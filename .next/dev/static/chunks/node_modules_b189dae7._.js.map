{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/motion-dom/dist/es/scroll/observe.mjs"],"sourcesContent":["import { frame, cancelFrame } from '../frameloop/frame.mjs';\n\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = () => {\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.preUpdate(onFrame, true);\n    return () => cancelFrame(onFrame);\n}\n\nexport { observeTimeline };\n"],"names":[],"mappings":";;;;AAAA;;AAEA,SAAS,gBAAgB,MAAM,EAAE,QAAQ;IACrC,IAAI;IACJ,MAAM,UAAU;QACZ,MAAM,EAAE,WAAW,EAAE,GAAG;QACxB,MAAM,aAAa,gBAAgB,OAAO,IAAI,YAAY,KAAK;QAC/D,MAAM,WAAW,aAAa;QAC9B,IAAI,iBAAiB,UAAU;YAC3B,OAAO;QACX;QACA,eAAe;IACnB;IACA,8KAAK,CAAC,SAAS,CAAC,SAAS;IACzB,OAAO,IAAM,IAAA,oLAAW,EAAC;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/motion-dom/dist/es/resize/handle-element.mjs"],"sourcesContent":["import { isSVGElement } from '../utils/is-svg-element.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nconst getSize = (borderBoxAxis, svgAxis, htmlAxis) => (target, borderBoxSize) => {\n    if (borderBoxSize && borderBoxSize[0]) {\n        return borderBoxSize[0][(borderBoxAxis + \"Size\")];\n    }\n    else if (isSVGElement(target) && \"getBBox\" in target) {\n        return target.getBBox()[svgAxis];\n    }\n    else {\n        return target[htmlAxis];\n    }\n};\nconst getWidth = /*@__PURE__*/ getSize(\"inline\", \"width\", \"offsetWidth\");\nconst getHeight = /*@__PURE__*/ getSize(\"block\", \"height\", \"offsetHeight\");\nfunction notifyTarget({ target, borderBoxSize }) {\n    resizeHandlers.get(target)?.forEach((handler) => {\n        handler(target, {\n            get width() {\n                return getWidth(target, borderBoxSize);\n            },\n            get height() {\n                return getHeight(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer?.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers?.delete(handler);\n            if (!elementHandlers?.size) {\n                observer?.unobserve(element);\n            }\n        });\n    };\n}\n\nexport { resizeElement };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,iBAAiB,IAAI;AAC3B,IAAI;AACJ,MAAM,UAAU,CAAC,eAAe,SAAS,WAAa,CAAC,QAAQ;QAC3D,IAAI,iBAAiB,aAAa,CAAC,EAAE,EAAE;YACnC,OAAO,aAAa,CAAC,EAAE,CAAE,gBAAgB,OAAQ;QACrD,OACK,IAAI,IAAA,gMAAY,EAAC,WAAW,aAAa,QAAQ;YAClD,OAAO,OAAO,OAAO,EAAE,CAAC,QAAQ;QACpC,OACK;YACD,OAAO,MAAM,CAAC,SAAS;QAC3B;IACJ;AACA,MAAM,WAAW,WAAW,GAAG,QAAQ,UAAU,SAAS;AAC1D,MAAM,YAAY,WAAW,GAAG,QAAQ,SAAS,UAAU;AAC3D,SAAS,aAAa,EAAE,MAAM,EAAE,aAAa,EAAE;IAC3C,eAAe,GAAG,CAAC,SAAS,QAAQ,CAAC;QACjC,QAAQ,QAAQ;YACZ,IAAI,SAAQ;gBACR,OAAO,SAAS,QAAQ;YAC5B;YACA,IAAI,UAAS;gBACT,OAAO,UAAU,QAAQ;YAC7B;QACJ;IACJ;AACJ;AACA,SAAS,UAAU,OAAO;IACtB,QAAQ,OAAO,CAAC;AACpB;AACA,SAAS;IACL,IAAI,OAAO,mBAAmB,aAC1B;IACJ,WAAW,IAAI,eAAe;AAClC;AACA,SAAS,cAAc,MAAM,EAAE,OAAO;IAClC,IAAI,CAAC,UACD;IACJ,MAAM,WAAW,IAAA,kMAAe,EAAC;IACjC,SAAS,OAAO,CAAC,CAAC;QACd,IAAI,kBAAkB,eAAe,GAAG,CAAC;QACzC,IAAI,CAAC,iBAAiB;YAClB,kBAAkB,IAAI;YACtB,eAAe,GAAG,CAAC,SAAS;QAChC;QACA,gBAAgB,GAAG,CAAC;QACpB,UAAU,QAAQ;IACtB;IACA,OAAO;QACH,SAAS,OAAO,CAAC,CAAC;YACd,MAAM,kBAAkB,eAAe,GAAG,CAAC;YAC3C,iBAAiB,OAAO;YACxB,IAAI,CAAC,iBAAiB,MAAM;gBACxB,UAAU,UAAU;YACxB;QACJ;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/motion-dom/dist/es/resize/handle-window.mjs"],"sourcesContent":["const windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const info = {\n            get width() {\n                return window.innerWidth;\n            },\n            get height() {\n                return window.innerHeight;\n            },\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size &&\n            typeof windowResizeHandler === \"function\") {\n            window.removeEventListener(\"resize\", windowResizeHandler);\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nexport { resizeWindow };\n"],"names":[],"mappings":";;;;AAAA,MAAM,kBAAkB,IAAI;AAC5B,IAAI;AACJ,SAAS;IACL,sBAAsB;QAClB,MAAM,OAAO;YACT,IAAI,SAAQ;gBACR,OAAO,OAAO,UAAU;YAC5B;YACA,IAAI,UAAS;gBACT,OAAO,OAAO,WAAW;YAC7B;QACJ;QACA,gBAAgB,OAAO,CAAC,CAAC,WAAa,SAAS;IACnD;IACA,OAAO,gBAAgB,CAAC,UAAU;AACtC;AACA,SAAS,aAAa,QAAQ;IAC1B,gBAAgB,GAAG,CAAC;IACpB,IAAI,CAAC,qBACD;IACJ,OAAO;QACH,gBAAgB,MAAM,CAAC;QACvB,IAAI,CAAC,gBAAgB,IAAI,IACrB,OAAO,wBAAwB,YAAY;YAC3C,OAAO,mBAAmB,CAAC,UAAU;YACrC,sBAAsB;QAC1B;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/motion-dom/dist/es/resize/index.mjs"],"sourcesContent":["import { resizeElement } from './handle-element.mjs';\nimport { resizeWindow } from './handle-window.mjs';\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\nexport { resize };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,SAAS,OAAO,CAAC,EAAE,CAAC;IAChB,OAAO,OAAO,MAAM,aAAa,IAAA,6LAAY,EAAC,KAAK,IAAA,+LAAa,EAAC,GAAG;AACxE","ignoreList":[0]}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/motion-dom/dist/es/utils/transform.mjs"],"sourcesContent":["import { interpolate } from './interpolate.mjs';\n\nfunction transform(...args) {\n    const useImmediate = !Array.isArray(args[0]);\n    const argOffset = useImmediate ? 0 : -1;\n    const inputValue = args[0 + argOffset];\n    const inputRange = args[1 + argOffset];\n    const outputRange = args[2 + argOffset];\n    const options = args[3 + argOffset];\n    const interpolator = interpolate(inputRange, outputRange, options);\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nexport { transform };\n"],"names":[],"mappings":";;;;AAAA;;AAEA,SAAS,UAAU,GAAG,IAAI;IACtB,MAAM,eAAe,CAAC,MAAM,OAAO,CAAC,IAAI,CAAC,EAAE;IAC3C,MAAM,YAAY,eAAe,IAAI,CAAC;IACtC,MAAM,aAAa,IAAI,CAAC,IAAI,UAAU;IACtC,MAAM,aAAa,IAAI,CAAC,IAAI,UAAU;IACtC,MAAM,cAAc,IAAI,CAAC,IAAI,UAAU;IACvC,MAAM,UAAU,IAAI,CAAC,IAAI,UAAU;IACnC,MAAM,eAAe,IAAA,sLAAW,EAAC,YAAY,aAAa;IAC1D,OAAO,eAAe,aAAa,cAAc;AACrD","ignoreList":[0]}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/info.mjs"],"sourcesContent":["import { progress, velocityPerSecond } from 'motion-utils';\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[`scroll${position}`];\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nexport { createScrollInfo, updateScrollInfo };\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;;AAEA;;CAEC,GACD,MAAM,aAAa;AACnB,MAAM,iBAAiB,IAAM,CAAC;QAC1B,SAAS;QACT,QAAQ,EAAE;QACV,UAAU;QACV,cAAc;QACd,cAAc;QACd,cAAc;QACd,iBAAiB;QACjB,UAAU;IACd,CAAC;AACD,MAAM,mBAAmB,IAAM,CAAC;QAC5B,MAAM;QACN,GAAG;QACH,GAAG;IACP,CAAC;AACD,MAAM,OAAO;IACT,GAAG;QACC,QAAQ;QACR,UAAU;IACd;IACA,GAAG;QACC,QAAQ;QACR,UAAU;IACd;AACJ;AACA,SAAS,eAAe,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,IAAI;IACjD,MAAM,OAAO,IAAI,CAAC,SAAS;IAC3B,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,SAAS;IAC3C,MAAM,OAAO,KAAK,OAAO;IACzB,MAAM,WAAW,KAAK,IAAI;IAC1B,KAAK,OAAO,GAAG,OAAO,CAAC,CAAC,MAAM,EAAE,UAAU,CAAC;IAC3C,KAAK,YAAY,GAAG,OAAO,CAAC,CAAC,MAAM,EAAE,QAAQ,CAAC,GAAG,OAAO,CAAC,CAAC,MAAM,EAAE,QAAQ,CAAC;IAC3E,KAAK,MAAM,CAAC,MAAM,GAAG;IACrB,KAAK,MAAM,CAAC,EAAE,GAAG;IACjB,KAAK,MAAM,CAAC,EAAE,GAAG,KAAK,YAAY;IAClC,KAAK,QAAQ,GAAG,IAAA,yKAAQ,EAAC,GAAG,KAAK,YAAY,EAAE,KAAK,OAAO;IAC3D,MAAM,UAAU,OAAO;IACvB,KAAK,QAAQ,GACT,UAAU,aACJ,IACA,IAAA,mMAAiB,EAAC,KAAK,OAAO,GAAG,MAAM;AACrD;AACA,SAAS,iBAAiB,OAAO,EAAE,IAAI,EAAE,IAAI;IACzC,eAAe,SAAS,KAAK,MAAM;IACnC,eAAe,SAAS,KAAK,MAAM;IACnC,KAAK,IAAI,GAAG;AAChB","ignoreList":[0]}},
    {"offset": {"line": 230, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs"],"sourcesContent":["import { isHTMLElement } from 'motion-dom';\n\nfunction calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n"],"names":[],"mappings":";;;;AAAA;;AAEA,SAAS,UAAU,OAAO,EAAE,SAAS;IACjC,MAAM,QAAQ;QAAE,GAAG;QAAG,GAAG;IAAE;IAC3B,IAAI,UAAU;IACd,MAAO,WAAW,YAAY,UAAW;QACrC,IAAI,IAAA,kMAAa,EAAC,UAAU;YACxB,MAAM,CAAC,IAAI,QAAQ,UAAU;YAC7B,MAAM,CAAC,IAAI,QAAQ,SAAS;YAC5B,UAAU,QAAQ,YAAY;QAClC,OACK,IAAI,QAAQ,OAAO,KAAK,OAAO;YAChC;;;;;;aAMC,GACD,MAAM,iBAAiB,QAAQ,qBAAqB;YACpD,UAAU,QAAQ,aAAa;YAC/B,MAAM,oBAAoB,QAAQ,qBAAqB;YACvD,MAAM,CAAC,IAAI,eAAe,IAAI,GAAG,kBAAkB,IAAI;YACvD,MAAM,CAAC,IAAI,eAAe,GAAG,GAAG,kBAAkB,GAAG;QACzD,OACK,IAAI,mBAAmB,oBAAoB;YAC5C,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,QAAQ,OAAO;YAChC,MAAM,CAAC,IAAI;YACX,MAAM,CAAC,IAAI;YACX,IAAI,MAAM;YACV,IAAI,SAAS,QAAQ,UAAU;YAC/B,MAAO,CAAC,IAAK;gBACT,IAAI,OAAO,OAAO,KAAK,OAAO;oBAC1B,MAAM;gBACV;gBACA,SAAS,QAAQ,UAAU;YAC/B;YACA,UAAU;QACd,OACK;YACD;QACJ;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs"],"sourcesContent":["const namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nexport { namedEdges, resolveEdge };\n"],"names":[],"mappings":";;;;;;AAAA,MAAM,aAAa;IACf,OAAO;IACP,QAAQ;IACR,KAAK;AACT;AACA,SAAS,YAAY,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC;IACxC,IAAI,QAAQ;IACZ;;;KAGC,GACD,IAAI,QAAQ,YAAY;QACpB,OAAO,UAAU,CAAC,KAAK;IAC3B;IACA;;KAEC,GACD,IAAI,OAAO,SAAS,UAAU;QAC1B,MAAM,WAAW,WAAW;QAC5B,IAAI,KAAK,QAAQ,CAAC,OAAO;YACrB,QAAQ;QACZ,OACK,IAAI,KAAK,QAAQ,CAAC,MAAM;YACzB,OAAO,WAAW;QACtB,OACK,IAAI,KAAK,QAAQ,CAAC,OAAO;YAC1B,QAAQ,AAAC,WAAW,MAAO,SAAS,eAAe,CAAC,WAAW;QACnE,OACK,IAAI,KAAK,QAAQ,CAAC,OAAO;YAC1B,QAAQ,AAAC,WAAW,MAAO,SAAS,eAAe,CAAC,YAAY;QACpE,OACK;YACD,OAAO;QACX;IACJ;IACA;;KAEC,GACD,IAAI,OAAO,SAAS,UAAU;QAC1B,QAAQ,SAAS;IACrB;IACA,OAAO,QAAQ;AACnB","ignoreList":[0]}},
    {"offset": {"line": 330, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs"],"sourcesContent":["import { resolveEdge, namedEdges } from './edge.mjs';\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,gBAAgB;IAAC;IAAG;CAAE;AAC5B,SAAS,cAAc,MAAM,EAAE,eAAe,EAAE,YAAY,EAAE,WAAW;IACrE,IAAI,mBAAmB,MAAM,OAAO,CAAC,UAAU,SAAS;IACxD,IAAI,cAAc;IAClB,IAAI,iBAAiB;IACrB,IAAI,OAAO,WAAW,UAAU;QAC5B;;;;SAIC,GACD,mBAAmB;YAAC;YAAQ;SAAO;IACvC,OACK,IAAI,OAAO,WAAW,UAAU;QACjC,SAAS,OAAO,IAAI;QACpB,IAAI,OAAO,QAAQ,CAAC,MAAM;YACtB,mBAAmB,OAAO,KAAK,CAAC;QACpC,OACK;YACD;;;;aAIC,GACD,mBAAmB;gBAAC;gBAAQ,8MAAU,CAAC,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC;aAAC;QAClE;IACJ;IACA,cAAc,IAAA,+MAAW,EAAC,gBAAgB,CAAC,EAAE,EAAE,cAAc;IAC7D,iBAAiB,IAAA,+MAAW,EAAC,gBAAgB,CAAC,EAAE,EAAE;IAClD,OAAO,cAAc;AACzB","ignoreList":[0]}},
    {"offset": {"line": 377, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs"],"sourcesContent":["const ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nexport { ScrollOffset };\n"],"names":[],"mappings":";;;;AAAA,MAAM,eAAe;IACjB,OAAO;QACH;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;KACT;IACD,MAAM;QACF;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;KACT;IACD,KAAK;QACD;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;KACT;IACD,KAAK;QACD;YAAC;YAAG;SAAE;QACN;YAAC;YAAG;SAAE;KACT;AACL","ignoreList":[0]}},
    {"offset": {"line": 428, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs"],"sourcesContent":["import { interpolate, defaultOffset } from 'motion-dom';\nimport { clamp } from 'motion-utils';\nimport { calcInset } from './inset.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { ScrollOffset } from './presets.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n\nexport { resolveOffsets };\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,MAAM,QAAQ;IAAE,GAAG;IAAG,GAAG;AAAE;AAC3B,SAAS,cAAc,MAAM;IACzB,OAAO,aAAa,UAAU,OAAO,OAAO,KAAK,QAC3C,OAAO,OAAO,KACd;QAAE,OAAO,OAAO,WAAW;QAAE,QAAQ,OAAO,YAAY;IAAC;AACnE;AACA,SAAS,eAAe,SAAS,EAAE,IAAI,EAAE,OAAO;IAC5C,MAAM,EAAE,QAAQ,mBAAmB,mNAAY,CAAC,GAAG,EAAE,GAAG;IACxD,MAAM,EAAE,SAAS,SAAS,EAAE,OAAO,GAAG,EAAE,GAAG;IAC3C,MAAM,cAAc,SAAS,MAAM,WAAW;IAC9C,MAAM,QAAQ,WAAW,YAAY,IAAA,8MAAS,EAAC,QAAQ,aAAa;IACpE;;;;KAIC,GACD,MAAM,aAAa,WAAW,YACxB;QAAE,OAAO,UAAU,WAAW;QAAE,QAAQ,UAAU,YAAY;IAAC,IAC/D,cAAc;IACpB,MAAM,gBAAgB;QAClB,OAAO,UAAU,WAAW;QAC5B,QAAQ,UAAU,YAAY;IAClC;IACA;;;KAGC,GACD,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG;IAC3B;;;KAGC,GACD,IAAI,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW;IACxC,MAAM,aAAa,iBAAiB,MAAM;IAC1C,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,IAAK;QACjC,MAAM,SAAS,IAAA,mNAAa,EAAC,gBAAgB,CAAC,EAAE,EAAE,aAAa,CAAC,YAAY,EAAE,UAAU,CAAC,YAAY,EAAE,KAAK,CAAC,KAAK;QAClH,IAAI,CAAC,cAAc,WAAW,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,EAAE,EAAE;YAC7D,aAAa;QACjB;QACA,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,GAAG;IAC3B;IACA;;;KAGC,GACD,IAAI,YAAY;QACZ,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,IAAA,sLAAW,EAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,IAAA,gNAAa,EAAC,mBAAmB;YAAE,OAAO;QAAM;QACxG,IAAI,CAAC,KAAK,CAAC,mBAAmB,GAAG;eAAI,IAAI,CAAC,KAAK,CAAC,MAAM;SAAC;IAC3D;IACA,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,IAAA,mKAAK,EAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO;AAC/E","ignoreList":[0]}},
    {"offset": {"line": 504, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs"],"sourcesContent":["import { warnOnce } from 'motion-utils';\nimport { updateScrollInfo } from './info.mjs';\nimport { resolveOffsets } from './offsets/index.mjs';\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info);\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n\nexport { createOnScrollHandler };\n"],"names":[],"mappings":";;;;AA4BQ;AA5BR;AACA;AACA;;;;AAEA,SAAS,QAAQ,SAAS,EAAE,SAAS,SAAS,EAAE,IAAI;IAChD;;KAEC,GACD,KAAK,CAAC,CAAC,YAAY,GAAG;IACtB,KAAK,CAAC,CAAC,YAAY,GAAG;IACtB,IAAI,WAAW,WAAW;QACtB,IAAI,OAAO;QACX,MAAO,QAAQ,SAAS,UAAW;YAC/B,KAAK,CAAC,CAAC,YAAY,IAAI,KAAK,UAAU;YACtC,KAAK,CAAC,CAAC,YAAY,IAAI,KAAK,SAAS;YACrC,OAAO,KAAK,YAAY;QAC5B;IACJ;IACA,KAAK,CAAC,CAAC,YAAY,GACf,WAAW,YAAY,OAAO,WAAW,GAAG,OAAO,WAAW;IAClE,KAAK,CAAC,CAAC,YAAY,GACf,WAAW,YAAY,OAAO,YAAY,GAAG,OAAO,YAAY;IACpE,KAAK,CAAC,CAAC,eAAe,GAAG,UAAU,WAAW;IAC9C,KAAK,CAAC,CAAC,eAAe,GAAG,UAAU,YAAY;IAC/C;;;KAGC,GACD,wCAA2C;QACvC,IAAI,aAAa,UAAU,WAAW,WAAW;YAC7C,IAAA,6KAAQ,EAAC,iBAAiB,WAAW,QAAQ,KAAK,UAAU;QAChE;IACJ;AACJ;AACA,SAAS,sBAAsB,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;IAChE,OAAO;QACH,SAAS,CAAC;YACN,QAAQ,SAAS,QAAQ,MAAM,EAAE;YACjC,IAAA,yMAAgB,EAAC,SAAS,MAAM;YAChC,IAAI,QAAQ,MAAM,IAAI,QAAQ,MAAM,EAAE;gBAClC,IAAA,mNAAc,EAAC,SAAS,MAAM;YAClC;QACJ;QACA,QAAQ,IAAM,SAAS;IAC3B;AACJ","ignoreList":[0]}},
    {"offset": {"line": 558, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/track.mjs"],"sourcesContent":["import { resize, frame, cancelFrame, frameData } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { createScrollInfo } from './info.mjs';\nimport { createOnScrollHandler } from './on-scroll-handler.mjs';\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.scrollingElement ? window : element;\nfunction scrollInfo(onScroll, { container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp);\n            }\n            frame.preUpdate(notifyAll);\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify();\n            }\n        };\n        const listener = () => frame.read(measureAll);\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n        listener();\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            resizeListeners.get(container)?.();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n    };\n}\n\nexport { scrollInfo };\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,kBAAkB,IAAI;AAC5B,MAAM,kBAAkB,IAAI;AAC5B,MAAM,mBAAmB,IAAI;AAC7B,MAAM,iBAAiB,CAAC,UAAY,YAAY,SAAS,gBAAgB,GAAG,SAAS;AACrF,SAAS,WAAW,QAAQ,EAAE,EAAE,YAAY,SAAS,gBAAgB,EAAE,GAAG,SAAS,GAAG,CAAC,CAAC;IACpF,IAAI,CAAC,WACD,OAAO,iKAAI;IACf,IAAI,oBAAoB,iBAAiB,GAAG,CAAC;IAC7C;;;KAGC,GACD,IAAI,CAAC,mBAAmB;QACpB,oBAAoB,IAAI;QACxB,iBAAiB,GAAG,CAAC,WAAW;IACpC;IACA;;KAEC,GACD,MAAM,OAAO,IAAA,yMAAgB;IAC7B,MAAM,mBAAmB,IAAA,iOAAqB,EAAC,WAAW,UAAU,MAAM;IAC1E,kBAAkB,GAAG,CAAC;IACtB;;;KAGC,GACD,IAAI,CAAC,gBAAgB,GAAG,CAAC,YAAY;QACjC,MAAM,aAAa;YACf,KAAK,MAAM,WAAW,kBAAmB;gBACrC,QAAQ,OAAO,CAAC,kLAAS,CAAC,SAAS;YACvC;YACA,8KAAK,CAAC,SAAS,CAAC;QACpB;QACA,MAAM,YAAY;YACd,KAAK,MAAM,WAAW,kBAAmB;gBACrC,QAAQ,MAAM;YAClB;QACJ;QACA,MAAM,WAAW,IAAM,8KAAK,CAAC,IAAI,CAAC;QAClC,gBAAgB,GAAG,CAAC,WAAW;QAC/B,MAAM,SAAS,eAAe;QAC9B,OAAO,gBAAgB,CAAC,UAAU,UAAU;YAAE,SAAS;QAAK;QAC5D,IAAI,cAAc,SAAS,eAAe,EAAE;YACxC,gBAAgB,GAAG,CAAC,WAAW,IAAA,4KAAM,EAAC,WAAW;QACrD;QACA,OAAO,gBAAgB,CAAC,UAAU,UAAU;YAAE,SAAS;QAAK;QAC5D;IACJ;IACA,MAAM,WAAW,gBAAgB,GAAG,CAAC;IACrC,8KAAK,CAAC,IAAI,CAAC,UAAU,OAAO;IAC5B,OAAO;QACH,IAAA,oLAAW,EAAC;QACZ;;SAEC,GACD,MAAM,kBAAkB,iBAAiB,GAAG,CAAC;QAC7C,IAAI,CAAC,iBACD;QACJ,gBAAgB,MAAM,CAAC;QACvB,IAAI,gBAAgB,IAAI,EACpB;QACJ;;SAEC,GACD,MAAM,iBAAiB,gBAAgB,GAAG,CAAC;QAC3C,gBAAgB,MAAM,CAAC;QACvB,IAAI,gBAAgB;YAChB,eAAe,WAAW,mBAAmB,CAAC,UAAU;YACxD,gBAAgB,GAAG,CAAC;YACpB,OAAO,mBAAmB,CAAC,UAAU;QACzC;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 645, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/utils/get-timeline.mjs"],"sourcesContent":["import { supportsScrollTimeline } from 'motion-dom';\nimport { scrollInfo } from '../track.mjs';\n\nconst timelineCache = new Map();\nfunction scrollTimelineFallback(options) {\n    const currentTime = { value: 0 };\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis].progress * 100;\n    }, options);\n    return { currentTime, cancel };\n}\nfunction getTimeline({ source, container, ...options }) {\n    const { axis } = options;\n    if (source)\n        container = source;\n    const containerCache = timelineCache.get(container) ?? new Map();\n    timelineCache.set(container, containerCache);\n    const targetKey = options.target ?? \"self\";\n    const targetCache = containerCache.get(targetKey) ?? {};\n    const axisKey = axis + (options.offset ?? []).join(\",\");\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            !options.target && supportsScrollTimeline()\n                ? new ScrollTimeline({ source: container, axis })\n                : scrollTimelineFallback({ container, ...options });\n    }\n    return targetCache[axisKey];\n}\n\nexport { getTimeline };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,MAAM,gBAAgB,IAAI;AAC1B,SAAS,uBAAuB,OAAO;IACnC,MAAM,cAAc;QAAE,OAAO;IAAE;IAC/B,MAAM,SAAS,IAAA,oMAAU,EAAC,CAAC;QACvB,YAAY,KAAK,GAAG,IAAI,CAAC,QAAQ,IAAI,CAAC,CAAC,QAAQ,GAAG;IACtD,GAAG;IACH,OAAO;QAAE;QAAa;IAAO;AACjC;AACA,SAAS,YAAY,EAAE,MAAM,EAAE,SAAS,EAAE,GAAG,SAAS;IAClD,MAAM,EAAE,IAAI,EAAE,GAAG;IACjB,IAAI,QACA,YAAY;IAChB,MAAM,iBAAiB,cAAc,GAAG,CAAC,cAAc,IAAI;IAC3D,cAAc,GAAG,CAAC,WAAW;IAC7B,MAAM,YAAY,QAAQ,MAAM,IAAI;IACpC,MAAM,cAAc,eAAe,GAAG,CAAC,cAAc,CAAC;IACtD,MAAM,UAAU,OAAO,CAAC,QAAQ,MAAM,IAAI,EAAE,EAAE,IAAI,CAAC;IACnD,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE;QACvB,WAAW,CAAC,QAAQ,GAChB,CAAC,QAAQ,MAAM,IAAI,IAAA,oNAAsB,MACnC,IAAI,eAAe;YAAE,QAAQ;YAAW;QAAK,KAC7C,uBAAuB;YAAE;YAAW,GAAG,OAAO;QAAC;IAC7D;IACA,OAAO,WAAW,CAAC,QAAQ;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 690, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/attach-animation.mjs"],"sourcesContent":["import { observeTimeline } from 'motion-dom';\nimport { getTimeline } from './utils/get-timeline.mjs';\n\nfunction attachToAnimation(animation, options) {\n    const timeline = getTimeline(options);\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause();\n            return observeTimeline((progress) => {\n                valueAnimation.time = valueAnimation.duration * progress;\n            }, timeline);\n        },\n    });\n}\n\nexport { attachToAnimation };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,SAAS,kBAAkB,SAAS,EAAE,OAAO;IACzC,MAAM,WAAW,IAAA,wNAAW,EAAC;IAC7B,OAAO,UAAU,cAAc,CAAC;QAC5B,UAAU,QAAQ,MAAM,GAAG,YAAY;QACvC,SAAS,CAAC;YACN,eAAe,KAAK;YACpB,OAAO,IAAA,uLAAe,EAAC,CAAC;gBACpB,eAAe,IAAI,GAAG,eAAe,QAAQ,GAAG;YACpD,GAAG;QACP;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 715, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/attach-function.mjs"],"sourcesContent":["import { observeTimeline } from 'motion-dom';\nimport { scrollInfo } from './track.mjs';\nimport { getTimeline } from './utils/get-timeline.mjs';\n\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll) {\n    return onScroll.length === 2;\n}\nfunction attachToFunction(onScroll, options) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis].progress, info);\n        }, options);\n    }\n    else {\n        return observeTimeline(onScroll, getTimeline(options));\n    }\n}\n\nexport { attachToFunction };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA;;;CAGC,GACD,SAAS,mBAAmB,QAAQ;IAChC,OAAO,SAAS,MAAM,KAAK;AAC/B;AACA,SAAS,iBAAiB,QAAQ,EAAE,OAAO;IACvC,IAAI,mBAAmB,WAAW;QAC9B,OAAO,IAAA,oMAAU,EAAC,CAAC;YACf,SAAS,IAAI,CAAC,QAAQ,IAAI,CAAC,CAAC,QAAQ,EAAE;QAC1C,GAAG;IACP,OACK;QACD,OAAO,IAAA,uLAAe,EAAC,UAAU,IAAA,wNAAW,EAAC;IACjD;AACJ","ignoreList":[0]}},
    {"offset": {"line": 745, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/render/dom/scroll/index.mjs"],"sourcesContent":["import { noop } from 'motion-utils';\nimport { attachToAnimation } from './attach-animation.mjs';\nimport { attachToFunction } from './attach-function.mjs';\n\nfunction scroll(onScroll, { axis = \"y\", container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    const optionsWithDefaults = { axis, container, ...options };\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults);\n}\n\nexport { scroll };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,SAAS,OAAO,QAAQ,EAAE,EAAE,OAAO,GAAG,EAAE,YAAY,SAAS,gBAAgB,EAAE,GAAG,SAAS,GAAG,CAAC,CAAC;IAC5F,IAAI,CAAC,WACD,OAAO,iKAAI;IACf,MAAM,sBAAsB;QAAE;QAAM;QAAW,GAAG,OAAO;IAAC;IAC1D,OAAO,OAAO,aAAa,aACrB,IAAA,uNAAgB,EAAC,UAAU,uBAC3B,IAAA,yNAAiB,EAAC,UAAU;AACtC","ignoreList":[0]}},
    {"offset": {"line": 769, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/value/use-scroll.mjs"],"sourcesContent":["import { motionValue } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { useRef, useCallback, useEffect } from 'react';\nimport { scroll } from '../render/dom/scroll/index.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\n\nconst createScrollMotionValues = () => ({\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0),\n});\nconst isRefPending = (ref) => {\n    if (!ref)\n        return false;\n    return !ref.current;\n};\nfunction useScroll({ container, target, ...options } = {}) {\n    const values = useConstant(createScrollMotionValues);\n    const scrollAnimation = useRef(null);\n    const needsStart = useRef(false);\n    const start = useCallback(() => {\n        scrollAnimation.current = scroll((_progress, { x, y, }) => {\n            values.scrollX.set(x.current);\n            values.scrollXProgress.set(x.progress);\n            values.scrollY.set(y.current);\n            values.scrollYProgress.set(y.progress);\n        }, {\n            ...options,\n            container: container?.current || undefined,\n            target: target?.current || undefined,\n        });\n        return () => {\n            scrollAnimation.current?.();\n        };\n    }, [container, target, JSON.stringify(options.offset)]);\n    useIsomorphicLayoutEffect(() => {\n        needsStart.current = false;\n        if (isRefPending(container) || isRefPending(target)) {\n            needsStart.current = true;\n            return;\n        }\n        else {\n            return start();\n        }\n    }, [start]);\n    useEffect(() => {\n        if (needsStart.current) {\n            invariant(!isRefPending(container), \"Container ref is defined but not hydrated\", \"use-scroll-ref\");\n            invariant(!isRefPending(target), \"Target ref is defined but not hydrated\", \"use-scroll-ref\");\n            return start();\n        }\n        else {\n            return;\n        }\n    }, [start]);\n    return values;\n}\n\nexport { useScroll };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA,MAAM,2BAA2B,IAAM,CAAC;QACpC,SAAS,IAAA,gLAAW,EAAC;QACrB,SAAS,IAAA,gLAAW,EAAC;QACrB,iBAAiB,IAAA,gLAAW,EAAC;QAC7B,iBAAiB,IAAA,gLAAW,EAAC;IACjC,CAAC;AACD,MAAM,eAAe,CAAC;IAClB,IAAI,CAAC,KACD,OAAO;IACX,OAAO,CAAC,IAAI,OAAO;AACvB;AACA,SAAS,UAAU,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,SAAS,GAAG,CAAC,CAAC;IACrD,MAAM,SAAS,IAAA,6LAAW,EAAC;IAC3B,MAAM,kBAAkB,IAAA,uKAAM,EAAC;IAC/B,MAAM,aAAa,IAAA,uKAAM,EAAC;IAC1B,MAAM,QAAQ,IAAA,4KAAW;wCAAC;YACtB,gBAAgB,OAAO,GAAG,IAAA,gMAAM;gDAAC,CAAC,WAAW,EAAE,CAAC,EAAE,CAAC,EAAG;oBAClD,OAAO,OAAO,CAAC,GAAG,CAAC,EAAE,OAAO;oBAC5B,OAAO,eAAe,CAAC,GAAG,CAAC,EAAE,QAAQ;oBACrC,OAAO,OAAO,CAAC,GAAG,CAAC,EAAE,OAAO;oBAC5B,OAAO,eAAe,CAAC,GAAG,CAAC,EAAE,QAAQ;gBACzC;+CAAG;gBACC,GAAG,OAAO;gBACV,WAAW,WAAW,WAAW;gBACjC,QAAQ,QAAQ,WAAW;YAC/B;YACA;gDAAO;oBACH,gBAAgB,OAAO;gBAC3B;;QACJ;uCAAG;QAAC;QAAW;QAAQ,KAAK,SAAS,CAAC,QAAQ,MAAM;KAAE;IACtD,IAAA,uNAAyB;+CAAC;YACtB,WAAW,OAAO,GAAG;YACrB,IAAI,aAAa,cAAc,aAAa,SAAS;gBACjD,WAAW,OAAO,GAAG;gBACrB;YACJ,OACK;gBACD,OAAO;YACX;QACJ;8CAAG;QAAC;KAAM;IACV,IAAA,0KAAS;+BAAC;YACN,IAAI,WAAW,OAAO,EAAE;gBACpB,IAAA,wKAAS,EAAC,CAAC,aAAa,YAAY,6CAA6C;gBACjF,IAAA,wKAAS,EAAC,CAAC,aAAa,SAAS,0CAA0C;gBAC3E,OAAO;YACX,OACK;gBACD;YACJ;QACJ;8BAAG;QAAC;KAAM;IACV,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 857, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/value/use-motion-value.mjs"],"sourcesContent":["import { motionValue } from 'motion-dom';\nimport { useContext, useState, useEffect } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = useConstant(() => motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = useState(initial);\n        useEffect(() => value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;;;;;;;;;;;;;;;CAgBC,GACD,SAAS,eAAe,OAAO;IAC3B,MAAM,QAAQ,IAAA,6LAAW;6CAAC,IAAM,IAAA,gLAAW,EAAC;;IAC5C;;;;KAIC,GACD,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAA,2KAAU,EAAC,2MAAmB;IACnD,IAAI,UAAU;QACV,MAAM,GAAG,UAAU,GAAG,IAAA,yKAAQ,EAAC;QAC/B,IAAA,0KAAS;wCAAC,IAAM,MAAM,EAAE,CAAC,UAAU;uCAAY,EAAE;IACrD;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 907, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/value/use-combine-values.mjs"],"sourcesContent":["import { cancelFrame, frame } from 'motion-dom';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    const value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    const updateValue = () => value.set(combineValues());\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useIsomorphicLayoutEffect(() => {\n        const scheduleUpdate = () => frame.preRender(updateValue, false, true);\n        const subscriptions = values.map((v) => v.on(\"change\", scheduleUpdate));\n        return () => {\n            subscriptions.forEach((unsubscribe) => unsubscribe());\n            cancelFrame(updateValue);\n        };\n    });\n    return value;\n}\n\nexport { useCombineMotionValues };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,SAAS,uBAAuB,MAAM,EAAE,aAAa;IACjD;;KAEC,GACD,MAAM,QAAQ,IAAA,uMAAc,EAAC;IAC7B;;;;;KAKC,GACD,MAAM,cAAc,IAAM,MAAM,GAAG,CAAC;IACpC;;;KAGC,GACD;IACA;;;KAGC,GACD,IAAA,uNAAyB;4DAAC;YACtB,MAAM;mFAAiB,IAAM,8KAAK,CAAC,SAAS,CAAC,aAAa,OAAO;;YACjE,MAAM,gBAAgB,OAAO,GAAG;kFAAC,CAAC,IAAM,EAAE,EAAE,CAAC,UAAU;;YACvD;oEAAO;oBACH,cAAc,OAAO;4EAAC,CAAC,cAAgB;;oBACvC,IAAA,oLAAW,EAAC;gBAChB;;QACJ;;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 959, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/value/use-computed.mjs"],"sourcesContent":["import { collectMotionValues } from 'motion-dom';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\n\nfunction useComputed(compute) {\n    /**\n     * Open session of collectMotionValues. Any MotionValue that calls get()\n     * will be saved into this array.\n     */\n    collectMotionValues.current = [];\n    compute();\n    const value = useCombineMotionValues(collectMotionValues.current, compute);\n    /**\n     * Synchronously close session of collectMotionValues.\n     */\n    collectMotionValues.current = undefined;\n    return value;\n}\n\nexport { useComputed };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,SAAS,YAAY,OAAO;IACxB;;;KAGC,GACD,wLAAmB,CAAC,OAAO,GAAG,EAAE;IAChC;IACA,MAAM,QAAQ,IAAA,iNAAsB,EAAC,wLAAmB,CAAC,OAAO,EAAE;IAClE;;KAEC,GACD,wLAAmB,CAAC,OAAO,GAAG;IAC9B,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 984, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/framer-motion/dist/es/value/use-transform.mjs"],"sourcesContent":["import { transform } from 'motion-dom';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\nimport { useComputed } from './use-computed.mjs';\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    if (typeof input === \"function\") {\n        return useComputed(input);\n    }\n    const transformer = typeof inputRangeOrTransformer === \"function\"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], ([latest]) => transformer(latest));\n}\nfunction useListTransform(values, transformer) {\n    const latest = useConstant(() => []);\n    return useCombineMotionValues(values, () => {\n        latest.length = 0;\n        const numValues = values.length;\n        for (let i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\n\nexport { useTransform };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA,SAAS,aAAa,KAAK,EAAE,uBAAuB,EAAE,WAAW,EAAE,OAAO;IACtE,IAAI,OAAO,UAAU,YAAY;QAC7B,OAAO,IAAA,6LAAW,EAAC;IACvB;IACA,MAAM,cAAc,OAAO,4BAA4B,aACjD,0BACA,IAAA,kLAAS,EAAC,yBAAyB,aAAa;IACtD,OAAO,MAAM,OAAO,CAAC,SACf,iBAAiB,OAAO,eACxB,iBAAiB;QAAC;KAAM;yCAAE,CAAC,CAAC,OAAO,GAAK,YAAY;;AAC9D;AACA,SAAS,iBAAiB,MAAM,EAAE,WAAW;IACzC,MAAM,SAAS,IAAA,6LAAW;gDAAC,IAAM,EAAE;;IACnC,OAAO,IAAA,iNAAsB,EAAC;mDAAQ;YAClC,OAAO,MAAM,GAAG;YAChB,MAAM,YAAY,OAAO,MAAM;YAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,IAAK;gBAChC,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC,GAAG;YAC7B;YACA,OAAO,YAAY;QACvB;;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1027, "column": 0}, "map": {"version":3,"sources":["file:///E:/Frontend%20Projects/E-Commerce/node_modules/lenis/package.json","file:///E:/Frontend%20Projects/E-Commerce/node_modules/lenis/packages/core/src/maths.ts","file:///E:/Frontend%20Projects/E-Commerce/node_modules/lenis/packages/core/src/animate.ts","file:///E:/Frontend%20Projects/E-Commerce/node_modules/lenis/packages/core/src/debounce.ts","file:///E:/Frontend%20Projects/E-Commerce/node_modules/lenis/packages/core/src/dimensions.ts","file:///E:/Frontend%20Projects/E-Commerce/node_modules/lenis/packages/core/src/emitter.ts","file:///E:/Frontend%20Projects/E-Commerce/node_modules/lenis/packages/core/src/virtual-scroll.ts","file:///E:/Frontend%20Projects/E-Commerce/node_modules/lenis/packages/core/src/lenis.ts"],"sourcesContent":["{\n  \"name\": \"lenis\",\n  \"version\": \"1.3.17\",\n  \"description\": \"How smooth scroll should be\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"author\": \"darkroom.engineering\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/darkroomengineering/lenis.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/darkroomengineering/lenis/issues\"\n  },\n  \"homepage\": \"https://github.com/darkroomengineering/lenis\",\n  \"funding\": {\n    \"type\": \"github\",\n    \"url\": \"https://github.com/sponsors/darkroomengineering\"\n  },\n  \"keywords\": [\n    \"scroll\",\n    \"smooth\",\n    \"lenis\",\n    \"react\",\n    \"vue\"\n  ],\n  \"scripts\": {\n    \"build\": \"pnpm build:core && pnpm build:all\",\n    \"build:core\": \"tsup --config tsup.core.ts\",\n    \"build:all\": \"tsup\",\n    \"dev\": \"pnpm run -w --parallel /^dev:.*/\",\n    \"dev:build\": \"tsup --watch\",\n    \"dev:playground\": \"pnpm --filter playground dev\",\n    \"dev:nuxt\": \"pnpm --filter playground-nuxt dev\",\n    \"readme\": \"node ./scripts/update-readme.js\",\n    \"version:framer\": \"npm version prerelease --preid framer --force --no-git-tag-version\",\n    \"version:dev\": \"npm version prerelease --preid dev --force --no-git-tag-version\",\n    \"version:patch\": \"npm version patch --force --no-git-tag-version\",\n    \"version:minor\": \"npm version minor --force --no-git-tag-version\",\n    \"version:major\": \"npm version major --force --no-git-tag-version\",\n    \"postversion\": \"pnpm build && pnpm readme\",\n    \"publish:dev\": \"npm publish --tag dev\",\n    \"publish:framer\": \"npm publish --tag framer\",\n    \"publish:main\": \"npm publish\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"devDependencies\": {\n    \"terser\": \"^5.37.0\",\n    \"tsup\": \"^8.3.5\",\n    \"typescript\": \"^5.7.3\"\n  },\n  \"peerDependencies\": {\n    \"react\": \">=17.0.0\",\n    \"vue\": \">=3.0.0\",\n    \"@nuxt/kit\": \">=3.0.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react\": {\n      \"optional\": true\n    },\n    \"vue\": {\n      \"optional\": true\n    },\n    \"@nuxt/kit\": {\n      \"optional\": true\n    }\n  },\n  \"unpkg\": \"./dist/lenis.mjs\",\n  \"main\": \"./dist/lenis.mjs\",\n  \"module\": \"./dist/lenis.mjs\",\n  \"types\": \"./dist/lenis.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/lenis.d.ts\",\n      \"default\": \"./dist/lenis.mjs\"\n    },\n    \"./react\": {\n      \"types\": \"./dist/lenis-react.d.ts\",\n      \"default\": \"./dist/lenis-react.mjs\"\n    },\n    \"./snap\": {\n      \"types\": \"./dist/lenis-snap.d.ts\",\n      \"default\": \"./dist/lenis-snap.mjs\"\n    },\n    \"./vue\": {\n      \"types\": \"./dist/lenis-vue.d.ts\",\n      \"default\": \"./dist/lenis-vue.mjs\"\n    },\n    \"./nuxt\": {\n      \"default\": \"./dist/lenis-vue-nuxt.mjs\"\n    },\n    \"./nuxt/runtime/*\": {\n      \"default\": \"./dist/nuxt/runtime/*.mjs\"\n    },\n    \"./dist/*\": \"./dist/*\"\n  }\n}\n","/**\n * Clamp a value between a minimum and maximum value\n *\n * @param min Minimum value\n * @param input Value to clamp\n * @param max Maximum value\n * @returns Clamped value\n */\nexport function clamp(min: number, input: number, max: number) {\n  return Math.max(min, Math.min(input, max))\n}\n\n/**\n * Truncate a floating-point number to a specified number of decimal places\n *\n * @param value Value to truncate\n * @param decimals Number of decimal places to truncate to\n * @returns Truncated value\n */\nexport function truncate(value: number, decimals = 0) {\n  return parseFloat(value.toFixed(decimals))\n}\n\n/**\n *  Linearly interpolate between two values using an amount (0 <= t <= 1)\n *\n * @param x First value\n * @param y Second value\n * @param t Amount to interpolate (0 <= t <= 1)\n * @returns Interpolated value\n */\nexport function lerp(x: number, y: number, t: number) {\n  return (1 - t) * x + t * y\n}\n\n/**\n * Damp a value over time using a damping factor\n * {@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}\n *\n * @param x Initial value\n * @param y Target value\n * @param lambda Damping factor\n * @param dt Time elapsed since the last update\n * @returns Damped value\n */\nexport function damp(x: number, y: number, lambda: number, deltaTime: number) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime))\n}\n\n/**\n * Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\n * {@link https://anguscroll.com/just/just-modulo}\n *\n * @param n Dividend\n * @param d Divisor\n * @returns Modulo\n */\nexport function modulo(n: number, d: number) {\n  return ((n % d) + d) % d\n}\n","import { clamp, damp } from './maths'\r\nimport type { EasingFunction, FromToOptions, OnUpdateCallback } from './types'\r\n\r\n/**\r\n * Animate class to handle value animations with lerping or easing\r\n *\r\n * @example\r\n * const animate = new Animate()\r\n * animate.fromTo(0, 100, { duration: 1, easing: (t) => t })\r\n * animate.advance(0.5) // 50\r\n */\r\nexport class Animate {\r\n  isRunning = false\r\n  value = 0\r\n  from = 0\r\n  to = 0\r\n  currentTime = 0\r\n\r\n  // These are instanciated in the fromTo method\r\n  lerp?: number\r\n  duration?: number\r\n  easing?: EasingFunction\r\n  onUpdate?: OnUpdateCallback\r\n\r\n  /**\r\n   * Advance the animation by the given delta time\r\n   *\r\n   * @param deltaTime - The time in seconds to advance the animation\r\n   */\r\n  advance(deltaTime: number) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.duration && this.easing) {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    } else if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      // If no easing or lerp, just jump to the end value\r\n      this.value = this.to\r\n      completed = true\r\n    }\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n  }\r\n\r\n  /** Stop the animation */\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  /**\r\n   * Set up the animation from a starting value to an ending value\r\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\r\n   *\r\n   * @param from - The starting value\r\n   * @param to - The ending value\r\n   * @param options - Options for the animation\r\n   */\r\n  fromTo(\r\n    from: number,\r\n    to: number,\r\n    { lerp, duration, easing, onStart, onUpdate }: FromToOptions\r\n  ) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","export function debounce<CB extends (...args: any[]) => void>(\n  callback: CB,\n  delay: number\n) {\n  let timer: number | undefined\n  return function <T>(this: T, ...args: Parameters<typeof callback>) {\n    let context = this\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      timer = undefined\n      callback.apply(context, args)\n    }, delay)\n  }\n}\n","import { debounce } from './debounce'\n\n/**\n * Dimensions class to handle the size of the content and wrapper\n *\n * @example\n * const dimensions = new Dimensions(wrapper, content)\n * dimensions.on('resize', (e) => {\n *   console.log(e.width, e.height)\n * })\n */\nexport class Dimensions {\n  width = 0\n  height = 0\n  scrollHeight = 0\n  scrollWidth = 0\n\n  // These are instanciated in the constructor as they need information from the options\n  private debouncedResize?: (...args: unknown[]) => void\n  private wrapperResizeObserver?: ResizeObserver\n  private contentResizeObserver?: ResizeObserver\n\n  constructor(\n    private wrapper: HTMLElement | Window | Element,\n    private content: HTMLElement | Element,\n    { autoResize = true, debounce: debounceValue = 250 } = {}\n  ) {\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue)\n\n      if (this.wrapper instanceof Window) {\n        window.addEventListener('resize', this.debouncedResize, false)\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize)\n        this.wrapperResizeObserver.observe(this.wrapper)\n      }\n\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize)\n      this.contentResizeObserver.observe(this.content)\n    }\n\n    this.resize()\n  }\n\n  destroy() {\n    this.wrapperResizeObserver?.disconnect()\n    this.contentResizeObserver?.disconnect()\n\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener('resize', this.debouncedResize, false)\n    }\n  }\n\n  resize = () => {\n    this.onWrapperResize()\n    this.onContentResize()\n  }\n\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth\n      this.height = window.innerHeight\n    } else {\n      this.width = this.wrapper.clientWidth\n      this.height = this.wrapper.clientHeight\n    }\n  }\n\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight\n      this.scrollWidth = this.content.scrollWidth\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight\n      this.scrollWidth = this.wrapper.scrollWidth\n    }\n  }\n\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height,\n    }\n  }\n}\n","/**\n * Emitter class to handle events\n * @example\n * const emitter = new Emitter()\n * emitter.on('event', (data) => {\n *   console.log(data)\n * })\n * emitter.emit('event', 'data')\n */\nexport class Emitter {\n  private events: Record<\n    string,\n    Array<(...args: unknown[]) => void> | undefined\n  > = {}\n\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event: string, ...args: unknown[]) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args)\n    }\n  }\n\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on<CB extends (...args: any[]) => void>(event: string, cb: CB) {\n    // Add the callback to the event's callback list, or create a new list with the callback\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n\n    // Return an unsubscribe function\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\n    }\n  }\n\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off<CB extends (...args: any[]) => void>(event: string, callback: CB) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\n  }\n\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {}\n  }\n}\n","import { Emitter } from './emitter'\r\nimport type { VirtualScrollCallback } from './types'\r\n\r\nconst LINE_HEIGHT = 100 / 6\r\nconst listenerOptions: AddEventListenerOptions = { passive: false }\r\n\r\nexport class VirtualScroll {\r\n  touchStart = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  lastDelta = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  window = {\r\n    width: 0,\r\n    height: 0,\r\n  }\r\n  private emitter = new Emitter()\r\n\r\n  constructor(\r\n    private element: HTMLElement,\r\n    private options = { wheelMultiplier: 1, touchMultiplier: 1 }\r\n  ) {\r\n    window.addEventListener('resize', this.onWindowResize, false)\r\n    this.onWindowResize()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.addEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener('touchend', this.onTouchEnd, listenerOptions)\r\n  }\r\n\r\n  /**\r\n   * Add an event listener for the given event and callback\r\n   *\r\n   * @param event Event name\r\n   * @param callback Callback function\r\n   */\r\n  on(event: string, callback: VirtualScrollCallback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  /** Remove all event listeners and clean up */\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    window.removeEventListener('resize', this.onWindowResize, false)\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.removeEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchend',\r\n      this.onTouchEnd,\r\n      listenerOptions\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Event handler for 'touchstart' event\r\n   *\r\n   * @param event Touch event\r\n   */\r\n  onTouchStart = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX: 0,\r\n      deltaY: 0,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'touchmove' event */\r\n  onTouchMove = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event: TouchEvent) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'wheel' event */\r\n  onWheel = (event: WheelEvent) => {\r\n    let { deltaX, deltaY, deltaMode } = event\r\n\r\n    const multiplierX =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1\r\n    const multiplierY =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1\r\n\r\n    deltaX *= multiplierX\r\n    deltaY *= multiplierY\r\n\r\n    deltaX *= this.options.wheelMultiplier\r\n    deltaY *= this.options.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n\r\n  onWindowResize = () => {\r\n    this.window = {\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    }\r\n  }\r\n}\r\n","import { version } from '../../../package.json'\nimport { Animate } from './animate'\nimport { Dimensions } from './dimensions'\nimport { Emitter } from './emitter'\nimport { clamp, modulo } from './maths'\nimport type {\n  LenisEvent,\n  LenisOptions,\n  ScrollCallback,\n  Scrolling,\n  ScrollToOptions,\n  UserData,\n  VirtualScrollCallback,\n  VirtualScrollData,\n} from './types'\nimport { VirtualScroll } from './virtual-scroll'\n\n// Technical explanation\n// - listen to 'wheel' events\n// - prevent 'wheel' event to prevent scroll\n// - normalize wheel delta\n// - add delta to targetScroll\n// - animate scroll to targetScroll (smooth context)\n// - if animation is not running, listen to 'scroll' events (native context)\n\ntype OptionalPick<T, F extends keyof T> = Omit<T, F> & Partial<Pick<T, F>>\n\nconst defaultEasing = (t: number) => Math.min(1, 1.001 - Math.pow(2, -10 * t))\n\nexport class Lenis {\n  private _isScrolling: Scrolling = false // true when scroll is animating\n  private _isStopped = false // true if user should not be able to scroll - enable/disable programmatically\n  private _isLocked = false // same as isStopped but enabled/disabled when scroll reaches target\n  private _preventNextNativeScrollEvent = false\n  private _resetVelocityTimeout: ReturnType<typeof setTimeout> | null = null\n  private _rafId: number | null = null\n\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching?: boolean\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData: UserData = {}\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0\n  /**\n   * The direction of the scroll\n   */\n  direction: 1 | -1 | 0 = 0\n  /**\n   * The options passed to the lenis instance\n   */\n  options: OptionalPick<\n    Required<LenisOptions>,\n    'duration' | 'easing' | 'prevent' | 'virtualScroll'\n  >\n  /**\n   * The target scroll value\n   */\n  targetScroll: number\n  /**\n   * The animated scroll value\n   */\n  animatedScroll: number\n\n  // These are instanciated here as they don't need information from the options\n  private readonly animate = new Animate()\n  private readonly emitter = new Emitter()\n  // These are instanciated in the constructor as they need information from the options\n  readonly dimensions: Dimensions // This is not private because it's used in the Snap class\n  private readonly virtualScroll: VirtualScroll\n\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration, // in seconds\n    easing,\n    lerp = 0.1,\n    infinite = false,\n    orientation = 'vertical', // vertical, horizontal\n    gestureOrientation = orientation === 'horizontal' ? 'both' : 'vertical', // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false, // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    // @ts-ignore: this will be deprecated in the future\n    __experimental__naiveDimensions = false,\n    naiveDimensions = __experimental__naiveDimensions,\n    stopInertiaOnNavigate = false,\n  }: LenisOptions = {}) {\n    // Set version\n    window.lenisVersion = version\n\n    // Check if wrapper is <html>, fallback to window\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    // Setup options\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      naiveDimensions,\n      stopInertiaOnNavigate,\n    }\n\n    // Setup dimensions instance\n    this.dimensions = new Dimensions(wrapper, content, { autoResize })\n\n    // Setup class name\n    this.updateClassName()\n\n    // Set the initial scroll value for all scroll information\n    this.targetScroll = this.animatedScroll = this.actualScroll\n\n    // Add event listeners\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, false)\n\n    this.options.wrapper.addEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.addEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.options.wrapper.addEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    // Setup virtual scroll instance\n    this.virtualScroll = new VirtualScroll(eventsTarget as HTMLElement, {\n      touchMultiplier,\n      wheelMultiplier,\n    })\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\n\n    if (this.options.autoToggle) {\n      this.checkOverflow()\n      this.rootElement.addEventListener('transitionend', this.onTransitionEnd, {\n        passive: true,\n      })\n    }\n\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy()\n\n    this.options.wrapper.removeEventListener(\n      'scroll',\n      this.onNativeScroll,\n      false\n    )\n\n    this.options.wrapper.removeEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    this.options.wrapper.removeEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.removeEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.virtualScroll.destroy()\n    this.dimensions.destroy()\n\n    this.cleanUpClassName()\n\n    if (this._rafId) {\n      cancelAnimationFrame(this._rafId)\n    }\n  }\n\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   * @returns Unsubscribe function\n   */\n  on(event: 'scroll', callback: ScrollCallback): () => void\n  on(event: 'virtual-scroll', callback: VirtualScrollCallback): () => void\n  on(event: LenisEvent, callback: any) {\n    return this.emitter.on(event, callback)\n  }\n\n  /**\n   * Remove an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event: 'scroll', callback: ScrollCallback): void\n  off(event: 'virtual-scroll', callback: VirtualScrollCallback): void\n  off(event: LenisEvent, callback: any) {\n    return this.emitter.off(event, callback)\n  }\n\n  private onScrollEnd = (e: Event | CustomEvent) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === 'smooth' || this.isScrolling === false) {\n        e.stopPropagation()\n      }\n    }\n  }\n\n  private dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent('scrollend', {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true,\n        },\n      })\n    )\n  }\n\n  get overflow() {\n    const property = this.isHorizontal ? 'overflow-x' : 'overflow-y'\n    return getComputedStyle(this.rootElement)[\n      property as keyof CSSStyleDeclaration\n    ] as string\n  }\n\n  private checkOverflow() {\n    if (['hidden', 'clip'].includes(this.overflow)) {\n      this.internalStop()\n    } else {\n      this.internalStart()\n    }\n  }\n\n  private onTransitionEnd = (event: TransitionEvent) => {\n    if (event.propertyName.includes('overflow')) {\n      this.checkOverflow()\n    }\n  }\n\n  private setScroll(scroll: number) {\n    // behavior: 'instant' bypasses the scroll-behavior CSS property\n\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: 'instant' })\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: 'instant' })\n    }\n  }\n\n  private onClick = (event: PointerEvent | MouseEvent) => {\n    const path = event.composedPath()\n\n    // filter anchor elements (elements with a valid href attribute)\n    const anchorElements = path.filter(\n      (node) => node instanceof HTMLAnchorElement && node.getAttribute('href')\n    ) as HTMLAnchorElement[]\n\n    if (this.options.anchors) {\n      const anchor = anchorElements.find((node) =>\n        node.getAttribute('href')?.includes('#')\n      )\n      if (anchor) {\n        const href = anchor.getAttribute('href')\n\n        if (href) {\n          const options =\n            typeof this.options.anchors === 'object' && this.options.anchors\n              ? this.options.anchors\n              : undefined\n\n          const target = `#${href.split('#')[1]}`\n\n          this.scrollTo(target, options)\n        }\n      }\n    }\n\n    if (this.options.stopInertiaOnNavigate) {\n      const internalLink = anchorElements.find(\n        (node) => node.host === window.location.host\n      )\n\n      if (internalLink) {\n        this.reset()\n      }\n    }\n  }\n\n  private onPointerDown = (event: PointerEvent | MouseEvent) => {\n    if (event.button === 1) {\n      this.reset()\n    }\n  }\n\n  private onVirtualScroll = (data: VirtualScrollData) => {\n    if (\n      typeof this.options.virtualScroll === 'function' &&\n      this.options.virtualScroll(data) === false\n    )\n      return\n\n    const { deltaX, deltaY, event } = data\n\n    this.emitter.emit('virtual-scroll', { deltaX, deltaY, event })\n\n    // keep zoom feature\n    if (event.ctrlKey) return\n    // @ts-ignore\n    if (event.lenisStopPropagation) return\n\n    const isTouch = event.type.includes('touch')\n    const isWheel = event.type.includes('wheel')\n\n    this.isTouching = event.type === 'touchstart' || event.type === 'touchmove'\n    // if (event.type === 'touchend') {\n    //   console.log('touchend', this.scroll)\n    //   // this.lastVelocity = this.velocity\n    //   // this.velocity = 0\n    //   // this.isScrolling = false\n    //   this.emit({ type: 'touchend' })\n    //   // alert('touchend')\n    //   return\n    // }\n\n    const isClickOrTap = deltaX === 0 && deltaY === 0\n\n    const isTapToStop =\n      this.options.syncTouch &&\n      isTouch &&\n      event.type === 'touchstart' &&\n      isClickOrTap &&\n      !this.isStopped &&\n      !this.isLocked\n\n    if (isTapToStop) {\n      this.reset()\n      return\n    }\n\n    // const isPullToRefresh =\n    //   this.options.gestureOrientation === 'vertical' &&\n    //   this.scroll === 0 &&\n    //   !this.options.infinite &&\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\n\n    const isUnknownGesture =\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\n\n    if (isClickOrTap || isUnknownGesture) {\n      // console.log('prevent')\n      return\n    }\n\n    // catch if scrolling on nested scroll elements\n    let composedPath = event.composedPath()\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\n\n    const prevent = this.options.prevent\n\n    if (\n      !!composedPath.find(\n        (node) =>\n          node instanceof HTMLElement &&\n          ((typeof prevent === 'function' && prevent?.(node)) ||\n            node.hasAttribute?.('data-lenis-prevent') ||\n            (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\n            (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\n            (this.options.allowNestedScroll &&\n              this.checkNestedScroll(node, { deltaX, deltaY })))\n      )\n    )\n      return\n\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault() // this will stop forwarding the event to the parent, this is problematic\n      }\n      return\n    }\n\n    const isSmooth =\n      (this.options.syncTouch && isTouch) ||\n      (this.options.smoothWheel && isWheel)\n\n    if (!isSmooth) {\n      this.isScrolling = 'native'\n      this.animate.stop()\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      return\n    }\n\n    let delta = deltaY\n    if (this.options.gestureOrientation === 'both') {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\n    } else if (this.options.gestureOrientation === 'horizontal') {\n      delta = deltaX\n    }\n\n    if (\n      !this.options.overscroll ||\n      this.options.infinite ||\n      (this.options.wrapper !== window &&\n        this.limit > 0 &&\n        ((this.animatedScroll > 0 && this.animatedScroll < this.limit) ||\n          (this.animatedScroll === 0 && deltaY > 0) ||\n          (this.animatedScroll === this.limit && deltaY < 0)))\n    ) {\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      // event.stopPropagation()\n    }\n\n    if (event.cancelable) {\n      event.preventDefault()\n    }\n\n    const isSyncTouch = isTouch && this.options.syncTouch\n    const isTouchEnd = isTouch && event.type === 'touchend'\n\n    const hasTouchInertia = isTouchEnd\n\n    if (hasTouchInertia) {\n      // delta = this.velocity * this.options.touchInertiaMultiplier\n      delta =\n        Math.sign(this.velocity) *\n        Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent)\n    }\n\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(isSyncTouch\n        ? {\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\n          }\n        : {\n            lerp: this.options.lerp,\n            duration: this.options.duration,\n            easing: this.options.easing,\n          }),\n    })\n  }\n\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize()\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.emit()\n  }\n\n  private emit() {\n    this.emitter.emit('scroll', this)\n  }\n\n  private onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout)\n      this._resetVelocityTimeout = null\n    }\n\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false\n      return\n    }\n\n    if (this.isScrolling === false || this.isScrolling === 'native') {\n      const lastScroll = this.animatedScroll\n      this.animatedScroll = this.targetScroll = this.actualScroll\n      this.lastVelocity = this.velocity\n      this.velocity = this.animatedScroll - lastScroll\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      ) as Lenis['direction']\n\n      if (!this.isStopped) {\n        this.isScrolling = 'native'\n      }\n\n      this.emit()\n\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity\n          this.velocity = 0\n          this.isScrolling = false\n          this.emit()\n        }, 400)\n      }\n    }\n  }\n\n  private reset() {\n    this.isLocked = false\n    this.isScrolling = false\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.lastVelocity = this.velocity = 0\n    this.animate.stop()\n  }\n\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty('overflow')\n      return\n    }\n\n    this.internalStart()\n  }\n\n  private internalStart() {\n    if (!this.isStopped) return\n\n    this.reset()\n    this.isStopped = false\n    this.emit()\n  }\n\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty('overflow', 'clip')\n      return\n    }\n\n    this.internalStop()\n  }\n\n  private internalStop() {\n    if (this.isStopped) return\n\n    this.reset()\n    this.isStopped = true\n    this.emit()\n  }\n\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time: number) => {\n    const deltaTime = time - (this.time || time)\n    this.time = time\n\n    this.animate.advance(deltaTime * 0.001)\n\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(\n    target: number | string | HTMLElement,\n    {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      programmatic = true, // called from outside of the class\n      lerp = programmatic ? this.options.lerp : undefined,\n      duration = programmatic ? this.options.duration : undefined,\n      easing = programmatic ? this.options.easing : undefined,\n      onStart,\n      onComplete,\n      force = false, // scroll even if stopped\n      userData,\n    }: ScrollToOptions = {}\n  ) {\n    if ((this.isStopped || this.isLocked) && !force) return\n\n    // keywords\n    if (\n      typeof target === 'string' &&\n      ['top', 'left', 'start', '#'].includes(target)\n    ) {\n      target = 0\n    } else if (\n      typeof target === 'string' &&\n      ['bottom', 'right', 'end'].includes(target)\n    ) {\n      target = this.limit\n    } else {\n      let node\n\n      if (typeof target === 'string') {\n        // CSS selector\n        node = document.querySelector(target)\n\n        if (!node) {\n          if (target === '#top') {\n            target = 0\n          } else {\n            console.warn('Lenis: Target not found', target)\n          }\n        }\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        // Node element\n        node = target\n      }\n\n      if (node) {\n        if (this.options.wrapper !== window) {\n          // nested scroll offset correction\n          const wrapperRect = this.rootElement.getBoundingClientRect()\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\n        }\n\n        const rect = node.getBoundingClientRect()\n\n        target =\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\n      }\n    }\n\n    if (typeof target !== 'number') return\n\n    target += offset\n    target = Math.round(target)\n\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll\n\n        const distance = target - this.animatedScroll\n\n        if (distance > this.limit / 2) {\n          target = target - this.limit\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit)\n    }\n\n    if (target === this.targetScroll) {\n      onStart?.(this)\n      onComplete?.(this)\n      return\n    }\n\n    this.userData = userData ?? {}\n\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target\n      this.setScroll(this.scroll)\n      this.reset()\n      this.preventNextNativeScrollEvent()\n      this.emit()\n      onComplete?.(this)\n      this.userData = {}\n\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent()\n      })\n      return\n    }\n\n    if (!programmatic) {\n      this.targetScroll = target\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp,\n      onStart: () => {\n        // started\n        if (lock) this.isLocked = true\n        this.isScrolling = 'smooth'\n        onStart?.(this)\n      },\n      onUpdate: (value: number, completed: boolean) => {\n        this.isScrolling = 'smooth'\n\n        // updated\n        this.lastVelocity = this.velocity\n        this.velocity = value - this.animatedScroll\n        this.direction = Math.sign(this.velocity) as Lenis['direction']\n\n        this.animatedScroll = value\n        this.setScroll(this.scroll)\n\n        if (programmatic) {\n          // wheel during programmatic should stop it\n          this.targetScroll = value\n        }\n\n        if (!completed) this.emit()\n\n        if (completed) {\n          this.reset()\n          this.emit()\n          onComplete?.(this)\n          this.userData = {}\n\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent()\n          })\n\n          // avoid emitting event twice\n          this.preventNextNativeScrollEvent()\n        }\n      },\n    })\n  }\n\n  private preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true\n\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false\n    })\n  }\n\n  private checkNestedScroll(\n    node: HTMLElement,\n    { deltaX, deltaY }: { deltaX: number; deltaY: number }\n  ) {\n    const time = Date.now()\n\n    // @ts-ignore\n    const cache = (node._lenis ??= {})\n\n    let hasOverflowX,\n      hasOverflowY,\n      isScrollableX,\n      isScrollableY,\n      scrollWidth,\n      scrollHeight,\n      clientWidth,\n      clientHeight\n\n    const gestureOrientation = this.options.gestureOrientation\n\n    if (time - (cache.time ?? 0) > 2000) {\n      cache.time = Date.now()\n\n      const computedStyle = window.getComputedStyle(node)\n      cache.computedStyle = computedStyle\n\n      const overflowXString = computedStyle.overflowX\n      const overflowYString = computedStyle.overflowY\n\n      hasOverflowX = ['auto', 'overlay', 'scroll'].includes(overflowXString)\n      hasOverflowY = ['auto', 'overlay', 'scroll'].includes(overflowYString)\n      cache.hasOverflowX = hasOverflowX\n      cache.hasOverflowY = hasOverflowY\n\n      if (!hasOverflowX && !hasOverflowY) return false // if no overflow, it's not scrollable no matter what, early return saves some computations\n      if (gestureOrientation === 'vertical' && !hasOverflowY) return false\n      if (gestureOrientation === 'horizontal' && !hasOverflowX) return false\n\n      scrollWidth = node.scrollWidth\n      scrollHeight = node.scrollHeight\n\n      clientWidth = node.clientWidth\n      clientHeight = node.clientHeight\n\n      isScrollableX = scrollWidth > clientWidth\n      isScrollableY = scrollHeight > clientHeight\n\n      cache.isScrollableX = isScrollableX\n      cache.isScrollableY = isScrollableY\n      cache.scrollWidth = scrollWidth\n      cache.scrollHeight = scrollHeight\n      cache.clientWidth = clientWidth\n      cache.clientHeight = clientHeight\n    } else {\n      isScrollableX = cache.isScrollableX\n      isScrollableY = cache.isScrollableY\n      hasOverflowX = cache.hasOverflowX\n      hasOverflowY = cache.hasOverflowY\n      scrollWidth = cache.scrollWidth\n      scrollHeight = cache.scrollHeight\n      clientWidth = cache.clientWidth\n      clientHeight = cache.clientHeight\n    }\n\n    if (\n      (!hasOverflowX && !hasOverflowY) ||\n      (!isScrollableX && !isScrollableY)\n    ) {\n      return false\n    }\n\n    if (gestureOrientation === 'vertical' && (!hasOverflowY || !isScrollableY))\n      return false\n\n    if (\n      gestureOrientation === 'horizontal' &&\n      (!hasOverflowX || !isScrollableX)\n    )\n      return false\n\n    let orientation: 'x' | 'y' | undefined\n\n    if (gestureOrientation === 'horizontal') {\n      orientation = 'x'\n    } else if (gestureOrientation === 'vertical') {\n      orientation = 'y'\n    } else {\n      const isScrollingX = deltaX !== 0\n      const isScrollingY = deltaY !== 0\n\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = 'x'\n      }\n\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = 'y'\n      }\n    }\n\n    if (!orientation) return false\n\n    let scroll, maxScroll, delta, hasOverflow, isScrollable\n\n    if (orientation === 'x') {\n      scroll = node.scrollLeft\n      maxScroll = scrollWidth - clientWidth\n      delta = deltaX\n\n      hasOverflow = hasOverflowX\n      isScrollable = isScrollableX\n    } else if (orientation === 'y') {\n      scroll = node.scrollTop\n      maxScroll = scrollHeight - clientHeight\n      delta = deltaY\n\n      hasOverflow = hasOverflowY\n      isScrollable = isScrollableY\n    } else {\n      return false\n    }\n\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0\n\n    return willScroll && hasOverflow && isScrollable\n  }\n\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return (\n      this.options.wrapper === window\n        ? document.documentElement\n        : this.options.wrapper\n    ) as HTMLElement\n  }\n\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\n    }\n  }\n\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === 'horizontal'\n  }\n\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    // value browser takes into account\n    // it has to be this way because of DOCTYPE declaration\n    const wrapper = this.options.wrapper as Window | HTMLElement\n\n    return this.isHorizontal\n      ? (wrapper as Window).scrollX ?? (wrapper as HTMLElement).scrollLeft\n      : (wrapper as Window).scrollY ?? (wrapper as HTMLElement).scrollTop\n  }\n\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite\n      ? modulo(this.animatedScroll, this.limit)\n      : this.animatedScroll\n  }\n\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    // avoid progress to be NaN\n    return this.limit === 0 ? 1 : this.scroll / this.limit\n  }\n\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling\n  }\n\n  private set isScrolling(value: Scrolling) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped\n  }\n\n  private set isStopped(value: boolean) {\n    if (this._isStopped !== value) {\n      this._isStopped = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked\n  }\n\n  private set isLocked(value: boolean) {\n    if (this._isLocked !== value) {\n      this._isLocked = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === 'smooth'\n  }\n\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = 'lenis'\n    if (this.options.autoToggle) className += ' lenis-autoToggle'\n    if (this.isStopped) className += ' lenis-stopped'\n    if (this.isLocked) className += ' lenis-locked'\n    if (this.isScrolling) className += ' lenis-scrolling'\n    if (this.isScrolling === 'smooth') className += ' lenis-smooth'\n    return className\n  }\n\n  private updateClassName() {\n    this.cleanUpClassName()\n\n    this.rootElement.className =\n      `${this.rootElement.className} ${this.className}`.trim()\n  }\n\n  private cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className\n      .replace(/lenis(-\\w+)?/g, '')\n      .trim()\n  }\n}\n"],"names":["lerp","lerp"],"mappings":"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"}}]
}