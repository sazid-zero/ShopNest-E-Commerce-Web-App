{"version":3,"sources":["../../../../node_modules/framer-motion/dist/es/value/use-scroll.mjs","../../../../node_modules/swiper/shared/ssr-window.esm.mjs","../../../../node_modules/swiper/shared/classes-to-selector.mjs","../../../../node_modules/swiper/swiper-react.mjs","../../../../node_modules/swiper/modules/grid.mjs","../../../../node_modules/swiper/shared/effect-init.mjs","../../../../src/components/BannerCarousel.tsx","../../../../src/components/FlashSale.tsx","../../../../src/components/ui/Catagories.tsx","../../../../src/components/BestSeller.tsx","../../../../src/components/Services.tsx","../../../../src/components/StoreBanner.tsx","../../../../node_modules/lenis/dist/lenis.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/index.mjs","../../../../node_modules/motion-dom/dist/es/scroll/observe.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/utils/get-timeline.mjs","../../../../node_modules/motion-dom/dist/es/resize/handle-element.mjs","../../../../node_modules/motion-dom/dist/es/resize/handle-window.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/info.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/index.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/edge.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/presets.mjs","../../../../src/components/Featured.tsx","../../../../src/components/LandingAnimationWrapper.tsx","../../../../src/components/SectionAnimator.tsx","../../../../src/app/page.tsx","../../../../node_modules/swiper/shared/update-swiper.mjs","../../../../node_modules/swiper/modules/parallax.mjs","../../../../node_modules/swiper/shared/effect-target.mjs","../../../../node_modules/swiper/modules/controller.mjs","../../../../node_modules/swiper/shared/effect-virtual-transition-end.mjs","../../../../node_modules/swiper/modules/history.mjs","../../../../node_modules/swiper/modules/autoplay.mjs","../../../../node_modules/swiper/shared/create-shadow.mjs","../../../../node_modules/swiper/modules/free-mode.mjs","../../../../node_modules/swiper/shared/create-element-if-not-defined.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/offsets/offset.mjs","../../../../node_modules/swiper/shared/utils.mjs","../../../../node_modules/motion-dom/dist/es/utils/transform.mjs","../../../../node_modules/framer-motion/dist/es/value/use-motion-value.mjs","../../../../node_modules/swiper/modules/manipulation.mjs","../../../../node_modules/swiper/modules/hash-navigation.mjs","../../../../node_modules/swiper/modules/thumbs.mjs","../../../../node_modules/swiper/modules/navigation.mjs","../../../../node_modules/motion-dom/dist/es/resize/index.mjs","../../../../node_modules/swiper/shared/update-on-virtual-data.mjs","../../../../node_modules/swiper/modules/virtual.mjs","../../../../node_modules/swiper/modules/keyboard.mjs","../../../../node_modules/swiper/modules/mousewheel.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/attach-animation.mjs","../../../../node_modules/swiper/modules/effect-cube.mjs","../../../../node_modules/swiper/modules/zoom.mjs","../../../../node_modules/framer-motion/dist/es/value/use-computed.mjs","../../../../node_modules/swiper/shared/swiper-core.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/attach-function.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/on-scroll-handler.mjs","../../../../node_modules/swiper/modules/a11y.mjs","../../../../node_modules/framer-motion/dist/es/value/use-combine-values.mjs","../../../../node_modules/swiper/modules/pagination.mjs","../../../../src/components/BestStores.tsx","../../../../node_modules/swiper/modules/effect-coverflow.mjs","../../../../node_modules/framer-motion/dist/es/value/use-transform.mjs","../../../../node_modules/framer-motion/dist/es/render/dom/scroll/track.mjs","../../../../node_modules/swiper/modules/scrollbar.mjs","../../../../node_modules/swiper/modules/effect-fade.mjs","../../../../node_modules/swiper/modules/effect-creative.mjs","../../../../node_modules/swiper/modules/effect-cards.mjs","../../../../node_modules/swiper/modules/effect-flip.mjs"],"sourcesContent":["import { motionValue } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { useRef, useCallback, useEffect } from 'react';\nimport { scroll } from '../render/dom/scroll/index.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\n\nconst createScrollMotionValues = () => ({\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0),\n});\nconst isRefPending = (ref) => {\n    if (!ref)\n        return false;\n    return !ref.current;\n};\nfunction useScroll({ container, target, ...options } = {}) {\n    const values = useConstant(createScrollMotionValues);\n    const scrollAnimation = useRef(null);\n    const needsStart = useRef(false);\n    const start = useCallback(() => {\n        scrollAnimation.current = scroll((_progress, { x, y, }) => {\n            values.scrollX.set(x.current);\n            values.scrollXProgress.set(x.progress);\n            values.scrollY.set(y.current);\n            values.scrollYProgress.set(y.progress);\n        }, {\n            ...options,\n            container: container?.current || undefined,\n            target: target?.current || undefined,\n        });\n        return () => {\n            scrollAnimation.current?.();\n        };\n    }, [container, target, JSON.stringify(options.offset)]);\n    useIsomorphicLayoutEffect(() => {\n        needsStart.current = false;\n        if (isRefPending(container) || isRefPending(target)) {\n            needsStart.current = true;\n            return;\n        }\n        else {\n            return start();\n        }\n    }, [start]);\n    useEffect(() => {\n        if (needsStart.current) {\n            invariant(!isRefPending(container), \"Container ref is defined but not hydrated\", \"use-scroll-ref\");\n            invariant(!isRefPending(target), \"Target ref is defined but not hydrated\", \"use-scroll-ref\");\n            return start();\n        }\n        else {\n            return;\n        }\n    }, [start]);\n    return values;\n}\n\nexport { useScroll };\n","/**\n * SSR Window 5.0.1\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2025, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: June 27, 2025\n */\n/* eslint-disable no-param-reassign */\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n}\nfunction extend(target = {}, src = {}) {\n  const noExtend = ['__proto__', 'constructor', 'prototype'];\n  Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {\n    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {\n      extend(target[key], src[key]);\n    }\n  });\n}\nconst ssrDocument = {\n  body: {},\n  addEventListener() {},\n  removeEventListener() {},\n  activeElement: {\n    blur() {},\n    nodeName: ''\n  },\n  querySelector() {\n    return null;\n  },\n  querySelectorAll() {\n    return [];\n  },\n  getElementById() {\n    return null;\n  },\n  createEvent() {\n    return {\n      initEvent() {}\n    };\n  },\n  createElement() {\n    return {\n      children: [],\n      childNodes: [],\n      style: {},\n      setAttribute() {},\n      getElementsByTagName() {\n        return [];\n      }\n    };\n  },\n  createElementNS() {\n    return {};\n  },\n  importNode() {\n    return null;\n  },\n  location: {\n    hash: '',\n    host: '',\n    hostname: '',\n    href: '',\n    origin: '',\n    pathname: '',\n    protocol: '',\n    search: ''\n  }\n};\nfunction getDocument() {\n  const doc = typeof document !== 'undefined' ? document : {};\n  extend(doc, ssrDocument);\n  return doc;\n}\nconst ssrWindow = {\n  document: ssrDocument,\n  navigator: {\n    userAgent: ''\n  },\n  location: {\n    hash: '',\n    host: '',\n    hostname: '',\n    href: '',\n    origin: '',\n    pathname: '',\n    protocol: '',\n    search: ''\n  },\n  history: {\n    replaceState() {},\n    pushState() {},\n    go() {},\n    back() {}\n  },\n  CustomEvent: function CustomEvent() {\n    return this;\n  },\n  addEventListener() {},\n  removeEventListener() {},\n  getComputedStyle() {\n    return {\n      getPropertyValue() {\n        return '';\n      }\n    };\n  },\n  Image() {},\n  Date() {},\n  screen: {},\n  setTimeout() {},\n  clearTimeout() {},\n  matchMedia() {\n    return {};\n  },\n  requestAnimationFrame(callback) {\n    if (typeof setTimeout === 'undefined') {\n      callback();\n      return null;\n    }\n    return setTimeout(callback, 0);\n  },\n  cancelAnimationFrame(id) {\n    if (typeof setTimeout === 'undefined') {\n      return;\n    }\n    clearTimeout(id);\n  }\n};\nfunction getWindow() {\n  const win = typeof window !== 'undefined' ? window : {};\n  extend(win, ssrWindow);\n  return win;\n}\n\nexport { getWindow as a, getDocument as g };\n","function classesToSelector(classes = '') {\n  // Escape all CSS selector special characters\n  return `.${classes.trim().replace(/([\\.:!+\\/()[\\]#>~*^$|=,'\"@{}\\\\])/g, '\\\\$1') // eslint-disable-line\n  .replace(/ /g, '.')}`;\n}\n\nexport { classesToSelector as c };\n","/**\n * Swiper React 12.1.0\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2026 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: January 28, 2026\n */\n\nimport React, { useEffect, useLayoutEffect, useContext, createContext, forwardRef, useState, useRef } from 'react';\nimport { S as Swiper$1 } from './shared/swiper-core.mjs';\nimport { g as getParams, m as mountSwiper, a as getChangedParams, u as updateOnVirtualData } from './shared/update-on-virtual-data.mjs';\nimport { d as uniqueClasses, w as wrapperClass, n as needsNavigation, b as needsScrollbar, a as needsPagination, e as extend, u as updateSwiper } from './shared/update-swiper.mjs';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction isChildSwiperSlide(child) {\n  return child.type && child.type.displayName && child.type.displayName.includes('SwiperSlide');\n}\nfunction processChildren(c) {\n  const slides = [];\n  React.Children.toArray(c).forEach(child => {\n    if (isChildSwiperSlide(child)) {\n      slides.push(child);\n    } else if (child.props && child.props.children) {\n      processChildren(child.props.children).forEach(slide => slides.push(slide));\n    }\n  });\n  return slides;\n}\nfunction getChildren(c) {\n  const slides = [];\n  const slots = {\n    'container-start': [],\n    'container-end': [],\n    'wrapper-start': [],\n    'wrapper-end': []\n  };\n  React.Children.toArray(c).forEach(child => {\n    if (isChildSwiperSlide(child)) {\n      slides.push(child);\n    } else if (child.props && child.props.slot && slots[child.props.slot]) {\n      slots[child.props.slot].push(child);\n    } else if (child.props && child.props.children) {\n      const foundSlides = processChildren(child.props.children);\n      if (foundSlides.length > 0) {\n        foundSlides.forEach(slide => slides.push(slide));\n      } else {\n        slots['container-end'].push(child);\n      }\n    } else {\n      slots['container-end'].push(child);\n    }\n  });\n  return {\n    slides,\n    slots\n  };\n}\n\nfunction renderVirtual(swiper, slides, virtualData) {\n  if (!virtualData) return null;\n  const getSlideIndex = index => {\n    let slideIndex = index;\n    if (index < 0) {\n      slideIndex = slides.length + index;\n    } else if (slideIndex >= slides.length) {\n      // eslint-disable-next-line\n      slideIndex = slideIndex - slides.length;\n    }\n    return slideIndex;\n  };\n  const style = swiper.isHorizontal() ? {\n    [swiper.rtlTranslate ? 'right' : 'left']: `${virtualData.offset}px`\n  } : {\n    top: `${virtualData.offset}px`\n  };\n  const {\n    from,\n    to\n  } = virtualData;\n  const loopFrom = swiper.params.loop ? -slides.length : 0;\n  const loopTo = swiper.params.loop ? slides.length * 2 : slides.length;\n  const slidesToRender = [];\n  for (let i = loopFrom; i < loopTo; i += 1) {\n    if (i >= from && i <= to) {\n      slidesToRender.push(slides[getSlideIndex(i)]);\n    }\n  }\n  return slidesToRender.map((child, index) => {\n    return /*#__PURE__*/React.cloneElement(child, {\n      swiper,\n      style,\n      key: child.props.virtualIndex || child.key || `slide-${index}`\n    });\n  });\n}\n\nfunction useIsomorphicLayoutEffect(callback, deps) {\n  // eslint-disable-next-line\n  if (typeof window === 'undefined') return useEffect(callback, deps);\n  return useLayoutEffect(callback, deps);\n}\n\nconst SwiperSlideContext = /*#__PURE__*/createContext(null);\nconst useSwiperSlide = () => {\n  return useContext(SwiperSlideContext);\n};\nconst SwiperContext = /*#__PURE__*/createContext(null);\nconst useSwiper = () => {\n  return useContext(SwiperContext);\n};\n\nconst Swiper = /*#__PURE__*/forwardRef(({\n  className,\n  tag: Tag = 'div',\n  wrapperTag: WrapperTag = 'div',\n  children,\n  onSwiper,\n  ...rest\n} = {}, externalElRef) => {\n  let eventsAssigned = false;\n  const [containerClasses, setContainerClasses] = useState('swiper');\n  const [virtualData, setVirtualData] = useState(null);\n  const [breakpointChanged, setBreakpointChanged] = useState(false);\n  const initializedRef = useRef(false);\n  const swiperElRef = useRef(null);\n  const swiperRef = useRef(null);\n  const oldPassedParamsRef = useRef(null);\n  const oldSlides = useRef(null);\n  const nextElRef = useRef(null);\n  const prevElRef = useRef(null);\n  const paginationElRef = useRef(null);\n  const scrollbarElRef = useRef(null);\n  const {\n    params: swiperParams,\n    passedParams,\n    rest: restProps,\n    events\n  } = getParams(rest);\n  const {\n    slides,\n    slots\n  } = getChildren(children);\n  const onBeforeBreakpoint = () => {\n    setBreakpointChanged(!breakpointChanged);\n  };\n  Object.assign(swiperParams.on, {\n    _containerClasses(swiper, classes) {\n      setContainerClasses(classes);\n    }\n  });\n  const initSwiper = () => {\n    // init swiper\n    Object.assign(swiperParams.on, events);\n    eventsAssigned = true;\n    const passParams = {\n      ...swiperParams\n    };\n    delete passParams.wrapperClass;\n    swiperRef.current = new Swiper$1(passParams);\n    if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {\n      swiperRef.current.virtual.slides = slides;\n      const extendWith = {\n        cache: false,\n        slides,\n        renderExternal: setVirtualData,\n        renderExternalUpdate: false\n      };\n      extend(swiperRef.current.params.virtual, extendWith);\n      extend(swiperRef.current.originalParams.virtual, extendWith);\n    }\n  };\n  if (!swiperElRef.current) {\n    initSwiper();\n  }\n\n  // Listen for breakpoints change\n  if (swiperRef.current) {\n    swiperRef.current.on('_beforeBreakpoint', onBeforeBreakpoint);\n  }\n  const attachEvents = () => {\n    if (eventsAssigned || !events || !swiperRef.current) return;\n    Object.keys(events).forEach(eventName => {\n      swiperRef.current.on(eventName, events[eventName]);\n    });\n  };\n  const detachEvents = () => {\n    if (!events || !swiperRef.current) return;\n    Object.keys(events).forEach(eventName => {\n      swiperRef.current.off(eventName, events[eventName]);\n    });\n  };\n  useEffect(() => {\n    return () => {\n      if (swiperRef.current) swiperRef.current.off('_beforeBreakpoint', onBeforeBreakpoint);\n    };\n  });\n\n  // set initialized flag\n  useEffect(() => {\n    if (!initializedRef.current && swiperRef.current) {\n      swiperRef.current.emitSlidesClasses();\n      initializedRef.current = true;\n    }\n  });\n\n  // mount swiper\n  useIsomorphicLayoutEffect(() => {\n    if (externalElRef) {\n      externalElRef.current = swiperElRef.current;\n    }\n    if (!swiperElRef.current) return;\n    if (swiperRef.current.destroyed) {\n      initSwiper();\n    }\n    mountSwiper({\n      el: swiperElRef.current,\n      nextEl: nextElRef.current,\n      prevEl: prevElRef.current,\n      paginationEl: paginationElRef.current,\n      scrollbarEl: scrollbarElRef.current,\n      swiper: swiperRef.current\n    }, swiperParams);\n    if (onSwiper && !swiperRef.current.destroyed) onSwiper(swiperRef.current);\n    // eslint-disable-next-line\n    return () => {\n      if (swiperRef.current && !swiperRef.current.destroyed) {\n        swiperRef.current.destroy(true, false);\n      }\n    };\n  }, []);\n\n  // watch for params change\n  useIsomorphicLayoutEffect(() => {\n    attachEvents();\n    const changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, c => c.key);\n    oldPassedParamsRef.current = passedParams;\n    oldSlides.current = slides;\n    if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {\n      updateSwiper({\n        swiper: swiperRef.current,\n        slides,\n        passedParams,\n        changedParams,\n        nextEl: nextElRef.current,\n        prevEl: prevElRef.current,\n        scrollbarEl: scrollbarElRef.current,\n        paginationEl: paginationElRef.current\n      });\n    }\n    return () => {\n      detachEvents();\n    };\n  });\n\n  // update on virtual update\n  useIsomorphicLayoutEffect(() => {\n    updateOnVirtualData(swiperRef.current);\n  }, [virtualData]);\n\n  // bypass swiper instance to slides\n  function renderSlides() {\n    if (swiperParams.virtual) {\n      return renderVirtual(swiperRef.current, slides, virtualData);\n    }\n    return slides.map((child, index) => {\n      return /*#__PURE__*/React.cloneElement(child, {\n        swiper: swiperRef.current,\n        swiperSlideIndex: index\n      });\n    });\n  }\n  return /*#__PURE__*/React.createElement(Tag, _extends({\n    ref: swiperElRef,\n    className: uniqueClasses(`${containerClasses}${className ? ` ${className}` : ''}`)\n  }, restProps), /*#__PURE__*/React.createElement(SwiperContext.Provider, {\n    value: swiperRef.current\n  }, slots['container-start'], /*#__PURE__*/React.createElement(WrapperTag, {\n    className: wrapperClass(swiperParams.wrapperClass)\n  }, slots['wrapper-start'], renderSlides(), slots['wrapper-end']), needsNavigation(swiperParams) && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n    ref: prevElRef,\n    className: \"swiper-button-prev\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    ref: nextElRef,\n    className: \"swiper-button-next\"\n  })), needsScrollbar(swiperParams) && /*#__PURE__*/React.createElement(\"div\", {\n    ref: scrollbarElRef,\n    className: \"swiper-scrollbar\"\n  }), needsPagination(swiperParams) && /*#__PURE__*/React.createElement(\"div\", {\n    ref: paginationElRef,\n    className: \"swiper-pagination\"\n  }), slots['container-end']));\n});\nSwiper.displayName = 'Swiper';\n\nconst SwiperSlide = /*#__PURE__*/forwardRef(({\n  tag: Tag = 'div',\n  children,\n  className = '',\n  swiper,\n  zoom,\n  lazy,\n  virtualIndex,\n  swiperSlideIndex,\n  ...rest\n} = {}, externalRef) => {\n  const slideElRef = useRef(null);\n  const [slideClasses, setSlideClasses] = useState('swiper-slide');\n  const [lazyLoaded, setLazyLoaded] = useState(false);\n  function updateClasses(_s, el, classNames) {\n    if (el === slideElRef.current) {\n      setSlideClasses(classNames);\n    }\n  }\n  useIsomorphicLayoutEffect(() => {\n    if (typeof swiperSlideIndex !== 'undefined') {\n      slideElRef.current.swiperSlideIndex = swiperSlideIndex;\n    }\n    if (externalRef) {\n      externalRef.current = slideElRef.current;\n    }\n    if (!slideElRef.current || !swiper) {\n      return;\n    }\n    if (swiper.destroyed) {\n      if (slideClasses !== 'swiper-slide') {\n        setSlideClasses('swiper-slide');\n      }\n      return;\n    }\n    swiper.on('_slideClass', updateClasses);\n    // eslint-disable-next-line\n    return () => {\n      if (!swiper) return;\n      swiper.off('_slideClass', updateClasses);\n    };\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (swiper && slideElRef.current && !swiper.destroyed) {\n      setSlideClasses(swiper.getSlideClasses(slideElRef.current));\n    }\n  }, [swiper]);\n  const slideData = {\n    isActive: slideClasses.indexOf('swiper-slide-active') >= 0,\n    isVisible: slideClasses.indexOf('swiper-slide-visible') >= 0,\n    isPrev: slideClasses.indexOf('swiper-slide-prev') >= 0,\n    isNext: slideClasses.indexOf('swiper-slide-next') >= 0\n  };\n  const renderChildren = () => {\n    return typeof children === 'function' ? children(slideData) : children;\n  };\n  const onLoad = () => {\n    setLazyLoaded(true);\n  };\n  return /*#__PURE__*/React.createElement(Tag, _extends({\n    ref: slideElRef,\n    className: uniqueClasses(`${slideClasses}${className ? ` ${className}` : ''}`),\n    \"data-swiper-slide-index\": virtualIndex,\n    onLoad: onLoad\n  }, rest), zoom && /*#__PURE__*/React.createElement(SwiperSlideContext.Provider, {\n    value: slideData\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"swiper-zoom-container\",\n    \"data-swiper-zoom\": typeof zoom === 'number' ? zoom : undefined\n  }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/React.createElement(\"div\", {\n    className: \"swiper-lazy-preloader\",\n    ref: node => {\n      if (node) node.lazyPreloaderManaged = true;\n    }\n  }))), !zoom && /*#__PURE__*/React.createElement(SwiperSlideContext.Provider, {\n    value: slideData\n  }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/React.createElement(\"div\", {\n    className: \"swiper-lazy-preloader\",\n    ref: node => {\n      if (node) node.lazyPreloaderManaged = true;\n    }\n  })));\n});\nSwiperSlide.displayName = 'SwiperSlide';\n\nexport { Swiper, SwiperSlide, useSwiper, useSwiperSlide };\n","function Grid({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    grid: {\n      rows: 1,\n      fill: 'column'\n    }\n  });\n  let slidesNumberEvenToRows;\n  let slidesPerRow;\n  let numFullColumns;\n  let wasMultiRow;\n  const getSpaceBetween = () => {\n    let spaceBetween = swiper.params.spaceBetween;\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n    } else if (typeof spaceBetween === 'string') {\n      spaceBetween = parseFloat(spaceBetween);\n    }\n    return spaceBetween;\n  };\n  const initSlides = slides => {\n    const {\n      slidesPerView\n    } = swiper.params;\n    const {\n      rows,\n      fill\n    } = swiper.params.grid;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;\n    numFullColumns = Math.floor(slidesLength / rows);\n    if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n      slidesNumberEvenToRows = slidesLength;\n    } else {\n      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n    }\n    if (slidesPerView !== 'auto' && fill === 'row') {\n      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n    }\n    slidesPerRow = slidesNumberEvenToRows / rows;\n  };\n  const unsetSlides = () => {\n    if (swiper.slides) {\n      swiper.slides.forEach(slide => {\n        if (slide.swiperSlideGridSet) {\n          slide.style.height = '';\n          slide.style[swiper.getDirectionLabel('margin-top')] = '';\n        }\n      });\n    }\n  };\n  const updateSlide = (i, slide, slides) => {\n    const {\n      slidesPerGroup\n    } = swiper.params;\n    const spaceBetween = getSpaceBetween();\n    const {\n      rows,\n      fill\n    } = swiper.params.grid;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;\n    // Set slides order\n    let newSlideOrderIndex;\n    let column;\n    let row;\n    if (fill === 'row' && slidesPerGroup > 1) {\n      const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n      row = Math.floor(slideIndexInGroup / columnsInGroup);\n      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n      slide.style.order = newSlideOrderIndex;\n    } else if (fill === 'column') {\n      column = Math.floor(i / rows);\n      row = i - column * rows;\n      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n        row += 1;\n        if (row >= rows) {\n          row = 0;\n          column += 1;\n        }\n      }\n    } else {\n      row = Math.floor(i / slidesPerRow);\n      column = i - row * slidesPerRow;\n    }\n    slide.row = row;\n    slide.column = column;\n    slide.style.height = `calc((100% - ${(rows - 1) * spaceBetween}px) / ${rows})`;\n    slide.style[swiper.getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n    slide.swiperSlideGridSet = true;\n  };\n  const updateWrapperSize = (slideSize, snapGrid) => {\n    const {\n      centeredSlides,\n      roundLengths\n    } = swiper.params;\n    const spaceBetween = getSpaceBetween();\n    const {\n      rows\n    } = swiper.params.grid;\n    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n    if (!swiper.params.cssMode) {\n      swiper.wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n    }\n    if (centeredSlides) {\n      const newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n      }\n      snapGrid.splice(0, snapGrid.length);\n      snapGrid.push(...newSlidesGrid);\n    }\n  };\n  const onInit = () => {\n    wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;\n  };\n  const onUpdate = () => {\n    const {\n      params,\n      el\n    } = swiper;\n    const isMultiRow = params.grid && params.grid.rows > 1;\n    if (wasMultiRow && !isMultiRow) {\n      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n      numFullColumns = 1;\n      swiper.emitContainerClasses();\n    } else if (!wasMultiRow && isMultiRow) {\n      el.classList.add(`${params.containerModifierClass}grid`);\n      if (params.grid.fill === 'column') {\n        el.classList.add(`${params.containerModifierClass}grid-column`);\n      }\n      swiper.emitContainerClasses();\n    }\n    wasMultiRow = isMultiRow;\n  };\n  on('init', onInit);\n  on('update', onUpdate);\n  swiper.grid = {\n    initSlides,\n    unsetSlides,\n    updateSlide,\n    updateWrapperSize\n  };\n}\n\nexport { Grid as default };\n","function effectInit(params) {\n  const {\n    effect,\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams,\n    perspective,\n    recreateShadows,\n    getEffectParams\n  } = params;\n  on('beforeInit', () => {\n    if (swiper.params.effect !== effect) return;\n    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n    if (perspective && perspective()) {\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n    }\n    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n    Object.assign(swiper.params, overwriteParamsResult);\n    Object.assign(swiper.originalParams, overwriteParamsResult);\n  });\n  on('setTranslate _virtualUpdated', () => {\n    if (swiper.params.effect !== effect) return;\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    if (swiper.params.effect !== effect) return;\n    setTransition(duration);\n  });\n  on('transitionEnd', () => {\n    if (swiper.params.effect !== effect) return;\n    if (recreateShadows) {\n      if (!getEffectParams || !getEffectParams().slideShadows) return;\n      // remove shadows\n      swiper.slides.forEach(slideEl => {\n        slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());\n      });\n      // create new one\n      recreateShadows();\n    }\n  });\n  let requireUpdateOnVirtual;\n  on('virtualUpdate', () => {\n    if (swiper.params.effect !== effect) return;\n    if (!swiper.slides.length) {\n      requireUpdateOnVirtual = true;\n    }\n    requestAnimationFrame(() => {\n      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n        setTranslate();\n        requireUpdateOnVirtual = false;\n      }\n    });\n  });\n}\n\nexport { effectInit as e };\n","'use client';\nimport { Swiper, SwiperSlide } from \"swiper/react\"\nimport { Autoplay, Pagination, Navigation, EffectFade } from \"swiper/modules\"\nimport { motion, AnimatePresence } from \"framer-motion\"\nimport { useState, useEffect } from \"react\";\nimport Link from 'next/link';\nimport \"swiper/css\"\nimport \"swiper/css/effect-fade\"\nimport \"swiper/css/pagination\"\nimport \"swiper/css/navigation\"\nimport { ArrowLeft, ArrowRight } from \"lucide-react\";\n\nconst fadeInUp = {\n    hidden: { opacity: 0, y: 20 },\n    visible: { opacity: 1, y: 0, transition: { duration: 0.6 } }\n}\n\nconst containerVariants = {\n    hidden: { opacity: 0 },\n    visible: {\n        opacity: 1,\n        transition: {\n            staggerChildren: 0.1,\n            delayChildren: 0.2\n        }\n    }\n}\n\nexport default function BannerCarousel() {\n    const [banners, setBanners] = useState<{ image_url: string; title: string, link_url?: string }[]>([]);\n\n    useEffect(() => {\n        fetch(\"/api/banners\")\n            .then(res => res.json())\n            .then(data => setBanners(data));\n    }, []);\n\n    const displayBanners = banners.length > 0 ? banners : [\n        { image_url: \"/Apple-16-series.webp\", title: \"Latest Apple 16 Series\", link_url: \"/product/19\" },\n        { image_url: \"/iPad-Pro-M4.webp\", title: \"Powerful iPad Pro\", link_url: \"/product/20\" }\n    ];\n\n    const banners2 = [\n        { src: \"/airpods-max-2.png\", alt: \"Latest Airpods\", link_url: \"/product/21\" },\n        { src: \"/airpods-pro-3.jpg\", alt: \"Latest Airpods\", link_url: \"/product/22\" },\n        { src: \"/airpods-pro.jpg\", alt: \"Latest Airpods\", link_url: \"/product/22\" }\n    ]\n\n    const banners3 = [\n        { src: \"/apple-watch-series-10.jpg\", alt: \"Latest Apple watch\", link_url: \"/product/27\" },\n        { src: \"/apple-watch-series-9.jpg\", alt: \"Latest Apple watch\", link_url: \"/product/27\" },\n        { src: \"/Apple-Watch-Series-7.jpg\", alt: \"Latest Apple watch\", link_url: \"/product/27\" }\n    ]\n\n    return (\n        <div className=\"w-full max-w-[1440px] mx-auto pt-10\">\n            <motion.div\n                className=\"flex flex-col md:flex-row gap-4 sm:p-6 p-4 items-stretch\"\n                variants={containerVariants}\n                initial=\"hidden\"\n                animate=\"visible\"\n            >\n                {/* Main Banner */}\n                <motion.div\n                    variants={fadeInUp}\n                    className=\"rounded-2xl overflow-hidden shadow-2xl shadow-blue-900/10 md:w-[70%] w-full h-[300px] sm:h-[400px] md:h-[500px] relative group\"\n                >\n                    <Swiper\n                        modules={[Autoplay, Pagination, Navigation, EffectFade]}\n                        effect=\"fade\"\n                        navigation={{\n                            nextEl: \".swiper-button-next-main\",\n                            prevEl: \".swiper-button-prev-main\"\n                        }}\n                        autoplay={{ delay: 5000, disableOnInteraction: false }}\n                        loop={true}\n                        pagination={{ clickable: true, dynamicBullets: true }}\n                        className=\"w-full h-full\"\n                    >\n                        {displayBanners.map((banner, index) => (\n                            <SwiperSlide key={index}>\n                                <Link href={banner.link_url || '#'} className=\"block w-full h-full relative\">\n                                    <img\n                                        src={banner.image_url}\n                                        alt={banner.title}\n                                        className=\"w-full h-full object-cover\"\n                                    />\n                                    <div className=\"absolute inset-0 bg-linear-to-t from-black/60 to-transparent flex items-end p-8\">\n                                        <motion.h2 \n                                            initial={{ opacity: 0, y: 20 }}\n                                            animate={{ opacity: 1, y: 0 }}\n                                            transition={{ delay: 0.5 }}\n                                            className=\"text-white text-2xl md:text-4xl font-bold\"\n                                        >\n                                            {banner.title}\n                                        </motion.h2>\n                                    </div>\n                                </Link>\n                            </SwiperSlide>\n                        ))}\n                        \n                        <div className=\"swiper-button-prev-main absolute left-4 top-1/2 -translate-y-1/2 z-10 w-12 h-12 bg-white/10 backdrop-blur-md rounded-full flex items-center justify-center text-white cursor-pointer hover:bg-white/20 transition-all opacity-0 group-hover:opacity-100\">\n                            <ArrowLeft size={24} />\n                        </div>\n                        <div className=\"swiper-button-next-main absolute right-4 top-1/2 -translate-y-1/2 z-10 w-12 h-12 bg-white/10 backdrop-blur-md rounded-full flex items-center justify-center text-white cursor-pointer hover:bg-white/20 transition-all opacity-0 group-hover:opacity-100\">\n                            <ArrowRight size={24} />\n                        </div>\n                    </Swiper>\n                </motion.div>\n\n                {/* Side Banners */}\n                <motion.div\n                    variants={fadeInUp}\n                    className=\"flex sm:py-0 md:flex-col sm:gap-4 gap-4 md:w-[30%] w-full\"\n                >\n                    {[banners2, banners3].map((group, groupIdx) => (\n                        <motion.div\n                            key={groupIdx}\n                            className=\"rounded-2xl overflow-hidden shadow-xl shadow-blue-900/5 h-[150px] sm:h-[190px] md:h-1/2 w-full relative group\"\n                            whileHover={{ scale: 1.02 }}\n                            transition={{ duration: 0.3 }}\n                        >\n                            <Swiper\n                                modules={[Autoplay, Navigation, EffectFade]}\n                                effect=\"fade\"\n                                navigation={{\n                                    nextEl: `.swiper-button-next-side-${groupIdx}`,\n                                    prevEl: `.swiper-button-prev-side-${groupIdx}`\n                                }}\n                                autoplay={{\n                                    delay: 4500 + groupIdx * 1000,\n                                    disableOnInteraction: false\n                                }}\n                                loop={true}\n                                className=\"w-full h-full\"\n                            >\n                                {group.map((banner, index) => (\n                                    <SwiperSlide key={index}>\n                                        <Link href={banner.link_url || '#'} className=\"block w-full h-full relative\">\n                                            <img\n                                                src={banner.src}\n                                                alt={banner.alt}\n                                                className=\"w-full h-full object-cover\"\n                                            />\n                                            <div className=\"absolute inset-0 bg-black/10 group-hover:bg-black/0 transition-colors duration-500\" />\n                                        </Link>\n                                    </SwiperSlide>\n                                ))}\n                                <div\n                                    className={`swiper-button-prev-side-${groupIdx} absolute left-2 top-1/2 -translate-y-1/2 z-10 bg-white/10 hover:bg-white/30 backdrop-blur-xs text-white rounded-full w-8 h-8 flex items-center justify-center shadow-md transition-all duration-300 cursor-pointer opacity-0 group-hover:opacity-100`}>\n                                    <ArrowLeft style={{ width: \"16px\", height: \"16px\" }} />\n                                </div>\n\n                                <div\n                                    className={`swiper-button-next-side-${groupIdx} absolute right-2 top-1/2 -translate-y-1/2 z-10 bg-white/10 hover:bg-white/30 backdrop-blur-xs text-white rounded-full w-8 h-8 flex items-center justify-center shadow-md transition-all duration-300 cursor-pointer opacity-0 group-hover:opacity-100`}>\n                                    <ArrowRight style={{ width: \"16px\", height: \"16px\" }}/>\n                                </div>\n                            </Swiper>\n                        </motion.div>\n                    ))}\n                </motion.div>\n            </motion.div>\n\n            {/* Download Buttons */}\n            <motion.div \n                initial={{ opacity: 0, y: 20 }}\n                whileInView={{ opacity: 1, y: 0 }}\n                viewport={{ once: true }}\n                transition={{ delay: 0.4 }}\n                className=\"flex flex-row gap-4 mt-8 justify-center w-full items-center\"\n            >\n                <a\n                    href=\"#\"\n                    className=\"flex items-center justify-center px-6 py-3 bg-black text-white rounded-xl shadow-lg hover:shadow-xl hover:-translate-y-1 transition-all duration-300\"\n                >\n                    <img src=\"/apple.png\" alt=\"Apple Store\" className=\"h-6 w-6 mr-3\" />\n                    <div>\n                        <p className=\"text-[10px] opacity-75 uppercase tracking-wide\">Download on the</p>\n                        <p className=\"text-lg font-bold leading-none\">App Store</p>\n                    </div>\n                </a>\n                <a\n                    href=\"#\"\n                    className=\"flex items-center justify-center px-6 py-3 bg-black text-white rounded-xl shadow-lg hover:shadow-xl hover:-translate-y-1 transition-all duration-300\"\n                >\n                    <img src=\"/google-play.png\" alt=\"Google Play\" className=\"h-6 w-6 mr-3\" />\n                    <div>\n                        <p className=\"text-[10px] opacity-75 uppercase tracking-wide\">Get it on</p>\n                        <p className=\"text-lg font-bold leading-none\">Google Play</p>\n                    </div>\n                </a>\n            </motion.div>\n        </div>\n    )\n}","'use client';\nimport { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { allProducts } from \"@/lib/products\";\nimport ProductCard from \"./ProductCard\";\n\nexport default function FlashSale() {\n    const [timeLeft] = useState({\n        days: \"03\",\n        hours: \"23\",\n        minutes: \"19\",\n        seconds: \"56\"\n    });\n\n    const [products, setProducts] = useState<any[]>([]);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n        fetch(\"/api/products?type=flash-sale\")\n            .then(res => res.json())\n            .then(data => {\n                setProducts(data);\n                setLoading(false);\n            });\n    }, []);\n\n    const flashProducts = products;\n\n    const router = useRouter();\n\n    const handleViewAllClick = () => {\n        router.push(\"/products?type=flash-sale\");\n    };\n\n    if (loading) return <div className=\"p-6 text-center\">Loading Flash Sales...</div>;\n\n    return (\n\n        <div className=\" mx-auto p-6 mt-12\">\n            {/* Header */}\n            <span className=\"flex gap-1 items-center mb-6\">\n                <img src=\"/bar.png\" alt=\"bar\" className=\"h-6 w-10\" />\n                <p className=\"text-blue-600 font-bold text-lg\"> Today's </p>\n            </span>\n            <div className=\"flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6\">\n                <h2 className=\"text-2xl font-bold text-black\">âš¡ Flash Sale</h2>\n                <div className=\"flex gap-2 text-sm sm:text-base text-blue-500 font-semibold mt-2 sm:mt-0\">\n                    <span className=\"px-2 py-1 bg-blue-100 rounded\">{timeLeft.days}d</span>\n                    <span className=\"px-2 py-1 bg-blue-100 rounded\">{timeLeft.hours}h</span>\n                    <span className=\"px-2 py-1 bg-blue-100 rounded\">{timeLeft.minutes}m</span>\n                    <span className=\"px-2 py-1 bg-blue-100 rounded\">{timeLeft.seconds}s</span>\n                </div>\n            </div>\n\n            {/* Product List */}\n            <div className=\"flex gap-4 overflow-x-auto pb-6 hide-scrollbar\">\n                {flashProducts.map((product) => (\n                    <ProductCard key={product.id} product={product} />\n                ))}\n            </div>\n\n            {/* CTA Button */}\n            <div className=\"text-center mt-6\">\n                <button\n                    onClick={handleViewAllClick}\n                    className=\"px-6 py-2 text-sm font-semibold bg-linear-to-r from-blue-500 to-purple-500 hover:from-purple-500 hover:to-blue-500 duration-200 text-white rounded-full shadow-lg hover:scale-105 transition-all hover:shadow-[0_10px_10px_rgba(0,0,0,0.3)]\">\n                    <span className=\"inline-block align-middle\">View All Products</span>\n                </button>\n            </div>\n        </div>\n    );\n}","'use client';\nimport {\n    Smartphone,\n    Laptop,\n    Headphones,\n    Camera,\n    Gamepad2,\n    Tv,\n    Watch,\n    Printer,\n    Drone,\n    House,\n    ShoppingBag,\n    MonitorSmartphone,\n} from \"lucide-react\"\nimport { useRouter } from \"next/navigation\";\n\nimport * as Icons from \"lucide-react\";\nimport { useState, useEffect } from \"react\";\n\nexport default function CategoryGrid() {\n    const [categories, setCategories] = useState<{ name: string; icon: string }[]>([]);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n        fetch(\"/api/categories\")\n            .then(res => res.json())\n            .then(data => {\n                setCategories(data);\n                setLoading(false);\n            });\n    }, []);\n\n    const router = useRouter();\n\n    if (loading) return <div className=\"p-10 text-center\">Loading Categories...</div>;\n\n\n    const handleCategoryClick = (categoryName: string) => {\n        router.push(`/products?category=${encodeURIComponent(categoryName)}`);\n    };\n\n\n\n    return (\n        <section className=\"py-10 px-6 sm:px-10 bg-white\">\n            <span className=\"flex gap-1 items-center mb-12\">\n          <img src=\"/bar3.png\" alt=\"bar\" className=\"h-7 w-10\" />\n          <p className=\"text-gray-900 font-bold text-2xl \">Featured Category</p>\n        </span>\n            <div className=\"grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-6\">\n                {categories.map(({ name, icon }, idx) => {\n                    const Icon = (Icons as any)[icon] || Icons.HelpCircle;\n                    return (\n                        <button\n                            key={idx}\n                            onClick={() => handleCategoryClick(name)}\n                            className=\"flex flex-col items-center justify-center bg-gray-100 hover:bg-blue-100 hover:shadow-[0_10px_10px_rgba(0,0,0,0.3)] rounded-lg p-4 transition-all group\"\n                        >\n                            <Icon className=\"text-blue-600 h-8 w-8 mb-2 group-hover:scale-110 transition-transform\" />\n                            <span className=\"text-sm font-medium text-gray-700 group-hover:text-blue-600\">\n                                {name}\n                            </span>\n                        </button>\n                    );\n                })}\n\n            </div>\n        </section>\n    )\n}","'use client';\nimport { allProducts } from \"@/lib/products\";\nimport { useRouter } from \"next/navigation\";\nimport ProductCard from \"./ProductCard\";\n\nimport { useState, useEffect } from \"react\";\n\nexport default function BestSelling() {\n    const [products, setProducts] = useState<any[]>([]);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n        fetch(\"/api/products?type=best-seller\")\n            .then(res => res.json())\n            .then(data => {\n                setProducts(data);\n                setLoading(false);\n            });\n    }, []);\n\n    const bestProducts = products;\n    const router = useRouter();\n\n\n    const handleViewAllClick = () => {\n        router.push(\"/products?type=best-seller\");\n    };\n\n    if (loading) return <div className=\"py-10 text-center\">Loading Best Sellers...</div>;\n\n    return (\n\n        <section className=\"py-10 px-6 sm:px-10\">\n            <span className=\"flex gap-1 items-center mb-6\">\n                <img src=\"/bar.png\" alt=\"bar\" className=\"h-6 w-10\" />\n                <p className=\"text-blue-600 font-bold text-lg\"> This Month's </p>\n            </span>\n            <div className=\"flex items-center justify-between mb-6\">\n                <h2 className=\"text-2xl font-bold text-gray-800\">ðŸ”¥ Best Selling</h2>\n                <button\n                    onClick={handleViewAllClick}\n                    className=\"text-sm font-medium text-blue-600 hover:text-blue-800 transition\"\n                >\n                    View All Products\n                </button>\n            </div>\n\n            <div className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 lg:grid-cols-4 gap-6\">\n                {bestProducts.map((product) => (\n                    <ProductCard key={product.id} product={product} />\n                ))}\n            </div>\n        </section>\n    );\n}","import { Truck, Headphones, ShieldCheck } from \"lucide-react\"\nimport StoreBanner from \"@/components/StoreBanner\";\n\nexport default function ServiceHighlights() {\n    return (\n        <section className=\"py-10 px-6 sm:px-10 \">\n            <span className=\"flex gap-1 items-center mb-12 w-full justify-center\">\n                <p className=\"text-gray-900 font-bold text-2xl mb-6\">Why Choose Us?</p>\n            </span>\n            <div className=\"max-w-7xl mx-auto grid grid-cols-1 sm:grid-cols-3 gap-6 text-center mb-24\">\n                {/* Delivery */}\n                <div className=\"flex flex-col items-center gap-3\">\n                    <div className=\"bg-blue-100 p-3 rounded-full\">\n                        <Truck className=\"text-blue-600 h-6 w-6\" />\n                    </div>\n                    <h4 className=\"text-sm font-semibold text-gray-800 uppercase\">Free and Fast Delivery</h4>\n                    <p className=\"text-sm text-gray-500\">Free delivery for all orders over à§³140.</p>\n                </div>\n\n                {/* Customer Service */}\n                <div className=\"flex flex-col items-center gap-3\">\n                    <div className=\"bg-blue-100 p-3 rounded-full\">\n                        <Headphones className=\"text-blue-600 h-6 w-6\" />\n                    </div>\n                    <h4 className=\"text-sm font-semibold text-gray-800 uppercase\">24/7 Customer Service</h4>\n                    <p className=\"text-sm text-gray-500\">Friendly 24/7 customer support.</p>\n                </div>\n\n                {/* MoneyBack Guarantee */}\n                <div className=\"flex flex-col items-center gap-3\">\n                    <div className=\"bg-blue-100 p-3 rounded-full\">\n                        <ShieldCheck className=\"text-blue-600 h-6 w-6\" />\n                    </div>\n                    <h4 className=\"text-sm font-semibold text-gray-800 uppercase\">Money Back Guarantee</h4>\n                    <p className=\"text-sm text-gray-500\">We return money within 30 days.</p>\n                </div>\n\n            </div>\n            <div className=\"max-w-7xl mx-auto\">\n                <StoreBanner/>\n            </div>\n\n        </section>\n    )\n}","import { MapPin, Search } from \"lucide-react\"\n\nexport default function StoreBanner() {\n    return (\n        <section className=\"bg-gradient-to-r from-blue-400 via-blue-500 to-blue-600 text-white rounded-xl px-6 py-8 sm:px-10 sm:py-10 shadow-md\">\n            <div className=\"max-w-7xl mx-auto flex flex-col sm:flex-row items-center justify-between gap-6\">\n                {/* Left: Info */}\n                <div className=\"flex items-center gap-4\">\n                    <div className=\"bg-white/20 p-3 rounded-full\">\n                        <MapPin className=\"h-6 w-6 text-white\" />\n                    </div>\n                    <div>\n                        <h3 className=\"text-lg sm:text-xl font-bold\">20+ Physical Stores</h3>\n                        <p className=\"text-sm sm:text-base text-white/90\">\n                            Visit our store & get your desired IT product!\n                        </p>\n                    </div>\n                </div>\n\n                {/* Right: CTA Button */}\n                <a\n                    href=\"#\"\n                    className=\"inline-flex items-center gap-2 bg-white text-blue-600 font-semibold text-sm sm:text-base px-4 py-2 rounded-full shadow hover:bg-blue-100 transition-all\"\n                >\n                    <Search size={16} /> Find Our Store\n                </a>\n            </div>\n        </section>\n    )\n}","// package.json\nvar version = \"1.3.17\";\n\n// packages/core/src/maths.ts\nfunction clamp(min, input, max) {\n  return Math.max(min, Math.min(input, max));\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, deltaTime) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime));\n}\nfunction modulo(n, d) {\n  return (n % d + d) % d;\n}\n\n// packages/core/src/animate.ts\nvar Animate = class {\n  isRunning = false;\n  value = 0;\n  from = 0;\n  to = 0;\n  currentTime = 0;\n  // These are instanciated in the fromTo method\n  lerp;\n  duration;\n  easing;\n  onUpdate;\n  /**\n   * Advance the animation by the given delta time\n   *\n   * @param deltaTime - The time in seconds to advance the animation\n   */\n  advance(deltaTime) {\n    if (!this.isRunning) return;\n    let completed = false;\n    if (this.duration && this.easing) {\n      this.currentTime += deltaTime;\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1);\n      completed = linearProgress >= 1;\n      const easedProgress = completed ? 1 : this.easing(linearProgress);\n      this.value = this.from + (this.to - this.from) * easedProgress;\n    } else if (this.lerp) {\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime);\n      if (Math.round(this.value) === this.to) {\n        this.value = this.to;\n        completed = true;\n      }\n    } else {\n      this.value = this.to;\n      completed = true;\n    }\n    if (completed) {\n      this.stop();\n    }\n    this.onUpdate?.(this.value, completed);\n  }\n  /** Stop the animation */\n  stop() {\n    this.isRunning = false;\n  }\n  /**\n   * Set up the animation from a starting value to an ending value\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\n   *\n   * @param from - The starting value\n   * @param to - The ending value\n   * @param options - Options for the animation\n   */\n  fromTo(from, to, { lerp: lerp2, duration, easing, onStart, onUpdate }) {\n    this.from = this.value = from;\n    this.to = to;\n    this.lerp = lerp2;\n    this.duration = duration;\n    this.easing = easing;\n    this.currentTime = 0;\n    this.isRunning = true;\n    onStart?.();\n    this.onUpdate = onUpdate;\n  }\n};\n\n// packages/core/src/debounce.ts\nfunction debounce(callback, delay) {\n  let timer;\n  return function(...args) {\n    let context = this;\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = void 0;\n      callback.apply(context, args);\n    }, delay);\n  };\n}\n\n// packages/core/src/dimensions.ts\nvar Dimensions = class {\n  constructor(wrapper, content, { autoResize = true, debounce: debounceValue = 250 } = {}) {\n    this.wrapper = wrapper;\n    this.content = content;\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue);\n      if (this.wrapper instanceof Window) {\n        window.addEventListener(\"resize\", this.debouncedResize, false);\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize);\n        this.wrapperResizeObserver.observe(this.wrapper);\n      }\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize);\n      this.contentResizeObserver.observe(this.content);\n    }\n    this.resize();\n  }\n  width = 0;\n  height = 0;\n  scrollHeight = 0;\n  scrollWidth = 0;\n  // These are instanciated in the constructor as they need information from the options\n  debouncedResize;\n  wrapperResizeObserver;\n  contentResizeObserver;\n  destroy() {\n    this.wrapperResizeObserver?.disconnect();\n    this.contentResizeObserver?.disconnect();\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener(\"resize\", this.debouncedResize, false);\n    }\n  }\n  resize = () => {\n    this.onWrapperResize();\n    this.onContentResize();\n  };\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n    } else {\n      this.width = this.wrapper.clientWidth;\n      this.height = this.wrapper.clientHeight;\n    }\n  };\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight;\n      this.scrollWidth = this.content.scrollWidth;\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight;\n      this.scrollWidth = this.wrapper.scrollWidth;\n    }\n  };\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height\n    };\n  }\n};\n\n// packages/core/src/emitter.ts\nvar Emitter = class {\n  events = {};\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event, ...args) {\n    let callbacks = this.events[event] || [];\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args);\n    }\n  }\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb]);\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i);\n    };\n  }\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event, callback) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i);\n  }\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {};\n  }\n};\n\n// packages/core/src/virtual-scroll.ts\nvar LINE_HEIGHT = 100 / 6;\nvar listenerOptions = { passive: false };\nvar VirtualScroll = class {\n  constructor(element, options = { wheelMultiplier: 1, touchMultiplier: 1 }) {\n    this.element = element;\n    this.options = options;\n    window.addEventListener(\"resize\", this.onWindowResize, false);\n    this.onWindowResize();\n    this.element.addEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.addEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.addEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.addEventListener(\"touchend\", this.onTouchEnd, listenerOptions);\n  }\n  touchStart = {\n    x: 0,\n    y: 0\n  };\n  lastDelta = {\n    x: 0,\n    y: 0\n  };\n  window = {\n    width: 0,\n    height: 0\n  };\n  emitter = new Emitter();\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  /** Remove all event listeners and clean up */\n  destroy() {\n    this.emitter.destroy();\n    window.removeEventListener(\"resize\", this.onWindowResize, false);\n    this.element.removeEventListener(\"wheel\", this.onWheel, listenerOptions);\n    this.element.removeEventListener(\n      \"touchstart\",\n      this.onTouchStart,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchmove\",\n      this.onTouchMove,\n      listenerOptions\n    );\n    this.element.removeEventListener(\n      \"touchend\",\n      this.onTouchEnd,\n      listenerOptions\n    );\n  }\n  /**\n   * Event handler for 'touchstart' event\n   *\n   * @param event Touch event\n   */\n  onTouchStart = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: 0,\n      y: 0\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX: 0,\n      deltaY: 0,\n      event\n    });\n  };\n  /** Event handler for 'touchmove' event */\n  onTouchMove = (event) => {\n    const { clientX, clientY } = event.targetTouches ? event.targetTouches[0] : event;\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier;\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier;\n    this.touchStart.x = clientX;\n    this.touchStart.y = clientY;\n    this.lastDelta = {\n      x: deltaX,\n      y: deltaY\n    };\n    this.emitter.emit(\"scroll\", {\n      deltaX,\n      deltaY,\n      event\n    });\n  };\n  onTouchEnd = (event) => {\n    this.emitter.emit(\"scroll\", {\n      deltaX: this.lastDelta.x,\n      deltaY: this.lastDelta.y,\n      event\n    });\n  };\n  /** Event handler for 'wheel' event */\n  onWheel = (event) => {\n    let { deltaX, deltaY, deltaMode } = event;\n    const multiplierX = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1;\n    const multiplierY = deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1;\n    deltaX *= multiplierX;\n    deltaY *= multiplierY;\n    deltaX *= this.options.wheelMultiplier;\n    deltaY *= this.options.wheelMultiplier;\n    this.emitter.emit(\"scroll\", { deltaX, deltaY, event });\n  };\n  onWindowResize = () => {\n    this.window = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  };\n};\n\n// packages/core/src/lenis.ts\nvar defaultEasing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t));\nvar Lenis = class {\n  _isScrolling = false;\n  // true when scroll is animating\n  _isStopped = false;\n  // true if user should not be able to scroll - enable/disable programmatically\n  _isLocked = false;\n  // same as isStopped but enabled/disabled when scroll reaches target\n  _preventNextNativeScrollEvent = false;\n  _resetVelocityTimeout = null;\n  _rafId = null;\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching;\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0;\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData = {};\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0;\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0;\n  /**\n   * The direction of the scroll\n   */\n  direction = 0;\n  /**\n   * The options passed to the lenis instance\n   */\n  options;\n  /**\n   * The target scroll value\n   */\n  targetScroll;\n  /**\n   * The animated scroll value\n   */\n  animatedScroll;\n  // These are instanciated here as they don't need information from the options\n  animate = new Animate();\n  emitter = new Emitter();\n  // These are instanciated in the constructor as they need information from the options\n  dimensions;\n  // This is not private because it's used in the Snap class\n  virtualScroll;\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration,\n    // in seconds\n    easing,\n    lerp: lerp2 = 0.1,\n    infinite = false,\n    orientation = \"vertical\",\n    // vertical, horizontal\n    gestureOrientation = orientation === \"horizontal\" ? \"both\" : \"vertical\",\n    // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false,\n    // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    // @ts-ignore: this will be deprecated in the future\n    __experimental__naiveDimensions = false,\n    naiveDimensions = __experimental__naiveDimensions,\n    stopInertiaOnNavigate = false\n  } = {}) {\n    window.lenisVersion = version;\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp: lerp2,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      naiveDimensions,\n      stopInertiaOnNavigate\n    };\n    this.dimensions = new Dimensions(wrapper, content, { autoResize });\n    this.updateClassName();\n    this.targetScroll = this.animatedScroll = this.actualScroll;\n    this.options.wrapper.addEventListener(\"scroll\", this.onNativeScroll, false);\n    this.options.wrapper.addEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.addEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.options.wrapper.addEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\n      touchMultiplier,\n      wheelMultiplier\n    });\n    this.virtualScroll.on(\"scroll\", this.onVirtualScroll);\n    if (this.options.autoToggle) {\n      this.checkOverflow();\n      this.rootElement.addEventListener(\"transitionend\", this.onTransitionEnd, {\n        passive: true\n      });\n    }\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf);\n    }\n  }\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy();\n    this.options.wrapper.removeEventListener(\n      \"scroll\",\n      this.onNativeScroll,\n      false\n    );\n    this.options.wrapper.removeEventListener(\"scrollend\", this.onScrollEnd, {\n      capture: true\n    });\n    this.options.wrapper.removeEventListener(\n      \"pointerdown\",\n      this.onPointerDown,\n      false\n    );\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.removeEventListener(\n        \"click\",\n        this.onClick,\n        false\n      );\n    }\n    this.virtualScroll.destroy();\n    this.dimensions.destroy();\n    this.cleanUpClassName();\n    if (this._rafId) {\n      cancelAnimationFrame(this._rafId);\n    }\n  }\n  on(event, callback) {\n    return this.emitter.on(event, callback);\n  }\n  off(event, callback) {\n    return this.emitter.off(event, callback);\n  }\n  onScrollEnd = (e) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === \"smooth\" || this.isScrolling === false) {\n        e.stopPropagation();\n      }\n    }\n  };\n  dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent(\"scrollend\", {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true\n        }\n      })\n    );\n  };\n  get overflow() {\n    const property = this.isHorizontal ? \"overflow-x\" : \"overflow-y\";\n    return getComputedStyle(this.rootElement)[property];\n  }\n  checkOverflow() {\n    if ([\"hidden\", \"clip\"].includes(this.overflow)) {\n      this.internalStop();\n    } else {\n      this.internalStart();\n    }\n  }\n  onTransitionEnd = (event) => {\n    if (event.propertyName.includes(\"overflow\")) {\n      this.checkOverflow();\n    }\n  };\n  setScroll(scroll) {\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: \"instant\" });\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: \"instant\" });\n    }\n  }\n  onClick = (event) => {\n    const path = event.composedPath();\n    const anchorElements = path.filter(\n      (node) => node instanceof HTMLAnchorElement && node.getAttribute(\"href\")\n    );\n    if (this.options.anchors) {\n      const anchor = anchorElements.find(\n        (node) => node.getAttribute(\"href\")?.includes(\"#\")\n      );\n      if (anchor) {\n        const href = anchor.getAttribute(\"href\");\n        if (href) {\n          const options = typeof this.options.anchors === \"object\" && this.options.anchors ? this.options.anchors : void 0;\n          const target = `#${href.split(\"#\")[1]}`;\n          this.scrollTo(target, options);\n        }\n      }\n    }\n    if (this.options.stopInertiaOnNavigate) {\n      const internalLink = anchorElements.find(\n        (node) => node.host === window.location.host\n      );\n      if (internalLink) {\n        this.reset();\n      }\n    }\n  };\n  onPointerDown = (event) => {\n    if (event.button === 1) {\n      this.reset();\n    }\n  };\n  onVirtualScroll = (data) => {\n    if (typeof this.options.virtualScroll === \"function\" && this.options.virtualScroll(data) === false)\n      return;\n    const { deltaX, deltaY, event } = data;\n    this.emitter.emit(\"virtual-scroll\", { deltaX, deltaY, event });\n    if (event.ctrlKey) return;\n    if (event.lenisStopPropagation) return;\n    const isTouch = event.type.includes(\"touch\");\n    const isWheel = event.type.includes(\"wheel\");\n    this.isTouching = event.type === \"touchstart\" || event.type === \"touchmove\";\n    const isClickOrTap = deltaX === 0 && deltaY === 0;\n    const isTapToStop = this.options.syncTouch && isTouch && event.type === \"touchstart\" && isClickOrTap && !this.isStopped && !this.isLocked;\n    if (isTapToStop) {\n      this.reset();\n      return;\n    }\n    const isUnknownGesture = this.options.gestureOrientation === \"vertical\" && deltaY === 0 || this.options.gestureOrientation === \"horizontal\" && deltaX === 0;\n    if (isClickOrTap || isUnknownGesture) {\n      return;\n    }\n    let composedPath = event.composedPath();\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement));\n    const prevent = this.options.prevent;\n    if (!!composedPath.find(\n      (node) => node instanceof HTMLElement && (typeof prevent === \"function\" && prevent?.(node) || node.hasAttribute?.(\"data-lenis-prevent\") || isTouch && node.hasAttribute?.(\"data-lenis-prevent-touch\") || isWheel && node.hasAttribute?.(\"data-lenis-prevent-wheel\") || this.options.allowNestedScroll && this.checkNestedScroll(node, { deltaX, deltaY }))\n    ))\n      return;\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      return;\n    }\n    const isSmooth = this.options.syncTouch && isTouch || this.options.smoothWheel && isWheel;\n    if (!isSmooth) {\n      this.isScrolling = \"native\";\n      this.animate.stop();\n      event.lenisStopPropagation = true;\n      return;\n    }\n    let delta = deltaY;\n    if (this.options.gestureOrientation === \"both\") {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX;\n    } else if (this.options.gestureOrientation === \"horizontal\") {\n      delta = deltaX;\n    }\n    if (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && this.limit > 0 && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && deltaY > 0 || this.animatedScroll === this.limit && deltaY < 0)) {\n      event.lenisStopPropagation = true;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    const isSyncTouch = isTouch && this.options.syncTouch;\n    const isTouchEnd = isTouch && event.type === \"touchend\";\n    const hasTouchInertia = isTouchEnd;\n    if (hasTouchInertia) {\n      delta = Math.sign(this.velocity) * Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent);\n    }\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...isSyncTouch ? {\n        lerp: hasTouchInertia ? this.options.syncTouchLerp : 1\n      } : {\n        lerp: this.options.lerp,\n        duration: this.options.duration,\n        easing: this.options.easing\n      }\n    });\n  };\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize();\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.emit();\n  }\n  emit() {\n    this.emitter.emit(\"scroll\", this);\n  }\n  onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout);\n      this._resetVelocityTimeout = null;\n    }\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false;\n      return;\n    }\n    if (this.isScrolling === false || this.isScrolling === \"native\") {\n      const lastScroll = this.animatedScroll;\n      this.animatedScroll = this.targetScroll = this.actualScroll;\n      this.lastVelocity = this.velocity;\n      this.velocity = this.animatedScroll - lastScroll;\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      );\n      if (!this.isStopped) {\n        this.isScrolling = \"native\";\n      }\n      this.emit();\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity;\n          this.velocity = 0;\n          this.isScrolling = false;\n          this.emit();\n        }, 400);\n      }\n    }\n  };\n  reset() {\n    this.isLocked = false;\n    this.isScrolling = false;\n    this.animatedScroll = this.targetScroll = this.actualScroll;\n    this.lastVelocity = this.velocity = 0;\n    this.animate.stop();\n  }\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty(\"overflow\");\n      return;\n    }\n    this.internalStart();\n  }\n  internalStart() {\n    if (!this.isStopped) return;\n    this.reset();\n    this.isStopped = false;\n    this.emit();\n  }\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return;\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty(\"overflow\", \"clip\");\n      return;\n    }\n    this.internalStop();\n  }\n  internalStop() {\n    if (this.isStopped) return;\n    this.reset();\n    this.isStopped = true;\n    this.emit();\n  }\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time) => {\n    const deltaTime = time - (this.time || time);\n    this.time = time;\n    this.animate.advance(deltaTime * 1e-3);\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf);\n    }\n  };\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(target, {\n    offset = 0,\n    immediate = false,\n    lock = false,\n    programmatic = true,\n    // called from outside of the class\n    lerp: lerp2 = programmatic ? this.options.lerp : void 0,\n    duration = programmatic ? this.options.duration : void 0,\n    easing = programmatic ? this.options.easing : void 0,\n    onStart,\n    onComplete,\n    force = false,\n    // scroll even if stopped\n    userData\n  } = {}) {\n    if ((this.isStopped || this.isLocked) && !force) return;\n    if (typeof target === \"string\" && [\"top\", \"left\", \"start\", \"#\"].includes(target)) {\n      target = 0;\n    } else if (typeof target === \"string\" && [\"bottom\", \"right\", \"end\"].includes(target)) {\n      target = this.limit;\n    } else {\n      let node;\n      if (typeof target === \"string\") {\n        node = document.querySelector(target);\n        if (!node) {\n          if (target === \"#top\") {\n            target = 0;\n          } else {\n            console.warn(\"Lenis: Target not found\", target);\n          }\n        }\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        node = target;\n      }\n      if (node) {\n        if (this.options.wrapper !== window) {\n          const wrapperRect = this.rootElement.getBoundingClientRect();\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top;\n        }\n        const rect = node.getBoundingClientRect();\n        target = (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll;\n      }\n    }\n    if (typeof target !== \"number\") return;\n    target += offset;\n    target = Math.round(target);\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll;\n        const distance = target - this.animatedScroll;\n        if (distance > this.limit / 2) {\n          target = target - this.limit;\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit;\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit);\n    }\n    if (target === this.targetScroll) {\n      onStart?.(this);\n      onComplete?.(this);\n      return;\n    }\n    this.userData = userData ?? {};\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target;\n      this.setScroll(this.scroll);\n      this.reset();\n      this.preventNextNativeScrollEvent();\n      this.emit();\n      onComplete?.(this);\n      this.userData = {};\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent();\n      });\n      return;\n    }\n    if (!programmatic) {\n      this.targetScroll = target;\n    }\n    if (typeof duration === \"number\" && typeof easing !== \"function\") {\n      easing = defaultEasing;\n    } else if (typeof easing === \"function\" && typeof duration !== \"number\") {\n      duration = 1;\n    }\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp: lerp2,\n      onStart: () => {\n        if (lock) this.isLocked = true;\n        this.isScrolling = \"smooth\";\n        onStart?.(this);\n      },\n      onUpdate: (value, completed) => {\n        this.isScrolling = \"smooth\";\n        this.lastVelocity = this.velocity;\n        this.velocity = value - this.animatedScroll;\n        this.direction = Math.sign(this.velocity);\n        this.animatedScroll = value;\n        this.setScroll(this.scroll);\n        if (programmatic) {\n          this.targetScroll = value;\n        }\n        if (!completed) this.emit();\n        if (completed) {\n          this.reset();\n          this.emit();\n          onComplete?.(this);\n          this.userData = {};\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent();\n          });\n          this.preventNextNativeScrollEvent();\n        }\n      }\n    });\n  }\n  preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true;\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false;\n    });\n  }\n  checkNestedScroll(node, { deltaX, deltaY }) {\n    const time = Date.now();\n    const cache = node._lenis ??= {};\n    let hasOverflowX, hasOverflowY, isScrollableX, isScrollableY, scrollWidth, scrollHeight, clientWidth, clientHeight;\n    const gestureOrientation = this.options.gestureOrientation;\n    if (time - (cache.time ?? 0) > 2e3) {\n      cache.time = Date.now();\n      const computedStyle = window.getComputedStyle(node);\n      cache.computedStyle = computedStyle;\n      const overflowXString = computedStyle.overflowX;\n      const overflowYString = computedStyle.overflowY;\n      hasOverflowX = [\"auto\", \"overlay\", \"scroll\"].includes(overflowXString);\n      hasOverflowY = [\"auto\", \"overlay\", \"scroll\"].includes(overflowYString);\n      cache.hasOverflowX = hasOverflowX;\n      cache.hasOverflowY = hasOverflowY;\n      if (!hasOverflowX && !hasOverflowY) return false;\n      if (gestureOrientation === \"vertical\" && !hasOverflowY) return false;\n      if (gestureOrientation === \"horizontal\" && !hasOverflowX) return false;\n      scrollWidth = node.scrollWidth;\n      scrollHeight = node.scrollHeight;\n      clientWidth = node.clientWidth;\n      clientHeight = node.clientHeight;\n      isScrollableX = scrollWidth > clientWidth;\n      isScrollableY = scrollHeight > clientHeight;\n      cache.isScrollableX = isScrollableX;\n      cache.isScrollableY = isScrollableY;\n      cache.scrollWidth = scrollWidth;\n      cache.scrollHeight = scrollHeight;\n      cache.clientWidth = clientWidth;\n      cache.clientHeight = clientHeight;\n    } else {\n      isScrollableX = cache.isScrollableX;\n      isScrollableY = cache.isScrollableY;\n      hasOverflowX = cache.hasOverflowX;\n      hasOverflowY = cache.hasOverflowY;\n      scrollWidth = cache.scrollWidth;\n      scrollHeight = cache.scrollHeight;\n      clientWidth = cache.clientWidth;\n      clientHeight = cache.clientHeight;\n    }\n    if (!hasOverflowX && !hasOverflowY || !isScrollableX && !isScrollableY) {\n      return false;\n    }\n    if (gestureOrientation === \"vertical\" && (!hasOverflowY || !isScrollableY))\n      return false;\n    if (gestureOrientation === \"horizontal\" && (!hasOverflowX || !isScrollableX))\n      return false;\n    let orientation;\n    if (gestureOrientation === \"horizontal\") {\n      orientation = \"x\";\n    } else if (gestureOrientation === \"vertical\") {\n      orientation = \"y\";\n    } else {\n      const isScrollingX = deltaX !== 0;\n      const isScrollingY = deltaY !== 0;\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = \"x\";\n      }\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = \"y\";\n      }\n    }\n    if (!orientation) return false;\n    let scroll, maxScroll, delta, hasOverflow, isScrollable;\n    if (orientation === \"x\") {\n      scroll = node.scrollLeft;\n      maxScroll = scrollWidth - clientWidth;\n      delta = deltaX;\n      hasOverflow = hasOverflowX;\n      isScrollable = isScrollableX;\n    } else if (orientation === \"y\") {\n      scroll = node.scrollTop;\n      maxScroll = scrollHeight - clientHeight;\n      delta = deltaY;\n      hasOverflow = hasOverflowY;\n      isScrollable = isScrollableY;\n    } else {\n      return false;\n    }\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0;\n    return willScroll && hasOverflow && isScrollable;\n  }\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return this.options.wrapper === window ? document.documentElement : this.options.wrapper;\n  }\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth;\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight;\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? \"x\" : \"y\"];\n    }\n  }\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === \"horizontal\";\n  }\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    const wrapper = this.options.wrapper;\n    return this.isHorizontal ? wrapper.scrollX ?? wrapper.scrollLeft : wrapper.scrollY ?? wrapper.scrollTop;\n  }\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll;\n  }\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    return this.limit === 0 ? 1 : this.scroll / this.limit;\n  }\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling;\n  }\n  set isScrolling(value) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped;\n  }\n  set isStopped(value) {\n    if (this._isStopped !== value) {\n      this._isStopped = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    if (this._isLocked !== value) {\n      this._isLocked = value;\n      this.updateClassName();\n    }\n  }\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === \"smooth\";\n  }\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = \"lenis\";\n    if (this.options.autoToggle) className += \" lenis-autoToggle\";\n    if (this.isStopped) className += \" lenis-stopped\";\n    if (this.isLocked) className += \" lenis-locked\";\n    if (this.isScrolling) className += \" lenis-scrolling\";\n    if (this.isScrolling === \"smooth\") className += \" lenis-smooth\";\n    return className;\n  }\n  updateClassName() {\n    this.cleanUpClassName();\n    this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim();\n  }\n  cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className.replace(/lenis(-\\w+)?/g, \"\").trim();\n  }\n};\nexport {\n  Lenis as default\n};\n//# sourceMappingURL=lenis.mjs.map","import { noop } from 'motion-utils';\nimport { attachToAnimation } from './attach-animation.mjs';\nimport { attachToFunction } from './attach-function.mjs';\n\nfunction scroll(onScroll, { axis = \"y\", container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    const optionsWithDefaults = { axis, container, ...options };\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults);\n}\n\nexport { scroll };\n","import { frame, cancelFrame } from '../frameloop/frame.mjs';\n\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = () => {\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.preUpdate(onFrame, true);\n    return () => cancelFrame(onFrame);\n}\n\nexport { observeTimeline };\n","import { supportsScrollTimeline } from 'motion-dom';\nimport { scrollInfo } from '../track.mjs';\n\nconst timelineCache = new Map();\nfunction scrollTimelineFallback(options) {\n    const currentTime = { value: 0 };\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis].progress * 100;\n    }, options);\n    return { currentTime, cancel };\n}\nfunction getTimeline({ source, container, ...options }) {\n    const { axis } = options;\n    if (source)\n        container = source;\n    const containerCache = timelineCache.get(container) ?? new Map();\n    timelineCache.set(container, containerCache);\n    const targetKey = options.target ?? \"self\";\n    const targetCache = containerCache.get(targetKey) ?? {};\n    const axisKey = axis + (options.offset ?? []).join(\",\");\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            !options.target && supportsScrollTimeline()\n                ? new ScrollTimeline({ source: container, axis })\n                : scrollTimelineFallback({ container, ...options });\n    }\n    return targetCache[axisKey];\n}\n\nexport { getTimeline };\n","import { isSVGElement } from '../utils/is-svg-element.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nconst getSize = (borderBoxAxis, svgAxis, htmlAxis) => (target, borderBoxSize) => {\n    if (borderBoxSize && borderBoxSize[0]) {\n        return borderBoxSize[0][(borderBoxAxis + \"Size\")];\n    }\n    else if (isSVGElement(target) && \"getBBox\" in target) {\n        return target.getBBox()[svgAxis];\n    }\n    else {\n        return target[htmlAxis];\n    }\n};\nconst getWidth = /*@__PURE__*/ getSize(\"inline\", \"width\", \"offsetWidth\");\nconst getHeight = /*@__PURE__*/ getSize(\"block\", \"height\", \"offsetHeight\");\nfunction notifyTarget({ target, borderBoxSize }) {\n    resizeHandlers.get(target)?.forEach((handler) => {\n        handler(target, {\n            get width() {\n                return getWidth(target, borderBoxSize);\n            },\n            get height() {\n                return getHeight(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer?.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers?.delete(handler);\n            if (!elementHandlers?.size) {\n                observer?.unobserve(element);\n            }\n        });\n    };\n}\n\nexport { resizeElement };\n","const windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const info = {\n            get width() {\n                return window.innerWidth;\n            },\n            get height() {\n                return window.innerHeight;\n            },\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size &&\n            typeof windowResizeHandler === \"function\") {\n            window.removeEventListener(\"resize\", windowResizeHandler);\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nexport { resizeWindow };\n","import { progress, velocityPerSecond } from 'motion-utils';\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[`scroll${position}`];\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nexport { createScrollInfo, updateScrollInfo };\n","import { interpolate, defaultOffset } from 'motion-dom';\nimport { clamp } from 'motion-utils';\nimport { calcInset } from './inset.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { ScrollOffset } from './presets.mjs';\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), { clamp: false });\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\n\nexport { resolveOffsets };\n","import { isHTMLElement } from 'motion-dom';\n\nfunction calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nexport { calcInset };\n","const namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nexport { namedEdges, resolveEdge };\n","const ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nexport { ScrollOffset };\n","\"use client\";\nimport { motion, useScroll, useTransform } from \"framer-motion\";\nimport { useRef } from \"react\";\nimport Link from \"next/link\";\n\nconst ProductCard = ({ title, description, image, href }: { title: string; description: string; image: string; href: string }) => (\n    <div className=\"relative bg-gray-900 text-white w-full h-full rounded-lg shadow-[0_10px_10px_rgba(0,0,0,0.3)] hover:scale-103 transition-transform duration-300 overflow-hidden\">\n        <Link href={href} className=\"block w-full h-full\">\n            <img src={image} alt={title} className=\"w-full h-full object-cover\" />\n            <div className=\"absolute bottom-0 flex flex-col items-start p-4 bg-black/5\">\n                <div>\n                    <h3 className=\"sm:text-md text-sm font-bold text-shadow-2xl truncate overflow-hidden whitespace-nowrap\">{title}</h3>\n                    <p className=\"sm:text-xs text-[10px] mt-1 text-shadow-2xl truncate overflow-hidden whitespace-nowrap\">{description}</p>\n                </div>\n                <button className=\"sm:mt-20 mt-2 hover:scale-110 hover:bg-gray-800 transition-transform duration-300 text-white text-xs sm:text-sm p-2 rounded bg-black/20 backdrop-blur-xs\">Shop Now</button>\n            </div>\n        </Link>\n    </div>\n);\n\nconst NewArrival = () => {\n    const ref = useRef(null);\n    const { scrollYProgress } = useScroll({\n        target: ref,\n        offset: [\"start end\", \"end start\"]\n    });\n\n    const opacity = useTransform(scrollYProgress, [0, 0.5, 1], [1, 1, 0]);\n    const y = useTransform(scrollYProgress, [0, 1], [0, 20]); // Slide down\n\n    return (\n        <motion.section ref={ref} style={{ opacity, y }}>\n            <div className=\"px-6 mb-6\">\n                <span className=\"flex gap-1 items-center\">\n                    <img src=\"/bar.png\" alt=\"bar\" className=\"h-6 w-10\" />\n                    <p className=\"text-white font-bold text-lg\">Featured</p>\n                </span>\n            </div>\n            <div className=\"container w-[90%] bg-white rounded-lg p-4 sm:p-6 mb-4 mx-auto\">\n                <div className=\"flex flex-col md:flex-row gap-4\">\n                    <div className=\"w-full md:w-1/2\">\n                        <div className=\"flex items-center\">\n                        </div>\n                        <ProductCard\n                            title=\"PlayStation 5\"\n                            description=\"Black and White version of the PS5 coming out on sale.\"\n                            image=\"/ps5.jpg\"\n                            href=\"/product/23\"\n                        />\n                    </div>\n                    <div className=\"w-full md:w-1/2 grid grid-cols-1 md:grid-cols-1 gap-4\">\n                        <ProductCard\n                            title=\"Women's Collections\"\n                            description=\"Featured woman collections that give you another vibe.\"\n                            image=\"/fashion.jpg\"\n                            href=\"/product/24\"\n                        />\n                        <div className=\"grid grid-cols-2 gap-4\">\n                            <ProductCard\n                                title=\"Alexa\"\n                                description=\"Amazon smart home.\"\n                                image=\"/alexa.png\"\n                                href=\"/product/25\"\n                            />\n                            <ProductCard\n                                title=\"Perfume\"\n                                description=\"GUCCI intense OUD EDP.\"\n                                image=\"/gucci.png\"\n                                href=\"/product/26\"\n                            />\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </motion.section>\n    );\n};\n\nexport default NewArrival;","\"use client\";\n\nimport { motion } from \"framer-motion\";\nimport React from \"react\";\n\ninterface LandingAnimationWrapperProps {\n  children: React.ReactNode;\n}\n\nexport default function LandingAnimationWrapper({ children }: LandingAnimationWrapperProps) {\n  return (\n    <motion.div>\n      {children}\n    </motion.div>\n  );\n}","\"use client\";\n\nimport { motion, HTMLMotionProps } from \"framer-motion\";\nimport React from \"react\";\n\ninterface SectionAnimatorProps extends HTMLMotionProps<\"div\"> {\n  children: React.ReactNode;\n}\n\nexport default function SectionAnimator({ children, ...props }: SectionAnimatorProps) {\n  return (\n    <motion.div {...props}>\n      {children}\n    </motion.div>\n  );\n}","\"use client\";\nimport BannerCarousel from \"@/components/BannerCarousel\";\nimport FlashSale from \"@/components/FlashSale\";\nimport CategoryGrid from \"@/components/ui/Catagories\";\nimport BestSelling from \"@/components/BestSeller\";\nimport ServiceHighlights from \"@/components/Services\";\nimport BestSellingStores from \"@/components/BestStores\";\nimport Featured from \"@/components/Featured\";\nimport LandingAnimationWrapper from \"@/components/LandingAnimationWrapper\";\nimport SectionAnimator from \"@/components/SectionAnimator\";\nimport Lenis from \"lenis\"\nimport { useEffect } from \"react\";\n\nexport default function Landing(){\n\n    useEffect(() => {\n    const lenis = new Lenis();\n\n    function raf(time: number) {\n      lenis.raf(time);\n      requestAnimationFrame(raf);\n    }\n\n    requestAnimationFrame(raf);\n\n    return () => {\n      lenis.destroy();\n    };\n  }, []);\n    return(\n        <LandingAnimationWrapper>\n            <div className=\"w-full h-10 bg-blue-200 text-black text-xs font-semibold leading-tight p-4 flex justify-center items-center overflow-hidden\">\n                Exclusive cashback offers on Apple products! Get upto -20% OFF and Free Delivery\n            </div>\n            <SectionAnimator\n                initial={{ opacity: 0, scale: 0.8 }}\n                whileInView={{ opacity: 1, scale: 1 }}\n                viewport={{ once: false, amount: 0.5 }}\n                transition={{ duration: 0.8 }}\n                exit={{ opacity: 0, scale: 0.8 }}\n            >\n                <BannerCarousel/>\n            </SectionAnimator>\n            <SectionAnimator\n                initial={{ opacity: 0, rotate: -5 }}\n                whileInView={{ opacity: 1, rotate: 0 }}\n                viewport={{ once: false, amount: 0.4 }}\n                transition={{ duration: 0.8, delay: 0.2 }}\n                exit={{ opacity: 0, rotate: -5 }}\n            >\n                <Featured/>\n            </SectionAnimator>\n                <div className=\"bg-white rounded-t-3xl\">\n                    <FlashSale/>\n                    <BestSelling />\n                    <CategoryGrid />\n                    <BestSellingStores />\n                    <ServiceHighlights/>\n                </div>\n        </LandingAnimationWrapper>\n    );\n}","import { s as setInnerHTML } from './utils.mjs';\n\n/* underscore in name -> watch for changes */\nconst paramsList = ['eventsPrefix', 'injectStyles', 'injectStylesUrls', 'modules', 'init', '_direction', 'oneWayMovement', 'swiperElementNodeName', 'touchEventsTarget', 'initialSlide', '_speed', 'cssMode', 'updateOnWindowResize', 'resizeObserver', 'nested', 'focusableElements', '_enabled', '_width', '_height', 'preventInteractionOnTransition', 'userAgent', 'url', '_edgeSwipeDetection', '_edgeSwipeThreshold', '_freeMode', '_autoHeight', 'setWrapperSize', 'virtualTranslate', '_effect', 'breakpoints', 'breakpointsBase', '_spaceBetween', '_slidesPerView', 'maxBackfaceHiddenSlides', '_grid', '_slidesPerGroup', '_slidesPerGroupSkip', '_slidesPerGroupAuto', '_centeredSlides', '_centeredSlidesBounds', '_slidesOffsetBefore', '_slidesOffsetAfter', 'normalizeSlideIndex', '_centerInsufficientSlides', '_snapToSlideEdge', '_watchOverflow', 'roundLengths', 'touchRatio', 'touchAngle', 'simulateTouch', '_shortSwipes', '_longSwipes', 'longSwipesRatio', 'longSwipesMs', '_followFinger', 'allowTouchMove', '_threshold', 'touchMoveStopPropagation', 'touchStartPreventDefault', 'touchStartForcePreventDefault', 'touchReleaseOnEdges', 'uniqueNavElements', '_resistance', '_resistanceRatio', '_watchSlidesProgress', '_grabCursor', 'preventClicks', 'preventClicksPropagation', '_slideToClickedSlide', '_loop', 'loopAdditionalSlides', 'loopAddBlankSlides', 'loopPreventsSliding', '_rewind', '_allowSlidePrev', '_allowSlideNext', '_swipeHandler', '_noSwiping', 'noSwipingClass', 'noSwipingSelector', 'passiveListeners', 'containerModifierClass', 'slideClass', 'slideActiveClass', 'slideVisibleClass', 'slideFullyVisibleClass', 'slideNextClass', 'slidePrevClass', 'slideBlankClass', 'wrapperClass', 'lazyPreloaderClass', 'lazyPreloadPrevNext', 'runCallbacksOnInit', 'observer', 'observeParents', 'observeSlideChildren',\n// modules\n'a11y', '_autoplay', '_controller', 'coverflowEffect', 'cubeEffect', 'fadeEffect', 'flipEffect', 'creativeEffect', 'cardsEffect', 'hashNavigation', 'history', 'keyboard', 'mousewheel', '_navigation', '_pagination', 'parallax', '_scrollbar', '_thumbs', 'virtual', 'zoom', 'control'];\n\nfunction isObject(o) {\n  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object' && !o.__swiper__;\n}\nfunction extend(target, src) {\n  const noExtend = ['__proto__', 'constructor', 'prototype'];\n  Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {\n    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {\n      if (src[key].__swiper__) target[key] = src[key];else extend(target[key], src[key]);\n    } else {\n      target[key] = src[key];\n    }\n  });\n}\nfunction needsNavigation(params = {}) {\n  return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';\n}\nfunction needsPagination(params = {}) {\n  return params.pagination && typeof params.pagination.el === 'undefined';\n}\nfunction needsScrollbar(params = {}) {\n  return params.scrollbar && typeof params.scrollbar.el === 'undefined';\n}\nfunction uniqueClasses(classNames = '') {\n  const classes = classNames.split(' ').map(c => c.trim()).filter(c => !!c);\n  const unique = [];\n  classes.forEach(c => {\n    if (unique.indexOf(c) < 0) unique.push(c);\n  });\n  return unique.join(' ');\n}\nfunction attrToProp(attrName = '') {\n  return attrName.replace(/-[a-z]/g, l => l.toUpperCase().replace('-', ''));\n}\nfunction wrapperClass(className = '') {\n  if (!className) return 'swiper-wrapper';\n  if (!className.includes('swiper-wrapper')) return `swiper-wrapper ${className}`;\n  return className;\n}\n\nfunction updateSwiper({\n  swiper,\n  slides,\n  passedParams,\n  changedParams,\n  nextEl,\n  prevEl,\n  scrollbarEl,\n  paginationEl\n}) {\n  const updateParams = changedParams.filter(key => key !== 'children' && key !== 'direction' && key !== 'wrapperClass');\n  const {\n    params: currentParams,\n    pagination,\n    navigation,\n    scrollbar,\n    virtual,\n    thumbs\n  } = swiper;\n  let needThumbsInit;\n  let needControllerInit;\n  let needPaginationInit;\n  let needScrollbarInit;\n  let needNavigationInit;\n  let loopNeedDestroy;\n  let loopNeedEnable;\n  let loopNeedReloop;\n  if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && !passedParams.thumbs.swiper.destroyed && currentParams.thumbs && (!currentParams.thumbs.swiper || currentParams.thumbs.swiper.destroyed)) {\n    needThumbsInit = true;\n  }\n  if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {\n    needControllerInit = true;\n  }\n  if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {\n    needPaginationInit = true;\n  }\n  if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {\n    needScrollbarInit = true;\n  }\n  if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {\n    needNavigationInit = true;\n  }\n  const destroyModule = mod => {\n    if (!swiper[mod]) return;\n    swiper[mod].destroy();\n    if (mod === 'navigation') {\n      if (swiper.isElement) {\n        swiper[mod].prevEl.remove();\n        swiper[mod].nextEl.remove();\n      }\n      currentParams[mod].prevEl = undefined;\n      currentParams[mod].nextEl = undefined;\n      swiper[mod].prevEl = undefined;\n      swiper[mod].nextEl = undefined;\n    } else {\n      if (swiper.isElement) {\n        swiper[mod].el.remove();\n      }\n      currentParams[mod].el = undefined;\n      swiper[mod].el = undefined;\n    }\n  };\n  if (changedParams.includes('loop') && swiper.isElement) {\n    if (currentParams.loop && !passedParams.loop) {\n      loopNeedDestroy = true;\n    } else if (!currentParams.loop && passedParams.loop) {\n      loopNeedEnable = true;\n    } else {\n      loopNeedReloop = true;\n    }\n  }\n  updateParams.forEach(key => {\n    if (isObject(currentParams[key]) && isObject(passedParams[key])) {\n      Object.assign(currentParams[key], passedParams[key]);\n      if ((key === 'navigation' || key === 'pagination' || key === 'scrollbar') && 'enabled' in passedParams[key] && !passedParams[key].enabled) {\n        destroyModule(key);\n      }\n    } else {\n      const newValue = passedParams[key];\n      if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {\n        if (newValue === false) {\n          destroyModule(key);\n        }\n      } else {\n        currentParams[key] = passedParams[key];\n      }\n    }\n  });\n  if (updateParams.includes('controller') && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {\n    swiper.controller.control = currentParams.controller.control;\n  }\n  if (changedParams.includes('children') && slides && virtual && currentParams.virtual.enabled) {\n    virtual.slides = slides;\n    virtual.update(true);\n  } else if (changedParams.includes('virtual') && virtual && currentParams.virtual.enabled) {\n    if (slides) virtual.slides = slides;\n    virtual.update(true);\n  }\n  if (changedParams.includes('children') && slides && currentParams.loop) {\n    loopNeedReloop = true;\n  }\n  if (needThumbsInit) {\n    const initialized = thumbs.init();\n    if (initialized) thumbs.update(true);\n  }\n  if (needControllerInit) {\n    swiper.controller.control = currentParams.controller.control;\n  }\n  if (needPaginationInit) {\n    if (swiper.isElement && (!paginationEl || typeof paginationEl === 'string')) {\n      paginationEl = document.createElement('div');\n      paginationEl.classList.add('swiper-pagination');\n      paginationEl.part.add('pagination');\n      swiper.el.appendChild(paginationEl);\n    }\n    if (paginationEl) currentParams.pagination.el = paginationEl;\n    pagination.init();\n    pagination.render();\n    pagination.update();\n  }\n  if (needScrollbarInit) {\n    if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === 'string')) {\n      scrollbarEl = document.createElement('div');\n      scrollbarEl.classList.add('swiper-scrollbar');\n      scrollbarEl.part.add('scrollbar');\n      swiper.el.appendChild(scrollbarEl);\n    }\n    if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;\n    scrollbar.init();\n    scrollbar.updateSize();\n    scrollbar.setTranslate();\n  }\n  if (needNavigationInit) {\n    if (swiper.isElement) {\n      if (!nextEl || typeof nextEl === 'string') {\n        nextEl = document.createElement('div');\n        nextEl.classList.add('swiper-button-next');\n        setInnerHTML(nextEl, swiper.navigation.arrowSvg);\n        nextEl.part.add('button-next');\n        swiper.el.appendChild(nextEl);\n      }\n      if (!prevEl || typeof prevEl === 'string') {\n        prevEl = document.createElement('div');\n        prevEl.classList.add('swiper-button-prev');\n        setInnerHTML(prevEl, swiper.navigation.arrowSvg);\n        prevEl.part.add('button-prev');\n        swiper.el.appendChild(prevEl);\n      }\n    }\n    if (nextEl) currentParams.navigation.nextEl = nextEl;\n    if (prevEl) currentParams.navigation.prevEl = prevEl;\n    navigation.init();\n    navigation.update();\n  }\n  if (changedParams.includes('allowSlideNext')) {\n    swiper.allowSlideNext = passedParams.allowSlideNext;\n  }\n  if (changedParams.includes('allowSlidePrev')) {\n    swiper.allowSlidePrev = passedParams.allowSlidePrev;\n  }\n  if (changedParams.includes('direction')) {\n    swiper.changeDirection(passedParams.direction, false);\n  }\n  if (loopNeedDestroy || loopNeedReloop) {\n    swiper.loopDestroy();\n  }\n  if (loopNeedEnable || loopNeedReloop) {\n    swiper.loopCreate();\n  }\n  swiper.update();\n}\n\nexport { needsPagination as a, needsScrollbar as b, attrToProp as c, uniqueClasses as d, extend as e, isObject as i, needsNavigation as n, paramsList as p, updateSwiper as u, wrapperClass as w };\n","import { e as elementChildren } from '../shared/utils.mjs';\n\nfunction Parallax({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    parallax: {\n      enabled: false\n    }\n  });\n  const elementsSelector = '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]';\n  const setTransform = (el, progress) => {\n    const {\n      rtl\n    } = swiper;\n    const rtlFactor = rtl ? -1 : 1;\n    const p = el.getAttribute('data-swiper-parallax') || '0';\n    let x = el.getAttribute('data-swiper-parallax-x');\n    let y = el.getAttribute('data-swiper-parallax-y');\n    const scale = el.getAttribute('data-swiper-parallax-scale');\n    const opacity = el.getAttribute('data-swiper-parallax-opacity');\n    const rotate = el.getAttribute('data-swiper-parallax-rotate');\n    if (x || y) {\n      x = x || '0';\n      y = y || '0';\n    } else if (swiper.isHorizontal()) {\n      x = p;\n      y = '0';\n    } else {\n      y = p;\n      x = '0';\n    }\n    if (x.indexOf('%') >= 0) {\n      x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n    } else {\n      x = `${x * progress * rtlFactor}px`;\n    }\n    if (y.indexOf('%') >= 0) {\n      y = `${parseInt(y, 10) * progress}%`;\n    } else {\n      y = `${y * progress}px`;\n    }\n    if (typeof opacity !== 'undefined' && opacity !== null) {\n      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n      el.style.opacity = currentOpacity;\n    }\n    let transform = `translate3d(${x}, ${y}, 0px)`;\n    if (typeof scale !== 'undefined' && scale !== null) {\n      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n      transform += ` scale(${currentScale})`;\n    }\n    if (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n      const currentRotate = rotate * progress * -1;\n      transform += ` rotate(${currentRotate}deg)`;\n    }\n    el.style.transform = transform;\n  };\n  const setTranslate = () => {\n    const {\n      el,\n      slides,\n      progress,\n      snapGrid,\n      isElement\n    } = swiper;\n    const elements = elementChildren(el, elementsSelector);\n    if (swiper.isElement) {\n      elements.push(...elementChildren(swiper.hostEl, elementsSelector));\n    }\n    elements.forEach(subEl => {\n      setTransform(subEl, progress);\n    });\n    slides.forEach((slideEl, slideIndex) => {\n      let slideProgress = slideEl.progress;\n      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n      }\n      slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n      slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {\n        setTransform(subEl, slideProgress);\n      });\n    });\n  };\n  const setTransition = (duration = swiper.params.speed) => {\n    const {\n      el,\n      hostEl\n    } = swiper;\n    const elements = [...el.querySelectorAll(elementsSelector)];\n    if (swiper.isElement) {\n      elements.push(...hostEl.querySelectorAll(elementsSelector));\n    }\n    elements.forEach(parallaxEl => {\n      let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n      if (duration === 0) parallaxDuration = 0;\n      parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n    });\n  };\n  on('beforeInit', () => {\n    if (!swiper.params.parallax.enabled) return;\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n  });\n  on('init', () => {\n    if (!swiper.params.parallax.enabled) return;\n    setTranslate();\n  });\n  on('setTranslate', () => {\n    if (!swiper.params.parallax.enabled) return;\n    setTranslate();\n  });\n  on('setTransition', (_swiper, duration) => {\n    if (!swiper.params.parallax.enabled) return;\n    setTransition(duration);\n  });\n}\n\nexport { Parallax as default };\n","import { g as getSlideTransformEl } from './utils.mjs';\n\nfunction effectTarget(effectParams, slideEl) {\n  const transformEl = getSlideTransformEl(slideEl);\n  if (transformEl !== slideEl) {\n    transformEl.style.backfaceVisibility = 'hidden';\n    transformEl.style['-webkit-backface-visibility'] = 'hidden';\n  }\n  return transformEl;\n}\n\nexport { effectTarget as e };\n","import { n as nextTick, o as elementTransitionEnd } from '../shared/utils.mjs';\n\n/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\nfunction Controller({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    controller: {\n      control: undefined,\n      inverse: false,\n      by: 'slide' // or 'container'\n    }\n  });\n\n  swiper.controller = {\n    control: undefined\n  };\n  function LinearSpline(x, y) {\n    const binarySearch = function search() {\n      let maxIndex;\n      let minIndex;\n      let guess;\n      return (array, val) => {\n        minIndex = -1;\n        maxIndex = array.length;\n        while (maxIndex - minIndex > 1) {\n          guess = maxIndex + minIndex >> 1;\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n        return maxIndex;\n      };\n    }();\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1;\n    // Given an x value (x2), return the expected y2 value:\n    // (x1,y1) is the known point before given value,\n    // (x3,y3) is the known point after given value.\n    let i1;\n    let i3;\n    this.interpolate = function interpolate(x2) {\n      if (!x2) return 0;\n\n      // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1;\n\n      // We have our indexes i1 & i3, so we can calculate already:\n      // y2 := ((x2âˆ’x1) Ã— (y3âˆ’y1)) Ã· (x3âˆ’x1) + y1\n      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n    };\n    return this;\n  }\n  function getInterpolateFunction(c) {\n    swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n  }\n  function setTranslate(_t, byController) {\n    const controlled = swiper.controller.control;\n    let multiplier;\n    let controlledTranslate;\n    const Swiper = swiper.constructor;\n    function setControlledTranslate(c) {\n      if (c.destroyed) return;\n\n      // this will create an Interpolate function based on the snapGrids\n      // x is the Grid of the scrolled scroller and y will be the controlled scroller\n      // it makes sense to create this only once and recall it for the interpolation\n      // the function does a lot of value caching for performance\n      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n      if (swiper.params.controller.by === 'slide') {\n        getInterpolateFunction(c);\n        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n        // but it did not work out\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n      }\n      if (!controlledTranslate || swiper.params.controller.by === 'container') {\n        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n          multiplier = 1;\n        }\n        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n      }\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n    if (Array.isArray(controlled)) {\n      for (let i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  }\n  function setTransition(duration, byController) {\n    const Swiper = swiper.constructor;\n    const controlled = swiper.controller.control;\n    let i;\n    function setControlledTransition(c) {\n      if (c.destroyed) return;\n      c.setTransition(duration, swiper);\n      if (duration !== 0) {\n        c.transitionStart();\n        if (c.params.autoHeight) {\n          nextTick(() => {\n            c.updateAutoHeight();\n          });\n        }\n        elementTransitionEnd(c.wrapperEl, () => {\n          if (!controlled) return;\n          c.transitionEnd();\n        });\n      }\n    }\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  }\n  function removeSpline() {\n    if (!swiper.controller.control) return;\n    if (swiper.controller.spline) {\n      swiper.controller.spline = undefined;\n      delete swiper.controller.spline;\n    }\n  }\n  on('beforeInit', () => {\n    if (typeof window !== 'undefined' && (\n    // eslint-disable-line\n    typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {\n      const controlElements = typeof swiper.params.controller.control === 'string' ? [...document.querySelectorAll(swiper.params.controller.control)] : [swiper.params.controller.control];\n      controlElements.forEach(controlElement => {\n        if (!swiper.controller.control) swiper.controller.control = [];\n        if (controlElement && controlElement.swiper) {\n          swiper.controller.control.push(controlElement.swiper);\n        } else if (controlElement) {\n          const eventName = `${swiper.params.eventsPrefix}init`;\n          const onControllerSwiper = e => {\n            swiper.controller.control.push(e.detail[0]);\n            swiper.update();\n            controlElement.removeEventListener(eventName, onControllerSwiper);\n          };\n          controlElement.addEventListener(eventName, onControllerSwiper);\n        }\n      });\n      return;\n    }\n    swiper.controller.control = swiper.params.controller.control;\n  });\n  on('update', () => {\n    removeSpline();\n  });\n  on('resize', () => {\n    removeSpline();\n  });\n  on('observerUpdate', () => {\n    removeSpline();\n  });\n  on('setTranslate', (_s, translate, byController) => {\n    if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n    swiper.controller.setTranslate(translate, byController);\n  });\n  on('setTransition', (_s, duration, byController) => {\n    if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n    swiper.controller.setTransition(duration, byController);\n  });\n  Object.assign(swiper.controller, {\n    setTranslate,\n    setTransition\n  });\n}\n\nexport { Controller as default };\n","import { o as elementTransitionEnd } from './utils.mjs';\n\nfunction effectVirtualTransitionEnd({\n  swiper,\n  duration,\n  transformElements,\n  allSlides\n}) {\n  const {\n    activeIndex\n  } = swiper;\n  const getSlide = el => {\n    if (!el.parentElement) {\n      // assume shadow root\n      const slide = swiper.slides.find(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode);\n      return slide;\n    }\n    return el.parentElement;\n  };\n  if (swiper.params.virtualTranslate && duration !== 0) {\n    let eventTriggered = false;\n    let transitionEndTarget;\n    if (allSlides) {\n      transitionEndTarget = transformElements;\n    } else {\n      transitionEndTarget = transformElements.filter(transformEl => {\n        const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;\n        return swiper.getSlideIndex(el) === activeIndex;\n      });\n    }\n    transitionEndTarget.forEach(el => {\n      elementTransitionEnd(el, () => {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const evt = new window.CustomEvent('transitionend', {\n          bubbles: true,\n          cancelable: true\n        });\n        swiper.wrapperEl.dispatchEvent(evt);\n      });\n    });\n  }\n}\n\nexport { effectVirtualTransitionEnd as e };\n","import { a as getWindow } from '../shared/ssr-window.esm.mjs';\n\nfunction History({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    history: {\n      enabled: false,\n      root: '',\n      replaceState: false,\n      key: 'slides',\n      keepQuery: false\n    }\n  });\n  let initialized = false;\n  let paths = {};\n  const slugify = text => {\n    return text.toString().replace(/\\s+/g, '-').replace(/[^\\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\n  };\n  const getPathValues = urlOverride => {\n    const window = getWindow();\n    let location;\n    if (urlOverride) {\n      location = new URL(urlOverride);\n    } else {\n      location = window.location;\n    }\n    const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');\n    const total = pathArray.length;\n    const key = pathArray[total - 2];\n    const value = pathArray[total - 1];\n    return {\n      key,\n      value\n    };\n  };\n  const setHistory = (key, index) => {\n    const window = getWindow();\n    if (!initialized || !swiper.params.history.enabled) return;\n    let location;\n    if (swiper.params.url) {\n      location = new URL(swiper.params.url);\n    } else {\n      location = window.location;\n    }\n    const slide = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${index}\"]`) : swiper.slides[index];\n    let value = slugify(slide.getAttribute('data-history'));\n    if (swiper.params.history.root.length > 0) {\n      let root = swiper.params.history.root;\n      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n      value = `${root}/${key ? `${key}/` : ''}${value}`;\n    } else if (!location.pathname.includes(key)) {\n      value = `${key ? `${key}/` : ''}${value}`;\n    }\n    if (swiper.params.history.keepQuery) {\n      value += location.search;\n    }\n    const currentState = window.history.state;\n    if (currentState && currentState.value === value) {\n      return;\n    }\n    if (swiper.params.history.replaceState) {\n      window.history.replaceState({\n        value\n      }, null, value);\n    } else {\n      window.history.pushState({\n        value\n      }, null, value);\n    }\n  };\n  const scrollToSlide = (speed, value, runCallbacks) => {\n    if (value) {\n      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n        const slide = swiper.slides[i];\n        const slideHistory = slugify(slide.getAttribute('data-history'));\n        if (slideHistory === value) {\n          const index = swiper.getSlideIndex(slide);\n          swiper.slideTo(index, speed, runCallbacks);\n        }\n      }\n    } else {\n      swiper.slideTo(0, speed, runCallbacks);\n    }\n  };\n  const setHistoryPopState = () => {\n    paths = getPathValues(swiper.params.url);\n    scrollToSlide(swiper.params.speed, paths.value, false);\n  };\n  const init = () => {\n    const window = getWindow();\n    if (!swiper.params.history) return;\n    if (!window.history || !window.history.pushState) {\n      swiper.params.history.enabled = false;\n      swiper.params.hashNavigation.enabled = true;\n      return;\n    }\n    initialized = true;\n    paths = getPathValues(swiper.params.url);\n    if (!paths.key && !paths.value) {\n      if (!swiper.params.history.replaceState) {\n        window.addEventListener('popstate', setHistoryPopState);\n      }\n      return;\n    }\n    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n    if (!swiper.params.history.replaceState) {\n      window.addEventListener('popstate', setHistoryPopState);\n    }\n  };\n  const destroy = () => {\n    const window = getWindow();\n    if (!swiper.params.history.replaceState) {\n      window.removeEventListener('popstate', setHistoryPopState);\n    }\n  };\n  on('init', () => {\n    if (swiper.params.history.enabled) {\n      init();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.params.history.enabled) {\n      destroy();\n    }\n  });\n  on('transitionEnd _freeModeNoMomentumRelease', () => {\n    if (initialized) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n  on('slideChange', () => {\n    if (initialized && swiper.params.cssMode) {\n      setHistory(swiper.params.history.key, swiper.activeIndex);\n    }\n  });\n}\n\nexport { History as default };\n","import { g as getDocument } from '../shared/ssr-window.esm.mjs';\n\n/* eslint no-underscore-dangle: \"off\" */\n/* eslint no-use-before-define: \"off\" */\nfunction Autoplay({\n  swiper,\n  extendParams,\n  on,\n  emit,\n  params\n}) {\n  swiper.autoplay = {\n    running: false,\n    paused: false,\n    timeLeft: 0\n  };\n  extendParams({\n    autoplay: {\n      enabled: false,\n      delay: 3000,\n      waitForTransition: true,\n      disableOnInteraction: false,\n      stopOnLastSlide: false,\n      reverseDirection: false,\n      pauseOnMouseEnter: false\n    }\n  });\n  let timeout;\n  let raf;\n  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n  let autoplayTimeLeft;\n  let autoplayStartTime = new Date().getTime();\n  let wasPaused;\n  let isTouched;\n  let pausedByTouch;\n  let touchStartTimeout;\n  let pausedByInteraction;\n  let pausedByPointerEnter;\n  function onTransitionEnd(e) {\n    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n    if (e.target !== swiper.wrapperEl) return;\n    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n    if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {\n      return;\n    }\n    resume();\n  }\n  const calcTimeLeft = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) {\n      wasPaused = true;\n    } else if (wasPaused) {\n      autoplayDelayCurrent = autoplayTimeLeft;\n      wasPaused = false;\n    }\n    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n    swiper.autoplay.timeLeft = timeLeft;\n    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n    raf = requestAnimationFrame(() => {\n      calcTimeLeft();\n    });\n  };\n  const getSlideDelay = () => {\n    let activeSlideEl;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      activeSlideEl = swiper.slides.find(slideEl => slideEl.classList.contains('swiper-slide-active'));\n    } else {\n      activeSlideEl = swiper.slides[swiper.activeIndex];\n    }\n    if (!activeSlideEl) return undefined;\n    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n    return currentSlideDelay;\n  };\n  const getTotalDelay = () => {\n    let totalDelay = swiper.params.autoplay.delay;\n    const currentSlideDelay = getSlideDelay();\n    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0) {\n      totalDelay = currentSlideDelay;\n    }\n    return totalDelay;\n  };\n  const run = delayForce => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    cancelAnimationFrame(raf);\n    calcTimeLeft();\n    let delay = delayForce;\n    if (typeof delay === 'undefined') {\n      delay = getTotalDelay();\n      autoplayDelayTotal = delay;\n      autoplayDelayCurrent = delay;\n    }\n    autoplayTimeLeft = delay;\n    const speed = swiper.params.speed;\n    const proceed = () => {\n      if (!swiper || swiper.destroyed) return;\n      if (swiper.params.autoplay.reverseDirection) {\n        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n          swiper.slidePrev(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n          emit('autoplay');\n        }\n      } else {\n        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n          swiper.slideNext(speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          swiper.slideTo(0, speed, true, true);\n          emit('autoplay');\n        }\n      }\n      if (swiper.params.cssMode) {\n        autoplayStartTime = new Date().getTime();\n        requestAnimationFrame(() => {\n          run();\n        });\n      }\n    };\n    if (delay > 0) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        proceed();\n      }, delay);\n    } else {\n      requestAnimationFrame(() => {\n        proceed();\n      });\n    }\n\n    // eslint-disable-next-line\n    return delay;\n  };\n  const start = () => {\n    autoplayStartTime = new Date().getTime();\n    swiper.autoplay.running = true;\n    run();\n    emit('autoplayStart');\n  };\n  const stop = () => {\n    swiper.autoplay.running = false;\n    clearTimeout(timeout);\n    cancelAnimationFrame(raf);\n    emit('autoplayStop');\n  };\n  const pause = (internal, reset) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    clearTimeout(timeout);\n    if (!internal) {\n      pausedByInteraction = true;\n    }\n    const proceed = () => {\n      emit('autoplayPause');\n      if (swiper.params.autoplay.waitForTransition) {\n        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n      } else {\n        resume();\n      }\n    };\n    swiper.autoplay.paused = true;\n    if (reset) {\n      proceed();\n      return;\n    }\n    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n    proceed();\n  };\n  const resume = () => {\n    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n    autoplayStartTime = new Date().getTime();\n    if (pausedByInteraction) {\n      pausedByInteraction = false;\n      run(autoplayTimeLeft);\n    } else {\n      run();\n    }\n    swiper.autoplay.paused = false;\n    emit('autoplayResume');\n  };\n  const onVisibilityChange = () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    const document = getDocument();\n    if (document.visibilityState === 'hidden') {\n      pausedByInteraction = true;\n      pause(true);\n    }\n    if (document.visibilityState === 'visible') {\n      resume();\n    }\n  };\n  const onPointerEnter = e => {\n    if (e.pointerType !== 'mouse') return;\n    pausedByInteraction = true;\n    pausedByPointerEnter = true;\n    if (swiper.animating || swiper.autoplay.paused) return;\n    pause(true);\n  };\n  const onPointerLeave = e => {\n    if (e.pointerType !== 'mouse') return;\n    pausedByPointerEnter = false;\n    if (swiper.autoplay.paused) {\n      resume();\n    }\n  };\n  const attachMouseEvents = () => {\n    if (swiper.params.autoplay.pauseOnMouseEnter) {\n      swiper.el.addEventListener('pointerenter', onPointerEnter);\n      swiper.el.addEventListener('pointerleave', onPointerLeave);\n    }\n  };\n  const detachMouseEvents = () => {\n    if (swiper.el && typeof swiper.el !== 'string') {\n      swiper.el.removeEventListener('pointerenter', onPointerEnter);\n      swiper.el.removeEventListener('pointerleave', onPointerLeave);\n    }\n  };\n  const attachDocumentEvents = () => {\n    const document = getDocument();\n    document.addEventListener('visibilitychange', onVisibilityChange);\n  };\n  const detachDocumentEvents = () => {\n    const document = getDocument();\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n  };\n  on('init', () => {\n    if (swiper.params.autoplay.enabled) {\n      attachMouseEvents();\n      attachDocumentEvents();\n      start();\n    }\n  });\n  on('destroy', () => {\n    detachMouseEvents();\n    detachDocumentEvents();\n    if (swiper.autoplay.running) {\n      stop();\n    }\n  });\n  on('_freeModeStaticRelease', () => {\n    if (pausedByTouch || pausedByInteraction) {\n      resume();\n    }\n  });\n  on('_freeModeNoMomentumRelease', () => {\n    if (!swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on('beforeTransitionStart', (_s, speed, internal) => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (internal || !swiper.params.autoplay.disableOnInteraction) {\n      pause(true, true);\n    } else {\n      stop();\n    }\n  });\n  on('sliderFirstMove', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.params.autoplay.disableOnInteraction) {\n      stop();\n      return;\n    }\n    isTouched = true;\n    pausedByTouch = false;\n    pausedByInteraction = false;\n    touchStartTimeout = setTimeout(() => {\n      pausedByInteraction = true;\n      pausedByTouch = true;\n      pause(true);\n    }, 200);\n  });\n  on('touchEnd', () => {\n    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n    clearTimeout(touchStartTimeout);\n    clearTimeout(timeout);\n    if (swiper.params.autoplay.disableOnInteraction) {\n      pausedByTouch = false;\n      isTouched = false;\n      return;\n    }\n    if (pausedByTouch && swiper.params.cssMode) resume();\n    pausedByTouch = false;\n    isTouched = false;\n  });\n  on('slideChange', () => {\n    if (swiper.destroyed || !swiper.autoplay.running) return;\n    if (swiper.autoplay.paused) {\n      autoplayTimeLeft = getTotalDelay();\n      autoplayDelayTotal = getTotalDelay();\n    }\n  });\n  Object.assign(swiper.autoplay, {\n    start,\n    stop,\n    pause,\n    resume\n  });\n}\n\nexport { Autoplay as default };\n","import { g as getSlideTransformEl, c as createElement } from './utils.mjs';\n\nfunction createShadow(suffix, slideEl, side) {\n  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;\n  const shadowContainer = getSlideTransformEl(slideEl);\n  let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);\n  if (!shadowEl) {\n    shadowEl = createElement('div', shadowClass.split(' '));\n    shadowContainer.append(shadowEl);\n  }\n  return shadowEl;\n}\n\nexport { createShadow as c };\n","import { h as now, o as elementTransitionEnd } from '../shared/utils.mjs';\n\nfunction freeMode({\n  swiper,\n  extendParams,\n  emit,\n  once\n}) {\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n  function onTouchStart() {\n    if (swiper.params.cssMode) return;\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n  function onTouchMove() {\n    if (swiper.params.cssMode) return;\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper;\n    // Velocity\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n  function onTouchEnd({\n    currentPos\n  }) {\n    if (swiper.params.cssMode) return;\n    const {\n      params,\n      wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper;\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        elementTransitionEnd(wrapperEl, () => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      emit('_freeModeStaticRelease');\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}\n\nexport { freeMode as default };\n","import { e as elementChildren, c as createElement } from './utils.mjs';\n\nfunction createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n  if (swiper.params.createElements) {\n    Object.keys(checkProps).forEach(key => {\n      if (!params[key] && params.auto === true) {\n        let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n        if (!element) {\n          element = createElement('div', checkProps[key]);\n          element.className = checkProps[key];\n          swiper.el.append(element);\n        }\n        params[key] = element;\n        originalParams[key] = element;\n      }\n    });\n  }\n  return params;\n}\n\nexport { createElementIfNotDefined as c };\n","import { resolveEdge, namedEdges } from './edge.mjs';\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nexport { resolveOffset };\n","import { a as getWindow, g as getDocument } from './ssr-window.esm.mjs';\n\nfunction classesToTokens(classes = '') {\n  return classes.trim().split(' ').filter(c => !!c.trim());\n}\n\nfunction deleteProps(obj) {\n  const object = obj;\n  Object.keys(object).forEach(key => {\n    try {\n      object[key] = null;\n    } catch (e) {\n      // no getter for object\n    }\n    try {\n      delete object[key];\n    } catch (e) {\n      // something got wrong\n    }\n  });\n}\nfunction nextTick(callback, delay = 0) {\n  return setTimeout(callback, delay);\n}\nfunction now() {\n  return Date.now();\n}\nfunction getComputedStyle(el) {\n  const window = getWindow();\n  let style;\n  if (window.getComputedStyle) {\n    style = window.getComputedStyle(el, null);\n  }\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n  if (!style) {\n    style = el.style;\n  }\n  return style;\n}\nfunction getTranslate(el, axis = 'x') {\n  const window = getWindow();\n  let matrix;\n  let curTransform;\n  let transformMatrix;\n  const curStyle = getComputedStyle(el);\n  if (window.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n    if (curTransform.split(',').length > 6) {\n      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n    }\n    // Some old versions of Webkit choke when 'none' is passed; pass\n    // empty string instead in this case\n    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n  } else {\n    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n    matrix = transformMatrix.toString().split(',');\n  }\n  if (axis === 'x') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[4]);\n  }\n  if (axis === 'y') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[5]);\n  }\n  return curTransform || 0;\n}\nfunction isObject(o) {\n  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n}\nfunction isNode(node) {\n  // eslint-disable-next-line\n  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n    return node instanceof HTMLElement;\n  }\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend(...args) {\n  const to = Object(args[0]);\n  const noExtend = ['__proto__', 'constructor', 'prototype'];\n  for (let i = 1; i < args.length; i += 1) {\n    const nextSource = args[i];\n    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        const nextKey = keysArray[nextIndex];\n        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        if (desc !== undefined && desc.enumerable) {\n          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n  return to;\n}\nfunction setCSSProperty(el, varName, varValue) {\n  el.style.setProperty(varName, varValue);\n}\nfunction animateCSSModeScroll({\n  swiper,\n  targetPosition,\n  side\n}) {\n  const window = getWindow();\n  const startPosition = -swiper.translate;\n  let startTime = null;\n  let time;\n  const duration = swiper.params.speed;\n  swiper.wrapperEl.style.scrollSnapType = 'none';\n  window.cancelAnimationFrame(swiper.cssModeFrameID);\n  const dir = targetPosition > startPosition ? 'next' : 'prev';\n  const isOutOfBound = (current, target) => {\n    return dir === 'next' && current >= target || dir === 'prev' && current <= target;\n  };\n  const animate = () => {\n    time = new Date().getTime();\n    if (startTime === null) {\n      startTime = time;\n    }\n    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      currentPosition = targetPosition;\n    }\n    swiper.wrapperEl.scrollTo({\n      [side]: currentPosition\n    });\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.scrollSnapType = '';\n      setTimeout(() => {\n        swiper.wrapperEl.style.overflow = '';\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition\n        });\n      });\n      window.cancelAnimationFrame(swiper.cssModeFrameID);\n      return;\n    }\n    swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n  };\n  animate();\n}\nfunction getSlideTransformEl(slideEl) {\n  return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;\n}\nfunction elementChildren(element, selector = '') {\n  const window = getWindow();\n  const children = [...element.children];\n  if (window.HTMLSlotElement && element instanceof HTMLSlotElement) {\n    children.push(...element.assignedElements());\n  }\n  if (!selector) {\n    return children;\n  }\n  return children.filter(el => el.matches(selector));\n}\nfunction elementIsChildOfSlot(el, slot) {\n  // Breadth-first search through all parent's children and assigned elements\n  const elementsQueue = [slot];\n  while (elementsQueue.length > 0) {\n    const elementToCheck = elementsQueue.shift();\n    if (el === elementToCheck) {\n      return true;\n    }\n    elementsQueue.push(...elementToCheck.children, ...(elementToCheck.shadowRoot ? elementToCheck.shadowRoot.children : []), ...(elementToCheck.assignedElements ? elementToCheck.assignedElements() : []));\n  }\n}\nfunction elementIsChildOf(el, parent) {\n  const window = getWindow();\n  let isChild = parent.contains(el);\n  if (!isChild && window.HTMLSlotElement && parent instanceof HTMLSlotElement) {\n    const children = [...parent.assignedElements()];\n    isChild = children.includes(el);\n    if (!isChild) {\n      isChild = elementIsChildOfSlot(el, parent);\n    }\n  }\n  return isChild;\n}\nfunction showWarning(text) {\n  try {\n    console.warn(text);\n    return;\n  } catch (err) {\n    // err\n  }\n}\nfunction createElement(tag, classes = []) {\n  const el = document.createElement(tag);\n  el.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));\n  return el;\n}\nfunction elementOffset(el) {\n  const window = getWindow();\n  const document = getDocument();\n  const box = el.getBoundingClientRect();\n  const body = document.body;\n  const clientTop = el.clientTop || body.clientTop || 0;\n  const clientLeft = el.clientLeft || body.clientLeft || 0;\n  const scrollTop = el === window ? window.scrollY : el.scrollTop;\n  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n  return {\n    top: box.top + scrollTop - clientTop,\n    left: box.left + scrollLeft - clientLeft\n  };\n}\nfunction elementPrevAll(el, selector) {\n  const prevEls = [];\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling; // eslint-disable-line\n    if (selector) {\n      if (prev.matches(selector)) prevEls.push(prev);\n    } else prevEls.push(prev);\n    el = prev;\n  }\n  return prevEls;\n}\nfunction elementNextAll(el, selector) {\n  const nextEls = [];\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling; // eslint-disable-line\n    if (selector) {\n      if (next.matches(selector)) nextEls.push(next);\n    } else nextEls.push(next);\n    el = next;\n  }\n  return nextEls;\n}\nfunction elementStyle(el, prop) {\n  const window = getWindow();\n  return window.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n  let child = el;\n  let i;\n  if (child) {\n    i = 0;\n    // eslint-disable-next-line\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n    return i;\n  }\n  return undefined;\n}\nfunction elementParents(el, selector) {\n  const parents = []; // eslint-disable-line\n  let parent = el.parentElement; // eslint-disable-line\n  while (parent) {\n    if (selector) {\n      if (parent.matches(selector)) parents.push(parent);\n    } else {\n      parents.push(parent);\n    }\n    parent = parent.parentElement;\n  }\n  return parents;\n}\nfunction elementTransitionEnd(el, callback) {\n  function fireCallBack(e) {\n    if (e.target !== el) return;\n    callback.call(el, e);\n    el.removeEventListener('transitionend', fireCallBack);\n  }\n  if (callback) {\n    el.addEventListener('transitionend', fireCallBack);\n  }\n}\nfunction elementOuterSize(el, size, includeMargins) {\n  const window = getWindow();\n  if (includeMargins) {\n    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n  }\n  return el.offsetWidth;\n}\nfunction makeElementsArray(el) {\n  return (Array.isArray(el) ? el : [el]).filter(e => !!e);\n}\nfunction getRotateFix(swiper) {\n  return v => {\n    if (Math.abs(v) > 0 && swiper.browser && swiper.browser.need3dFix && Math.abs(v) % 90 === 0) {\n      return v + 0.001;\n    }\n    return v;\n  };\n}\nfunction setInnerHTML(el, html = '') {\n  if (typeof trustedTypes !== 'undefined') {\n    el.innerHTML = trustedTypes.createPolicy('html', {\n      createHTML: s => s\n    }).createHTML(html);\n  } else {\n    el.innerHTML = html;\n  }\n}\n\nexport { getRotateFix as a, setCSSProperty as b, createElement as c, elementParents as d, elementChildren as e, elementOffset as f, getSlideTransformEl as g, now as h, elementOuterSize as i, elementIndex as j, classesToTokens as k, getTranslate as l, makeElementsArray as m, nextTick as n, elementTransitionEnd as o, isObject as p, elementStyle as q, elementNextAll as r, setInnerHTML as s, elementPrevAll as t, animateCSSModeScroll as u, showWarning as v, elementIsChildOf as w, extend as x, deleteProps as y };\n","import { interpolate } from './interpolate.mjs';\n\nfunction transform(...args) {\n    const useImmediate = !Array.isArray(args[0]);\n    const argOffset = useImmediate ? 0 : -1;\n    const inputValue = args[0 + argOffset];\n    const inputRange = args[1 + argOffset];\n    const outputRange = args[2 + argOffset];\n    const options = args[3 + argOffset];\n    const interpolator = interpolate(inputRange, outputRange, options);\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nexport { transform };\n","import { motionValue } from 'motion-dom';\nimport { useContext, useState, useEffect } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = useConstant(() => motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = useState(initial);\n        useEffect(() => value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n","import { s as setInnerHTML } from '../shared/utils.mjs';\n\nfunction appendSlide(slides) {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  const appendElement = slideEl => {\n    if (typeof slideEl === 'string') {\n      const tempDOM = document.createElement('div');\n      setInnerHTML(tempDOM, slideEl);\n      slidesEl.append(tempDOM.children[0]);\n      setInnerHTML(tempDOM, '');\n    } else {\n      slidesEl.append(slideEl);\n    }\n  };\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) appendElement(slides[i]);\n    }\n  } else {\n    appendElement(slides);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n}\n\nfunction prependSlide(slides) {\n  const swiper = this;\n  const {\n    params,\n    activeIndex,\n    slidesEl\n  } = swiper;\n  if (params.loop) {\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndex + 1;\n  const prependElement = slideEl => {\n    if (typeof slideEl === 'string') {\n      const tempDOM = document.createElement('div');\n      setInnerHTML(tempDOM, slideEl);\n      slidesEl.prepend(tempDOM.children[0]);\n      setInnerHTML(tempDOM, '');\n    } else {\n      slidesEl.prepend(slideEl);\n    }\n  };\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) prependElement(slides[i]);\n    }\n    newActiveIndex = activeIndex + slides.length;\n  } else {\n    prependElement(slides);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  swiper.slideTo(newActiveIndex, 0, false);\n}\n\nfunction addSlide(index, slides) {\n  const swiper = this;\n  const {\n    params,\n    activeIndex,\n    slidesEl\n  } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n    swiper.recalcSlides();\n  }\n  const baseLength = swiper.slides.length;\n  if (index <= 0) {\n    swiper.prependSlide(slides);\n    return;\n  }\n  if (index >= baseLength) {\n    swiper.appendSlide(slides);\n    return;\n  }\n  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n  const slidesBuffer = [];\n  for (let i = baseLength - 1; i >= index; i -= 1) {\n    const currentSlide = swiper.slides[i];\n    currentSlide.remove();\n    slidesBuffer.unshift(currentSlide);\n  }\n  if (typeof slides === 'object' && 'length' in slides) {\n    for (let i = 0; i < slides.length; i += 1) {\n      if (slides[i]) slidesEl.append(slides[i]);\n    }\n    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n  } else {\n    slidesEl.append(slides);\n  }\n  for (let i = 0; i < slidesBuffer.length; i += 1) {\n    slidesEl.append(slidesBuffer[i]);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\nfunction removeSlide(slidesIndexes) {\n  const swiper = this;\n  const {\n    params,\n    activeIndex\n  } = swiper;\n  let activeIndexBuffer = activeIndex;\n  if (params.loop) {\n    activeIndexBuffer -= swiper.loopedSlides;\n    swiper.loopDestroy();\n  }\n  let newActiveIndex = activeIndexBuffer;\n  let indexToRemove;\n  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n    for (let i = 0; i < slidesIndexes.length; i += 1) {\n      indexToRemove = slidesIndexes[i];\n      if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    }\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  } else {\n    indexToRemove = slidesIndexes;\n    if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n    newActiveIndex = Math.max(newActiveIndex, 0);\n  }\n  swiper.recalcSlides();\n  if (params.loop) {\n    swiper.loopCreate();\n  }\n  if (!params.observer || swiper.isElement) {\n    swiper.update();\n  }\n  if (params.loop) {\n    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n  } else {\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n}\n\nfunction removeAllSlides() {\n  const swiper = this;\n  const slidesIndexes = [];\n  for (let i = 0; i < swiper.slides.length; i += 1) {\n    slidesIndexes.push(i);\n  }\n  swiper.removeSlide(slidesIndexes);\n}\n\nfunction Manipulation({\n  swiper\n}) {\n  Object.assign(swiper, {\n    appendSlide: appendSlide.bind(swiper),\n    prependSlide: prependSlide.bind(swiper),\n    addSlide: addSlide.bind(swiper),\n    removeSlide: removeSlide.bind(swiper),\n    removeAllSlides: removeAllSlides.bind(swiper)\n  });\n}\n\nexport { Manipulation as default };\n","import { g as getDocument, a as getWindow } from '../shared/ssr-window.esm.mjs';\nimport { e as elementChildren } from '../shared/utils.mjs';\n\nfunction HashNavigation({\n  swiper,\n  extendParams,\n  emit,\n  on\n}) {\n  let initialized = false;\n  const document = getDocument();\n  const window = getWindow();\n  extendParams({\n    hashNavigation: {\n      enabled: false,\n      replaceState: false,\n      watchState: false,\n      getSlideIndex(_s, hash) {\n        if (swiper.virtual && swiper.params.virtual.enabled) {\n          const slideWithHash = swiper.slides.find(slideEl => slideEl.getAttribute('data-hash') === hash);\n          if (!slideWithHash) return 0;\n          const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n          return index;\n        }\n        return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n      }\n    }\n  });\n  const onHashChange = () => {\n    emit('hashChange');\n    const newHash = document.location.hash.replace('#', '');\n    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n    if (newHash !== activeSlideHash) {\n      const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n      if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n      swiper.slideTo(newIndex);\n    }\n  };\n  const setHash = () => {\n    if (!initialized || !swiper.params.hashNavigation.enabled) return;\n    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';\n    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n      window.history.replaceState(null, null, `#${activeSlideHash}` || '');\n      emit('hashSet');\n    } else {\n      document.location.hash = activeSlideHash || '';\n      emit('hashSet');\n    }\n  };\n  const init = () => {\n    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n    initialized = true;\n    const hash = document.location.hash.replace('#', '');\n    if (hash) {\n      const speed = 0;\n      const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n      swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n    }\n    if (swiper.params.hashNavigation.watchState) {\n      window.addEventListener('hashchange', onHashChange);\n    }\n  };\n  const destroy = () => {\n    if (swiper.params.hashNavigation.watchState) {\n      window.removeEventListener('hashchange', onHashChange);\n    }\n  };\n  on('init', () => {\n    if (swiper.params.hashNavigation.enabled) {\n      init();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.params.hashNavigation.enabled) {\n      destroy();\n    }\n  });\n  on('transitionEnd _freeModeNoMomentumRelease', () => {\n    if (initialized) {\n      setHash();\n    }\n  });\n  on('slideChange', () => {\n    if (initialized && swiper.params.cssMode) {\n      setHash();\n    }\n  });\n}\n\nexport { HashNavigation as default };\n","import { g as getDocument } from '../shared/ssr-window.esm.mjs';\nimport { p as isObject, e as elementChildren } from '../shared/utils.mjs';\n\nfunction Thumb({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    thumbs: {\n      swiper: null,\n      multipleActiveThumbs: true,\n      autoScrollOffset: 0,\n      slideThumbActiveClass: 'swiper-slide-thumb-active',\n      thumbsContainerClass: 'swiper-thumbs'\n    }\n  });\n  let initialized = false;\n  let swiperCreated = false;\n  swiper.thumbs = {\n    swiper: null\n  };\n  function isVirtualEnabled() {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return false;\n    return thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled;\n  }\n  function onThumbClick() {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    const clickedIndex = thumbsSwiper.clickedIndex;\n    const clickedSlide = thumbsSwiper.clickedSlide;\n    if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n    let slideToIndex;\n    if (thumbsSwiper.params.loop) {\n      slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n    } else {\n      slideToIndex = clickedIndex;\n    }\n    if (swiper.params.loop) {\n      swiper.slideToLoop(slideToIndex);\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  }\n  function init() {\n    const {\n      thumbs: thumbsParams\n    } = swiper.params;\n    if (initialized) return false;\n    initialized = true;\n    const SwiperClass = swiper.constructor;\n    if (thumbsParams.swiper instanceof SwiperClass) {\n      if (thumbsParams.swiper.destroyed) {\n        initialized = false;\n        return false;\n      }\n      swiper.thumbs.swiper = thumbsParams.swiper;\n      Object.assign(swiper.thumbs.swiper.originalParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n      Object.assign(swiper.thumbs.swiper.params, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n      swiper.thumbs.swiper.update();\n    } else if (isObject(thumbsParams.swiper)) {\n      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n      Object.assign(thumbsSwiperParams, {\n        watchSlidesProgress: true,\n        slideToClickedSlide: false\n      });\n      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n      swiperCreated = true;\n    }\n    swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n    swiper.thumbs.swiper.on('tap', onThumbClick);\n    if (isVirtualEnabled()) {\n      swiper.thumbs.swiper.on('virtualUpdate', () => {\n        update(false, {\n          autoScroll: false\n        });\n      });\n    }\n    return true;\n  }\n  function update(initial, p) {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\n    // Activate thumbs\n    let thumbsToActivate = 1;\n    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n      thumbsToActivate = swiper.params.slidesPerView;\n    }\n    if (!swiper.params.thumbs.multipleActiveThumbs) {\n      thumbsToActivate = 1;\n    }\n    thumbsToActivate = Math.floor(thumbsToActivate);\n    thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));\n    if (thumbsSwiper.params.loop || isVirtualEnabled()) {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach(slideEl => {\n          slideEl.classList.add(thumbActiveClass);\n        });\n      }\n    } else {\n      for (let i = 0; i < thumbsToActivate; i += 1) {\n        if (thumbsSwiper.slides[swiper.realIndex + i]) {\n          thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n        }\n      }\n    }\n    if (p?.autoScroll ?? true) {\n      autoScroll(initial ? 0 : undefined);\n    }\n  }\n  function autoScroll(slideSpeed) {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n      const currentThumbsIndex = thumbsSwiper.activeIndex;\n      let newThumbsIndex;\n      let direction;\n      if (thumbsSwiper.params.loop) {\n        const newThumbsSlide = thumbsSwiper.slides.find(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`);\n        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n      } else {\n        newThumbsIndex = swiper.realIndex;\n        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n      }\n      if (useOffset) {\n        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n      }\n      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n        if (thumbsSwiper.params.centeredSlides) {\n          if (newThumbsIndex > currentThumbsIndex) {\n            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n          } else {\n            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n          }\n        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;\n        thumbsSwiper.slideTo(newThumbsIndex, slideSpeed);\n      }\n    }\n  }\n  on('beforeInit', () => {\n    const {\n      thumbs\n    } = swiper.params;\n    if (!thumbs || !thumbs.swiper) return;\n    if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n      const document = getDocument();\n      const getThumbsElementAndInit = () => {\n        const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n        if (thumbsElement && thumbsElement.swiper) {\n          thumbs.swiper = thumbsElement.swiper;\n          init();\n          update(true);\n        } else if (thumbsElement) {\n          const eventName = `${swiper.params.eventsPrefix}init`;\n          const onThumbsSwiper = e => {\n            thumbs.swiper = e.detail[0];\n            thumbsElement.removeEventListener(eventName, onThumbsSwiper);\n            init();\n            update(true);\n            thumbs.swiper.update();\n            swiper.update();\n          };\n          thumbsElement.addEventListener(eventName, onThumbsSwiper);\n        }\n        return thumbsElement;\n      };\n      const watchForThumbsToAppear = () => {\n        if (swiper.destroyed) return;\n        const thumbsElement = getThumbsElementAndInit();\n        if (!thumbsElement) {\n          requestAnimationFrame(watchForThumbsToAppear);\n        }\n      };\n      requestAnimationFrame(watchForThumbsToAppear);\n    } else {\n      init();\n      update(true);\n    }\n  });\n  on('slideChange update resize observerUpdate', () => {\n    update();\n  });\n  on('setTransition', (_s, duration) => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    thumbsSwiper.setTransition(duration);\n  });\n  on('beforeDestroy', () => {\n    const thumbsSwiper = swiper.thumbs.swiper;\n    if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n    if (swiperCreated) {\n      thumbsSwiper.destroy();\n    }\n  });\n  Object.assign(swiper.thumbs, {\n    init,\n    update\n  });\n}\n\nexport { Thumb as default };\n","import { c as createElementIfNotDefined } from '../shared/create-element-if-not-defined.mjs';\nimport { m as makeElementsArray, s as setInnerHTML } from '../shared/utils.mjs';\n\nconst arrowSvg = `<svg class=\"swiper-navigation-icon\" width=\"11\" height=\"20\" viewBox=\"0 0 11 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0.38296 20.0762C0.111788 19.805 0.111788 19.3654 0.38296 19.0942L9.19758 10.2796L0.38296 1.46497C0.111788 1.19379 0.111788 0.754138 0.38296 0.482966C0.654131 0.211794 1.09379 0.211794 1.36496 0.482966L10.4341 9.55214C10.8359 9.9539 10.8359 10.6053 10.4341 11.007L1.36496 20.0762C1.09379 20.3474 0.654131 20.3474 0.38296 20.0762Z\" fill=\"currentColor\"/></svg>`;\nfunction Navigation({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  extendParams({\n    navigation: {\n      nextEl: null,\n      prevEl: null,\n      addIcons: true,\n      hideOnClick: false,\n      disabledClass: 'swiper-button-disabled',\n      hiddenClass: 'swiper-button-hidden',\n      lockClass: 'swiper-button-lock',\n      navigationDisabledClass: 'swiper-navigation-disabled'\n    }\n  });\n  swiper.navigation = {\n    nextEl: null,\n    prevEl: null,\n    arrowSvg\n  };\n  function getEl(el) {\n    let res;\n    if (el && typeof el === 'string' && swiper.isElement) {\n      res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);\n      if (res) return res;\n    }\n    if (el) {\n      if (typeof el === 'string') res = [...document.querySelectorAll(el)];\n      if (swiper.params.uniqueNavElements && typeof el === 'string' && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n        res = swiper.el.querySelector(el);\n      } else if (res && res.length === 1) {\n        res = res[0];\n      }\n    }\n    if (el && !res) return el;\n    // if (Array.isArray(res) && res.length === 1) res = res[0];\n    return res;\n  }\n  function toggleEl(el, disabled) {\n    const params = swiper.params.navigation;\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      if (subEl) {\n        subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n        if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n        }\n      }\n    });\n  }\n  function update() {\n    // Update Navigation Buttons\n    const {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    if (swiper.params.loop) {\n      toggleEl(prevEl, false);\n      toggleEl(nextEl, false);\n      return;\n    }\n    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n  }\n  function onPrevClick(e) {\n    e.preventDefault();\n    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n    swiper.slidePrev();\n    emit('navigationPrev');\n  }\n  function onNextClick(e) {\n    e.preventDefault();\n    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n    swiper.slideNext();\n    emit('navigationNext');\n  }\n  function init() {\n    const params = swiper.params.navigation;\n    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n      nextEl: 'swiper-button-next',\n      prevEl: 'swiper-button-prev'\n    });\n    if (!(params.nextEl || params.prevEl)) return;\n    let nextEl = getEl(params.nextEl);\n    let prevEl = getEl(params.prevEl);\n    Object.assign(swiper.navigation, {\n      nextEl,\n      prevEl\n    });\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const initButton = (el, dir) => {\n      if (el) {\n        if (params.addIcons && el.matches('.swiper-button-next,.swiper-button-prev') && !el.querySelector('svg')) {\n          const tempEl = document.createElement('div');\n          setInnerHTML(tempEl, arrowSvg);\n          el.appendChild(tempEl.querySelector('svg'));\n          tempEl.remove();\n        }\n        el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n      }\n      if (!swiper.enabled && el) {\n        el.classList.add(...params.lockClass.split(' '));\n      }\n    };\n    nextEl.forEach(el => initButton(el, 'next'));\n    prevEl.forEach(el => initButton(el, 'prev'));\n  }\n  function destroy() {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const destroyButton = (el, dir) => {\n      el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n      el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n    };\n    nextEl.forEach(el => destroyButton(el, 'next'));\n    prevEl.forEach(el => destroyButton(el, 'prev'));\n  }\n  on('init', () => {\n    if (swiper.params.navigation.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      update();\n    }\n  });\n  on('toEdge fromEdge lock unlock', () => {\n    update();\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  on('enable disable', () => {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (swiper.enabled) {\n      update();\n      return;\n    }\n    [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass));\n  });\n  on('click', (_s, e) => {\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    const targetEl = e.target;\n    let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);\n    if (swiper.isElement && !targetIsButton) {\n      const path = e.path || e.composedPath && e.composedPath();\n      if (path) {\n        targetIsButton = path.find(pathEl => nextEl.includes(pathEl) || prevEl.includes(pathEl));\n      }\n    }\n    if (swiper.params.navigation.hideOnClick && !targetIsButton) {\n      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n      let isHidden;\n      if (nextEl.length) {\n        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      } else if (prevEl.length) {\n        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n      }\n      if (isHidden === true) {\n        emit('navigationShow');\n      } else {\n        emit('navigationHide');\n      }\n      [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));\n    }\n  });\n  const enable = () => {\n    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n    init();\n    update();\n  };\n  const disable = () => {\n    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n    destroy();\n  };\n  Object.assign(swiper.navigation, {\n    enable,\n    disable,\n    update,\n    init,\n    destroy\n  });\n}\n\nexport { Navigation as default };\n","import { resizeElement } from './handle-element.mjs';\nimport { resizeWindow } from './handle-window.mjs';\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\nexport { resize };\n","import { e as extend, p as paramsList, i as isObject, n as needsNavigation, a as needsPagination, b as needsScrollbar } from './update-swiper.mjs';\nimport { d as defaults } from './swiper-core.mjs';\n\nfunction getParams(obj = {}, splitEvents = true) {\n  const params = {\n    on: {}\n  };\n  const events = {};\n  const passedParams = {};\n  extend(params, defaults);\n  params._emitClasses = true;\n  params.init = false;\n  const rest = {};\n  const allowedParams = paramsList.map(key => key.replace(/_/, ''));\n  const plainObj = Object.assign({}, obj);\n  Object.keys(plainObj).forEach(key => {\n    if (typeof obj[key] === 'undefined') return;\n    if (allowedParams.indexOf(key) >= 0) {\n      if (isObject(obj[key])) {\n        params[key] = {};\n        passedParams[key] = {};\n        extend(params[key], obj[key]);\n        extend(passedParams[key], obj[key]);\n      } else {\n        params[key] = obj[key];\n        passedParams[key] = obj[key];\n      }\n    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === 'function') {\n      if (splitEvents) {\n        events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];\n      } else {\n        params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];\n      }\n    } else {\n      rest[key] = obj[key];\n    }\n  });\n  ['navigation', 'pagination', 'scrollbar'].forEach(key => {\n    if (params[key] === true) params[key] = {};\n    if (params[key] === false) delete params[key];\n  });\n  return {\n    params,\n    passedParams,\n    rest,\n    events\n  };\n}\n\nfunction mountSwiper({\n  el,\n  nextEl,\n  prevEl,\n  paginationEl,\n  scrollbarEl,\n  swiper\n}, swiperParams) {\n  if (needsNavigation(swiperParams) && nextEl && prevEl) {\n    swiper.params.navigation.nextEl = nextEl;\n    swiper.originalParams.navigation.nextEl = nextEl;\n    swiper.params.navigation.prevEl = prevEl;\n    swiper.originalParams.navigation.prevEl = prevEl;\n  }\n  if (needsPagination(swiperParams) && paginationEl) {\n    swiper.params.pagination.el = paginationEl;\n    swiper.originalParams.pagination.el = paginationEl;\n  }\n  if (needsScrollbar(swiperParams) && scrollbarEl) {\n    swiper.params.scrollbar.el = scrollbarEl;\n    swiper.originalParams.scrollbar.el = scrollbarEl;\n  }\n  swiper.init(el);\n}\n\nfunction getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {\n  const keys = [];\n  if (!oldParams) return keys;\n  const addKey = key => {\n    if (keys.indexOf(key) < 0) keys.push(key);\n  };\n  if (children && oldChildren) {\n    const oldChildrenKeys = oldChildren.map(getKey);\n    const childrenKeys = children.map(getKey);\n    if (oldChildrenKeys.join('') !== childrenKeys.join('')) addKey('children');\n    if (oldChildren.length !== children.length) addKey('children');\n  }\n  const watchParams = paramsList.filter(key => key[0] === '_').map(key => key.replace(/_/, ''));\n  watchParams.forEach(key => {\n    if (key in swiperParams && key in oldParams) {\n      if (isObject(swiperParams[key]) && isObject(oldParams[key])) {\n        const newKeys = Object.keys(swiperParams[key]);\n        const oldKeys = Object.keys(oldParams[key]);\n        if (newKeys.length !== oldKeys.length) {\n          addKey(key);\n        } else {\n          newKeys.forEach(newKey => {\n            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {\n              addKey(key);\n            }\n          });\n          oldKeys.forEach(oldKey => {\n            if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);\n          });\n        }\n      } else if (swiperParams[key] !== oldParams[key]) {\n        addKey(key);\n      }\n    }\n  });\n  return keys;\n}\n\nconst updateOnVirtualData = swiper => {\n  if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;\n  swiper.updateSlides();\n  swiper.updateProgress();\n  swiper.updateSlidesClasses();\n  swiper.emit('_virtualUpdated');\n  if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {\n    swiper.parallax.setTranslate();\n  }\n};\n\nexport { getChangedParams as a, getParams as g, mountSwiper as m, updateOnVirtualData as u };\n","import { g as getDocument } from '../shared/ssr-window.esm.mjs';\nimport { b as setCSSProperty, e as elementChildren, s as setInnerHTML, c as createElement } from '../shared/utils.mjs';\n\nfunction Virtual({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  extendParams({\n    virtual: {\n      enabled: false,\n      slides: [],\n      cache: true,\n      slidesPerViewAutoSlideSize: 320,\n      renderSlide: null,\n      renderExternal: null,\n      renderExternalUpdate: true,\n      addSlidesBefore: 0,\n      addSlidesAfter: 0\n    }\n  });\n  let cssModeTimeout;\n  const document = getDocument();\n  swiper.virtual = {\n    cache: {},\n    from: undefined,\n    to: undefined,\n    slides: [],\n    offset: 0,\n    slidesGrid: []\n  };\n  const tempDOM = document.createElement('div');\n  function renderSlide(slide, index) {\n    const params = swiper.params.virtual;\n    if (params.cache && swiper.virtual.cache[index]) {\n      return swiper.virtual.cache[index];\n    }\n    // eslint-disable-next-line\n    let slideEl;\n    if (params.renderSlide) {\n      slideEl = params.renderSlide.call(swiper, slide, index);\n      if (typeof slideEl === 'string') {\n        setInnerHTML(tempDOM, slideEl);\n        slideEl = tempDOM.children[0];\n      }\n    } else if (swiper.isElement) {\n      slideEl = createElement('swiper-slide');\n    } else {\n      slideEl = createElement('div', swiper.params.slideClass);\n    }\n    slideEl.setAttribute('data-swiper-slide-index', index);\n    if (!params.renderSlide) {\n      setInnerHTML(slideEl, slide);\n    }\n    if (params.cache) {\n      swiper.virtual.cache[index] = slideEl;\n    }\n    return slideEl;\n  }\n  function update(force, beforeInit, forceActiveIndex) {\n    const {\n      slidesPerGroup,\n      centeredSlides,\n      slidesPerView,\n      loop: isLoop,\n      initialSlide\n    } = swiper.params;\n    if (beforeInit && !isLoop && initialSlide > 0) {\n      return;\n    }\n    const {\n      addSlidesBefore,\n      addSlidesAfter,\n      slidesPerViewAutoSlideSize\n    } = swiper.params.virtual;\n    const {\n      from: previousFrom,\n      to: previousTo,\n      slides,\n      slidesGrid: previousSlidesGrid,\n      offset: previousOffset\n    } = swiper.virtual;\n    if (!swiper.params.cssMode) {\n      swiper.updateActiveIndex();\n    }\n    const activeIndex = typeof forceActiveIndex === 'undefined' ? swiper.activeIndex || 0 : forceActiveIndex;\n    let offsetProp;\n    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n    let slidesPerViewNumeric;\n    if (slidesPerView === 'auto') {\n      if (slidesPerViewAutoSlideSize) {\n        let swiperSize = swiper.size;\n        if (!swiperSize) {\n          swiperSize = swiper.isHorizontal() ? swiper.el.getBoundingClientRect().width : swiper.el.getBoundingClientRect().height;\n        }\n        slidesPerViewNumeric = Math.max(1, Math.ceil(swiperSize / slidesPerViewAutoSlideSize));\n      } else {\n        slidesPerViewNumeric = 1;\n      }\n    } else {\n      slidesPerViewNumeric = slidesPerView;\n    }\n    let slidesAfter;\n    let slidesBefore;\n    if (centeredSlides) {\n      slidesAfter = Math.floor(slidesPerViewNumeric / 2) + slidesPerGroup + addSlidesAfter;\n      slidesBefore = Math.floor(slidesPerViewNumeric / 2) + slidesPerGroup + addSlidesBefore;\n    } else {\n      slidesAfter = slidesPerViewNumeric + (slidesPerGroup - 1) + addSlidesAfter;\n      slidesBefore = (isLoop ? slidesPerViewNumeric : slidesPerGroup) + addSlidesBefore;\n    }\n    let from = activeIndex - slidesBefore;\n    let to = activeIndex + slidesAfter;\n    if (!isLoop) {\n      from = Math.max(from, 0);\n      to = Math.min(to, slides.length - 1);\n    }\n    let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n    if (isLoop && activeIndex >= slidesBefore) {\n      from -= slidesBefore;\n      if (!centeredSlides) offset += swiper.slidesGrid[0];\n    } else if (isLoop && activeIndex < slidesBefore) {\n      from = -slidesBefore;\n      if (centeredSlides) offset += swiper.slidesGrid[0];\n    }\n    Object.assign(swiper.virtual, {\n      from,\n      to,\n      offset,\n      slidesGrid: swiper.slidesGrid,\n      slidesBefore,\n      slidesAfter\n    });\n    function onRendered() {\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      emit('virtualUpdate');\n    }\n    if (previousFrom === from && previousTo === to && !force) {\n      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n        swiper.slides.forEach(slideEl => {\n          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n        });\n      }\n      swiper.updateProgress();\n      emit('virtualUpdate');\n      return;\n    }\n    if (swiper.params.virtual.renderExternal) {\n      swiper.params.virtual.renderExternal.call(swiper, {\n        offset,\n        from,\n        to,\n        slides: function getSlides() {\n          const slidesToRender = [];\n          for (let i = from; i <= to; i += 1) {\n            slidesToRender.push(slides[i]);\n          }\n          return slidesToRender;\n        }()\n      });\n      if (swiper.params.virtual.renderExternalUpdate) {\n        onRendered();\n      } else {\n        emit('virtualUpdate');\n      }\n      return;\n    }\n    const prependIndexes = [];\n    const appendIndexes = [];\n    const getSlideIndex = index => {\n      let slideIndex = index;\n      if (index < 0) {\n        slideIndex = slides.length + index;\n      } else if (slideIndex >= slides.length) {\n        // eslint-disable-next-line\n        slideIndex = slideIndex - slides.length;\n      }\n      return slideIndex;\n    };\n    if (force) {\n      swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach(slideEl => {\n        slideEl.remove();\n      });\n    } else {\n      for (let i = previousFrom; i <= previousTo; i += 1) {\n        if (i < from || i > to) {\n          const slideIndex = getSlideIndex(i);\n          swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`)).forEach(slideEl => {\n            slideEl.remove();\n          });\n        }\n      }\n    }\n    const loopFrom = isLoop ? -slides.length : 0;\n    const loopTo = isLoop ? slides.length * 2 : slides.length;\n    for (let i = loopFrom; i < loopTo; i += 1) {\n      if (i >= from && i <= to) {\n        const slideIndex = getSlideIndex(i);\n        if (typeof previousTo === 'undefined' || force) {\n          appendIndexes.push(slideIndex);\n        } else {\n          if (i > previousTo) appendIndexes.push(slideIndex);\n          if (i < previousFrom) prependIndexes.push(slideIndex);\n        }\n      }\n    }\n    appendIndexes.forEach(index => {\n      swiper.slidesEl.append(renderSlide(slides[index], index));\n    });\n    if (isLoop) {\n      for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n        const index = prependIndexes[i];\n        swiper.slidesEl.prepend(renderSlide(slides[index], index));\n      }\n    } else {\n      prependIndexes.sort((a, b) => b - a);\n      prependIndexes.forEach(index => {\n        swiper.slidesEl.prepend(renderSlide(slides[index], index));\n      });\n    }\n    elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {\n      slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n    });\n    onRendered();\n  }\n  function appendSlide(slides) {\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.push(slides[i]);\n      }\n    } else {\n      swiper.virtual.slides.push(slides);\n    }\n    update(true);\n  }\n  function prependSlide(slides) {\n    const activeIndex = swiper.activeIndex;\n    let newActiveIndex = activeIndex + 1;\n    let numberOfNewSlides = 1;\n    if (Array.isArray(slides)) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n      numberOfNewSlides = slides.length;\n    } else {\n      swiper.virtual.slides.unshift(slides);\n    }\n    if (swiper.params.virtual.cache) {\n      const cache = swiper.virtual.cache;\n      const newCache = {};\n      Object.keys(cache).forEach(cachedIndex => {\n        const cachedEl = cache[cachedIndex];\n        const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n        if (cachedElIndex) {\n          cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n        }\n        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n      });\n      swiper.virtual.cache = newCache;\n    }\n    update(true);\n    swiper.slideTo(newActiveIndex, 0);\n  }\n  function removeSlide(slidesIndexes) {\n    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n    let activeIndex = swiper.activeIndex;\n    if (Array.isArray(slidesIndexes)) {\n      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes[i]];\n          // shift cache indexes\n          Object.keys(swiper.virtual.cache).forEach(key => {\n            if (key > slidesIndexes) {\n              swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];\n              swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);\n              delete swiper.virtual.cache[key];\n            }\n          });\n        }\n        swiper.virtual.slides.splice(slidesIndexes[i], 1);\n        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n    } else {\n      if (swiper.params.virtual.cache) {\n        delete swiper.virtual.cache[slidesIndexes];\n        // shift cache indexes\n        Object.keys(swiper.virtual.cache).forEach(key => {\n          if (key > slidesIndexes) {\n            swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];\n            swiper.virtual.cache[key - 1].setAttribute('data-swiper-slide-index', key - 1);\n            delete swiper.virtual.cache[key];\n          }\n        });\n      }\n      swiper.virtual.slides.splice(slidesIndexes, 1);\n      if (slidesIndexes < activeIndex) activeIndex -= 1;\n      activeIndex = Math.max(activeIndex, 0);\n    }\n    update(true);\n    swiper.slideTo(activeIndex, 0);\n  }\n  function removeAllSlides() {\n    swiper.virtual.slides = [];\n    if (swiper.params.virtual.cache) {\n      swiper.virtual.cache = {};\n    }\n    update(true);\n    swiper.slideTo(0, 0);\n  }\n  on('beforeInit', () => {\n    if (!swiper.params.virtual.enabled) return;\n    let domSlidesAssigned;\n    if (typeof swiper.passedParams.virtual.slides === 'undefined') {\n      const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n      if (slides && slides.length) {\n        swiper.virtual.slides = [...slides];\n        domSlidesAssigned = true;\n        slides.forEach((slideEl, slideIndex) => {\n          slideEl.setAttribute('data-swiper-slide-index', slideIndex);\n          swiper.virtual.cache[slideIndex] = slideEl;\n          slideEl.remove();\n        });\n      }\n    }\n    if (!domSlidesAssigned) {\n      swiper.virtual.slides = swiper.params.virtual.slides;\n    }\n    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n    swiper.params.watchSlidesProgress = true;\n    swiper.originalParams.watchSlidesProgress = true;\n    update(false, true);\n  });\n  on('setTranslate', () => {\n    if (!swiper.params.virtual.enabled) return;\n    if (swiper.params.cssMode && !swiper._immediateVirtual) {\n      clearTimeout(cssModeTimeout);\n      cssModeTimeout = setTimeout(() => {\n        update();\n      }, 100);\n    } else {\n      update();\n    }\n  });\n  on('init update resize', () => {\n    if (!swiper.params.virtual.enabled) return;\n    if (swiper.params.cssMode) {\n      setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n    }\n  });\n  Object.assign(swiper.virtual, {\n    appendSlide,\n    prependSlide,\n    removeSlide,\n    removeAllSlides,\n    update\n  });\n}\n\nexport { Virtual as default };\n","import { g as getDocument, a as getWindow } from '../shared/ssr-window.esm.mjs';\nimport { d as elementParents, f as elementOffset } from '../shared/utils.mjs';\n\n/* eslint-disable consistent-return */\nfunction Keyboard({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const document = getDocument();\n  const window = getWindow();\n  swiper.keyboard = {\n    enabled: false\n  };\n  extendParams({\n    keyboard: {\n      enabled: false,\n      onlyInViewport: true,\n      pageUpDown: true,\n      speed: undefined\n    }\n  });\n  function handle(event) {\n    if (!swiper.enabled) return;\n    const {\n      rtlTranslate: rtl\n    } = swiper;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    const kc = e.keyCode || e.charCode;\n    const pageUpDown = swiper.params.keyboard.pageUpDown;\n    const isPageUp = pageUpDown && kc === 33;\n    const isPageDown = pageUpDown && kc === 34;\n    const isArrowLeft = kc === 37;\n    const isArrowRight = kc === 39;\n    const isArrowUp = kc === 38;\n    const isArrowDown = kc === 40;\n    // Directions locks\n    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n      return false;\n    }\n    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n      return undefined;\n    }\n    if (document.activeElement && (document.activeElement.isContentEditable || document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea'))) {\n      return undefined;\n    }\n    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n      let inView = false;\n      // Check that swiper should be inside of visible area of window\n      if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n        return undefined;\n      }\n      const el = swiper.el;\n      const swiperWidth = el.clientWidth;\n      const swiperHeight = el.clientHeight;\n      const windowWidth = window.innerWidth;\n      const windowHeight = window.innerHeight;\n      const swiperOffset = elementOffset(el);\n      if (rtl) swiperOffset.left -= el.scrollLeft;\n      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n      for (let i = 0; i < swiperCoord.length; i += 1) {\n        const point = swiperCoord[i];\n        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n          inView = true;\n        }\n      }\n      if (!inView) return undefined;\n    }\n    const speed = swiper.params.keyboard.speed;\n    if (swiper.isHorizontal()) {\n      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      }\n      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext(speed);\n      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev(speed);\n    } else {\n      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n        if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      }\n      if (isPageDown || isArrowDown) swiper.slideNext(speed);\n      if (isPageUp || isArrowUp) swiper.slidePrev(speed);\n    }\n    emit('keyPress', kc);\n    return undefined;\n  }\n  function enable() {\n    if (swiper.keyboard.enabled) return;\n    document.addEventListener('keydown', handle);\n    swiper.keyboard.enabled = true;\n  }\n  function disable() {\n    if (!swiper.keyboard.enabled) return;\n    document.removeEventListener('keydown', handle);\n    swiper.keyboard.enabled = false;\n  }\n  on('init', () => {\n    if (swiper.params.keyboard.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    if (swiper.keyboard.enabled) {\n      disable();\n    }\n  });\n  Object.assign(swiper.keyboard, {\n    enable,\n    disable\n  });\n}\n\nexport { Keyboard as default };\n","import { a as getWindow } from '../shared/ssr-window.esm.mjs';\nimport { n as nextTick, h as now } from '../shared/utils.mjs';\n\n/* eslint-disable consistent-return */\nfunction Mousewheel({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null,\n      noMousewheelClass: 'swiper-no-mousewheel'\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n\n    // Ignore event if the target or its parents have the swiper-no-mousewheel class\n    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n    const params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true\n          });\n        }\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              if (swiper.destroyed || !swiper.params) return;\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              if (swiper.destroyed || !swiper.params) return;\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplay.disableOnInteraction) swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {\n          return true;\n        }\n      }\n    }\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  }\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}\n\nexport { Mousewheel as default };\n","import { observeTimeline } from 'motion-dom';\nimport { getTimeline } from './utils/get-timeline.mjs';\n\nfunction attachToAnimation(animation, options) {\n    const timeline = getTimeline(options);\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause();\n            return observeTimeline((progress) => {\n                valueAnimation.time = valueAnimation.duration * progress;\n            }, timeline);\n        },\n    });\n}\n\nexport { attachToAnimation };\n","import { e as effectInit } from '../shared/effect-init.mjs';\nimport { c as createElement, a as getRotateFix } from '../shared/utils.mjs';\n\nfunction EffectCube({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    cubeEffect: {\n      slideShadows: true,\n      shadow: true,\n      shadowOffset: 20,\n      shadowScale: 0.94\n    }\n  });\n  const createSlideShadows = (slideEl, progress, isHorizontal) => {\n    let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n    let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n    if (!shadowBefore) {\n      shadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));\n      slideEl.append(shadowBefore);\n    }\n    if (!shadowAfter) {\n      shadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));\n      slideEl.append(shadowAfter);\n    }\n    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n  };\n  const recreateShadows = () => {\n    // create new ones\n    const isHorizontal = swiper.isHorizontal();\n    swiper.slides.forEach(slideEl => {\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      createSlideShadows(slideEl, progress, isHorizontal);\n    });\n  };\n  const setTranslate = () => {\n    const {\n      el,\n      wrapperEl,\n      slides,\n      width: swiperWidth,\n      height: swiperHeight,\n      rtlTranslate: rtl,\n      size: swiperSize,\n      browser\n    } = swiper;\n    const r = getRotateFix(swiper);\n    const params = swiper.params.cubeEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let wrapperRotate = 0;\n    let cubeShadowEl;\n    if (params.shadow) {\n      if (isHorizontal) {\n        cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');\n        if (!cubeShadowEl) {\n          cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n          swiper.wrapperEl.append(cubeShadowEl);\n        }\n        cubeShadowEl.style.height = `${swiperWidth}px`;\n      } else {\n        cubeShadowEl = el.querySelector('.swiper-cube-shadow');\n        if (!cubeShadowEl) {\n          cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n          el.append(cubeShadowEl);\n        }\n      }\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      let slideIndex = i;\n      if (isVirtual) {\n        slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n      }\n      let slideAngle = slideIndex * 90;\n      let round = Math.floor(slideAngle / 360);\n      if (rtl) {\n        slideAngle = -slideAngle;\n        round = Math.floor(-slideAngle / 360);\n      }\n      const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      let tx = 0;\n      let ty = 0;\n      let tz = 0;\n      if (slideIndex % 4 === 0) {\n        tx = -round * 4 * swiperSize;\n        tz = 0;\n      } else if ((slideIndex - 1) % 4 === 0) {\n        tx = 0;\n        tz = -round * 4 * swiperSize;\n      } else if ((slideIndex - 2) % 4 === 0) {\n        tx = swiperSize + round * 4 * swiperSize;\n        tz = swiperSize;\n      } else if ((slideIndex - 3) % 4 === 0) {\n        tx = -swiperSize;\n        tz = 3 * swiperSize + swiperSize * 4 * round;\n      }\n      if (rtl) {\n        tx = -tx;\n      }\n      if (!isHorizontal) {\n        ty = tx;\n        tx = 0;\n      }\n      const transform = `rotateX(${r(isHorizontal ? 0 : -slideAngle)}deg) rotateY(${r(isHorizontal ? slideAngle : 0)}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n      if (progress <= 1 && progress > -1) {\n        wrapperRotate = slideIndex * 90 + progress * 90;\n        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n      }\n      slideEl.style.transform = transform;\n      if (params.slideShadows) {\n        createSlideShadows(slideEl, progress, isHorizontal);\n      }\n    }\n    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n    wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n    if (params.shadow) {\n      if (isHorizontal) {\n        cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;\n      } else {\n        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n        const scale1 = params.shadowScale;\n        const scale2 = params.shadowScale / multiplier;\n        const offset = params.shadowOffset;\n        cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;\n      }\n    }\n    const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${r(swiper.isHorizontal() ? 0 : wrapperRotate)}deg) rotateY(${r(swiper.isHorizontal() ? -wrapperRotate : 0)}deg)`;\n    wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n  };\n  const setTransition = duration => {\n    const {\n      el,\n      slides\n    } = swiper;\n    slides.forEach(slideEl => {\n      slideEl.style.transitionDuration = `${duration}ms`;\n      slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {\n        subEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n      const shadowEl = el.querySelector('.swiper-cube-shadow');\n      if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n    }\n  };\n  effectInit({\n    effect: 'cube',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    recreateShadows,\n    getEffectParams: () => swiper.params.cubeEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      resistanceRatio: 0,\n      spaceBetween: 0,\n      centeredSlides: false,\n      virtualTranslate: true\n    })\n  });\n}\n\nexport { EffectCube as default };\n","import { a as getWindow } from '../shared/ssr-window.esm.mjs';\nimport { e as elementChildren, d as elementParents, f as elementOffset, l as getTranslate } from '../shared/utils.mjs';\n\nfunction Zoom({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const window = getWindow();\n  extendParams({\n    zoom: {\n      enabled: false,\n      limitToOriginalSize: false,\n      maxRatio: 3,\n      minRatio: 1,\n      panOnMouseMove: false,\n      toggle: true,\n      containerClass: 'swiper-zoom-container',\n      zoomedSlideClass: 'swiper-slide-zoomed'\n    }\n  });\n  swiper.zoom = {\n    enabled: false\n  };\n  let currentScale = 1;\n  let isScaling = false;\n  let isPanningWithMouse = false;\n  let mousePanStart = {\n    x: 0,\n    y: 0\n  };\n  const mousePanSensitivity = -3; // Negative to invert pan direction\n  let fakeGestureTouched;\n  let fakeGestureMoved;\n  const evCache = [];\n  const gesture = {\n    originX: 0,\n    originY: 0,\n    slideEl: undefined,\n    slideWidth: undefined,\n    slideHeight: undefined,\n    imageEl: undefined,\n    imageWrapEl: undefined,\n    maxRatio: 3\n  };\n  const image = {\n    isTouched: undefined,\n    isMoved: undefined,\n    currentX: undefined,\n    currentY: undefined,\n    minX: undefined,\n    minY: undefined,\n    maxX: undefined,\n    maxY: undefined,\n    width: undefined,\n    height: undefined,\n    startX: undefined,\n    startY: undefined,\n    touchesStart: {},\n    touchesCurrent: {}\n  };\n  const velocity = {\n    x: undefined,\n    y: undefined,\n    prevPositionX: undefined,\n    prevPositionY: undefined,\n    prevTime: undefined\n  };\n  let scale = 1;\n  Object.defineProperty(swiper.zoom, 'scale', {\n    get() {\n      return scale;\n    },\n    set(value) {\n      if (scale !== value) {\n        const imageEl = gesture.imageEl;\n        const slideEl = gesture.slideEl;\n        emit('zoomChange', value, imageEl, slideEl);\n      }\n      scale = value;\n    }\n  });\n  function getDistanceBetweenTouches() {\n    if (evCache.length < 2) return 1;\n    const x1 = evCache[0].pageX;\n    const y1 = evCache[0].pageY;\n    const x2 = evCache[1].pageX;\n    const y2 = evCache[1].pageY;\n    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n    return distance;\n  }\n  function getMaxRatio() {\n    const params = swiper.params.zoom;\n    const maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n    if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {\n      const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;\n      return Math.min(imageMaxRatio, maxRatio);\n    }\n    return maxRatio;\n  }\n  function getScaleOrigin() {\n    if (evCache.length < 2) return {\n      x: null,\n      y: null\n    };\n    const box = gesture.imageEl.getBoundingClientRect();\n    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale];\n  }\n  function getSlideSelector() {\n    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  }\n  function eventWithinSlide(e) {\n    const slideSelector = getSlideSelector();\n    if (e.target.matches(slideSelector)) return true;\n    if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\n    return false;\n  }\n  function eventWithinZoomContainer(e) {\n    const selector = `.${swiper.params.zoom.containerClass}`;\n    if (e.target.matches(selector)) return true;\n    if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\n    return false;\n  }\n\n  // Events\n  function onGestureStart(e) {\n    if (e.pointerType === 'mouse') {\n      evCache.splice(0, evCache.length);\n    }\n    if (!eventWithinSlide(e)) return;\n    const params = swiper.params.zoom;\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    evCache.push(e);\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureTouched = true;\n    gesture.scaleStart = getDistanceBetweenTouches();\n    if (!gesture.slideEl) {\n      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n      if (!gesture.imageWrapEl) {\n        gesture.imageEl = undefined;\n        return;\n      }\n      gesture.maxRatio = getMaxRatio();\n    }\n    if (gesture.imageEl) {\n      const [originX, originY] = getScaleOrigin();\n      gesture.originX = originX;\n      gesture.originY = originY;\n      gesture.imageEl.style.transitionDuration = '0ms';\n    }\n    isScaling = true;\n  }\n  function onGestureChange(e) {\n    if (!eventWithinSlide(e)) return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) evCache[pointerIndex] = e;\n    if (evCache.length < 2) {\n      return;\n    }\n    fakeGestureMoved = true;\n    gesture.scaleMove = getDistanceBetweenTouches();\n    if (!gesture.imageEl) {\n      return;\n    }\n    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n    if (zoom.scale > gesture.maxRatio) {\n      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n    }\n    if (zoom.scale < params.minRatio) {\n      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n    }\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function onGestureEnd(e) {\n    if (!eventWithinSlide(e)) return;\n    if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n    const params = swiper.params.zoom;\n    const zoom = swiper.zoom;\n    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n    if (!fakeGestureTouched || !fakeGestureMoved) {\n      return;\n    }\n    fakeGestureTouched = false;\n    fakeGestureMoved = false;\n    if (!gesture.imageEl) return;\n    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    currentScale = zoom.scale;\n    isScaling = false;\n    if (zoom.scale > 1 && gesture.slideEl) {\n      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    } else if (zoom.scale <= 1 && gesture.slideEl) {\n      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    }\n    if (zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n      gesture.slideEl = undefined;\n    }\n  }\n  let allowTouchMoveTimeout;\n  function allowTouchMove() {\n    swiper.touchEventsData.preventTouchMoveFromPointerMove = false;\n  }\n  function preventTouchMove() {\n    clearTimeout(allowTouchMoveTimeout);\n    swiper.touchEventsData.preventTouchMoveFromPointerMove = true;\n    allowTouchMoveTimeout = setTimeout(() => {\n      if (swiper.destroyed) return;\n      allowTouchMove();\n    });\n  }\n  function onTouchStart(e) {\n    const device = swiper.device;\n    if (!gesture.imageEl) return;\n    if (image.isTouched) return;\n    if (device.android && e.cancelable) e.preventDefault();\n    image.isTouched = true;\n    const event = evCache.length > 0 ? evCache[0] : e;\n    image.touchesStart.x = event.pageX;\n    image.touchesStart.y = event.pageY;\n  }\n  function onTouchMove(e) {\n    const isMouseEvent = e.pointerType === 'mouse';\n    const isMousePan = isMouseEvent && swiper.params.zoom.panOnMouseMove;\n    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {\n      return;\n    }\n    const zoom = swiper.zoom;\n    if (!gesture.imageEl) {\n      return;\n    }\n    if (!image.isTouched || !gesture.slideEl) {\n      if (isMousePan) onMouseMove(e);\n      return;\n    }\n    if (isMousePan) {\n      onMouseMove(e);\n      return;\n    }\n    if (!image.isMoved) {\n      image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;\n      image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;\n      image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n      image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n      gesture.slideWidth = gesture.slideEl.offsetWidth;\n      gesture.slideHeight = gesture.slideEl.offsetHeight;\n      gesture.imageWrapEl.style.transitionDuration = '0ms';\n    }\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n    if (touchesDiff > 5) {\n      swiper.allowClick = false;\n    }\n    if (!image.isMoved && !isScaling) {\n      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n        image.isTouched = false;\n        allowTouchMove();\n        return;\n      }\n      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n        image.isTouched = false;\n        allowTouchMove();\n        return;\n      }\n    }\n    if (e.cancelable) {\n      e.preventDefault();\n    }\n    e.stopPropagation();\n    preventTouchMove();\n    image.isMoved = true;\n    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n    const {\n      originX,\n      originY\n    } = gesture;\n    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n    if (image.currentX < image.minX) {\n      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n    }\n    if (image.currentX > image.maxX) {\n      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n    }\n    if (image.currentY < image.minY) {\n      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n    }\n    if (image.currentY > image.maxY) {\n      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n    }\n\n    // Velocity\n    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n    if (!velocity.prevTime) velocity.prevTime = Date.now();\n    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n    velocity.prevPositionX = image.touchesCurrent.x;\n    velocity.prevPositionY = image.touchesCurrent.y;\n    velocity.prevTime = Date.now();\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTouchEnd() {\n    const zoom = swiper.zoom;\n    evCache.length = 0;\n    if (!gesture.imageEl) return;\n    if (!image.isTouched || !image.isMoved) {\n      image.isTouched = false;\n      image.isMoved = false;\n      return;\n    }\n    image.isTouched = false;\n    image.isMoved = false;\n    let momentumDurationX = 300;\n    let momentumDurationY = 300;\n    const momentumDistanceX = velocity.x * momentumDurationX;\n    const newPositionX = image.currentX + momentumDistanceX;\n    const momentumDistanceY = velocity.y * momentumDurationY;\n    const newPositionY = image.currentY + momentumDistanceY;\n\n    // Fix duration\n    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n    image.currentX = newPositionX;\n    image.currentY = newPositionY;\n    // Define if we need image drag\n    const scaledWidth = image.width * zoom.scale;\n    const scaledHeight = image.height * zoom.scale;\n    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n    image.maxX = -image.minX;\n    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n    image.maxY = -image.minY;\n    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n  }\n  function onTransitionEnd() {\n    const zoom = swiper.zoom;\n    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n      if (gesture.imageEl) {\n        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n      }\n      if (gesture.imageWrapEl) {\n        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n      }\n      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n      zoom.scale = 1;\n      currentScale = 1;\n      gesture.slideEl = undefined;\n      gesture.imageEl = undefined;\n      gesture.imageWrapEl = undefined;\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n  }\n  function onMouseMove(e) {\n    // Only pan if zoomed in and mouse panning is enabled\n    if (currentScale <= 1 || !gesture.imageWrapEl) return;\n    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n    const currentTransform = window.getComputedStyle(gesture.imageWrapEl).transform;\n    const matrix = new window.DOMMatrix(currentTransform);\n    if (!isPanningWithMouse) {\n      isPanningWithMouse = true;\n      mousePanStart.x = e.clientX;\n      mousePanStart.y = e.clientY;\n      image.startX = matrix.e;\n      image.startY = matrix.f;\n      image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;\n      image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;\n      gesture.slideWidth = gesture.slideEl.offsetWidth;\n      gesture.slideHeight = gesture.slideEl.offsetHeight;\n      return;\n    }\n    const deltaX = (e.clientX - mousePanStart.x) * mousePanSensitivity;\n    const deltaY = (e.clientY - mousePanStart.y) * mousePanSensitivity;\n    const scaledWidth = image.width * currentScale;\n    const scaledHeight = image.height * currentScale;\n    const slideWidth = gesture.slideWidth;\n    const slideHeight = gesture.slideHeight;\n    const minX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n    const maxX = -minX;\n    const minY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n    const maxY = -minY;\n    const newX = Math.max(Math.min(image.startX + deltaX, maxX), minX);\n    const newY = Math.max(Math.min(image.startY + deltaY, maxY), minY);\n    gesture.imageWrapEl.style.transitionDuration = '0ms';\n    gesture.imageWrapEl.style.transform = `translate3d(${newX}px, ${newY}px, 0)`;\n    mousePanStart.x = e.clientX;\n    mousePanStart.y = e.clientY;\n    image.startX = newX;\n    image.startY = newY;\n    image.currentX = newX;\n    image.currentY = newY;\n  }\n  function zoomIn(e) {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    if (!gesture.slideEl) {\n      if (e && e.target) {\n        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      }\n      if (!gesture.slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n        } else {\n          gesture.slideEl = swiper.slides[swiper.activeIndex];\n        }\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\n    gesture.maxRatio = getMaxRatio();\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.touchAction = 'none';\n    }\n    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n    let touchX;\n    let touchY;\n    let offsetX;\n    let offsetY;\n    let diffX;\n    let diffY;\n    let translateX;\n    let translateY;\n    let imageWidth;\n    let imageHeight;\n    let scaledWidth;\n    let scaledHeight;\n    let translateMinX;\n    let translateMinY;\n    let translateMaxX;\n    let translateMaxY;\n    let slideWidth;\n    let slideHeight;\n    if (typeof image.touchesStart.x === 'undefined' && e) {\n      touchX = e.pageX;\n      touchY = e.pageY;\n    } else {\n      touchX = image.touchesStart.x;\n      touchY = image.touchesStart.y;\n    }\n    const prevScale = currentScale;\n    const forceZoomRatio = typeof e === 'number' ? e : null;\n    if (currentScale === 1 && forceZoomRatio) {\n      touchX = undefined;\n      touchY = undefined;\n      image.touchesStart.x = undefined;\n      image.touchesStart.y = undefined;\n    }\n    const maxRatio = getMaxRatio();\n    zoom.scale = forceZoomRatio || maxRatio;\n    currentScale = forceZoomRatio || maxRatio;\n    if (e && !(currentScale === 1 && forceZoomRatio)) {\n      slideWidth = gesture.slideEl.offsetWidth;\n      slideHeight = gesture.slideEl.offsetHeight;\n      offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n      offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n      diffX = offsetX + slideWidth / 2 - touchX;\n      diffY = offsetY + slideHeight / 2 - touchY;\n      imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;\n      imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;\n      scaledWidth = imageWidth * zoom.scale;\n      scaledHeight = imageHeight * zoom.scale;\n      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n      translateMaxX = -translateMinX;\n      translateMaxY = -translateMinY;\n      if (prevScale > 0 && forceZoomRatio && typeof image.currentX === 'number' && typeof image.currentY === 'number') {\n        translateX = image.currentX * zoom.scale / prevScale;\n        translateY = image.currentY * zoom.scale / prevScale;\n      } else {\n        translateX = diffX * zoom.scale;\n        translateY = diffY * zoom.scale;\n      }\n      if (translateX < translateMinX) {\n        translateX = translateMinX;\n      }\n      if (translateX > translateMaxX) {\n        translateX = translateMaxX;\n      }\n      if (translateY < translateMinY) {\n        translateY = translateMinY;\n      }\n      if (translateY > translateMaxY) {\n        translateY = translateMaxY;\n      }\n    } else {\n      translateX = 0;\n      translateY = 0;\n    }\n    if (forceZoomRatio && zoom.scale === 1) {\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n    image.currentX = translateX;\n    image.currentY = translateY;\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\n    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n    gesture.imageEl.style.transitionDuration = '300ms';\n    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n  }\n  function zoomOut() {\n    const zoom = swiper.zoom;\n    const params = swiper.params.zoom;\n    if (!gesture.slideEl) {\n      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n      } else {\n        gesture.slideEl = swiper.slides[swiper.activeIndex];\n      }\n      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n      if (imageEl) {\n        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n      }\n      gesture.imageEl = imageEl;\n      if (imageEl) {\n        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n      } else {\n        gesture.imageWrapEl = undefined;\n      }\n    }\n    if (!gesture.imageEl || !gesture.imageWrapEl) return;\n    gesture.maxRatio = getMaxRatio();\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style.overflow = '';\n      swiper.wrapperEl.style.touchAction = '';\n    }\n    zoom.scale = 1;\n    currentScale = 1;\n    image.currentX = undefined;\n    image.currentY = undefined;\n    image.touchesStart.x = undefined;\n    image.touchesStart.y = undefined;\n    gesture.imageWrapEl.style.transitionDuration = '300ms';\n    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n    gesture.imageEl.style.transitionDuration = '300ms';\n    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n    gesture.slideEl = undefined;\n    gesture.originX = 0;\n    gesture.originY = 0;\n    if (swiper.params.zoom.panOnMouseMove) {\n      mousePanStart = {\n        x: 0,\n        y: 0\n      };\n      if (isPanningWithMouse) {\n        isPanningWithMouse = false;\n        image.startX = 0;\n        image.startY = 0;\n      }\n    }\n  }\n\n  // Toggle Zoom\n  function zoomToggle(e) {\n    const zoom = swiper.zoom;\n    if (zoom.scale && zoom.scale !== 1) {\n      // Zoom Out\n      zoomOut();\n    } else {\n      // Zoom In\n      zoomIn(e);\n    }\n  }\n  function getListeners() {\n    const passiveListener = swiper.params.passiveListeners ? {\n      passive: true,\n      capture: false\n    } : false;\n    const activeListenerWithCapture = swiper.params.passiveListeners ? {\n      passive: false,\n      capture: true\n    } : true;\n    return {\n      passiveListener,\n      activeListenerWithCapture\n    };\n  }\n\n  // Attach/Detach Events\n  function enable() {\n    const zoom = swiper.zoom;\n    if (zoom.enabled) return;\n    zoom.enabled = true;\n    const {\n      passiveListener,\n      activeListenerWithCapture\n    } = getListeners();\n\n    // Scale image\n    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n    });\n\n    // Move image\n    swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n  }\n  function disable() {\n    const zoom = swiper.zoom;\n    if (!zoom.enabled) return;\n    zoom.enabled = false;\n    const {\n      passiveListener,\n      activeListenerWithCapture\n    } = getListeners();\n\n    // Scale image\n    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n    });\n\n    // Move image\n    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n  }\n  on('init', () => {\n    if (swiper.params.zoom.enabled) {\n      enable();\n    }\n  });\n  on('destroy', () => {\n    disable();\n  });\n  on('touchStart', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchStart(e);\n  });\n  on('touchEnd', (_s, e) => {\n    if (!swiper.zoom.enabled) return;\n    onTouchEnd();\n  });\n  on('doubleTap', (_s, e) => {\n    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n      zoomToggle(e);\n    }\n  });\n  on('transitionEnd', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n      onTransitionEnd();\n    }\n  });\n  on('slideChange', () => {\n    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n      onTransitionEnd();\n    }\n  });\n  Object.assign(swiper.zoom, {\n    enable,\n    disable,\n    in: zoomIn,\n    out: zoomOut,\n    toggle: zoomToggle\n  });\n}\n\nexport { Zoom as default };\n","import { collectMotionValues } from 'motion-dom';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\n\nfunction useComputed(compute) {\n    /**\n     * Open session of collectMotionValues. Any MotionValue that calls get()\n     * will be saved into this array.\n     */\n    collectMotionValues.current = [];\n    compute();\n    const value = useCombineMotionValues(collectMotionValues.current, compute);\n    /**\n     * Synchronously close session of collectMotionValues.\n     */\n    collectMotionValues.current = undefined;\n    return value;\n}\n\nexport { useComputed };\n","import { a as getWindow, g as getDocument } from './ssr-window.esm.mjs';\nimport { d as elementParents, q as elementStyle, e as elementChildren, b as setCSSProperty, i as elementOuterSize, r as elementNextAll, t as elementPrevAll, l as getTranslate, u as animateCSSModeScroll, n as nextTick, v as showWarning, c as createElement, w as elementIsChildOf, h as now, x as extend, j as elementIndex, y as deleteProps } from './utils.mjs';\n\nlet support;\nfunction calcSupport() {\n  const window = getWindow();\n  const document = getDocument();\n  return {\n    smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,\n    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)\n  };\n}\nfunction getSupport() {\n  if (!support) {\n    support = calcSupport();\n  }\n  return support;\n}\n\nlet deviceCached;\nfunction calcDevice({\n  userAgent\n} = {}) {\n  const support = getSupport();\n  const window = getWindow();\n  const platform = window.navigator.platform;\n  const ua = userAgent || window.navigator.userAgent;\n  const device = {\n    ios: false,\n    android: false\n  };\n  const screenWidth = window.screen.width;\n  const screenHeight = window.screen.height;\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  let ipad = ua.match(/(iPad)(?!\\1).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  const windows = platform === 'Win32';\n  let macos = platform === 'MacIntel';\n\n  // iPadOs 13 fix\n  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    if (!ipad) ipad = [0, 1, '13_0_0'];\n    macos = false;\n  }\n\n  // Android\n  if (android && !windows) {\n    device.os = 'android';\n    device.android = true;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  }\n\n  // Export object\n  return device;\n}\nfunction getDevice(overrides = {}) {\n  if (!deviceCached) {\n    deviceCached = calcDevice(overrides);\n  }\n  return deviceCached;\n}\n\nlet browser;\nfunction calcBrowser() {\n  const window = getWindow();\n  const device = getDevice();\n  let needPerspectiveFix = false;\n  function isSafari() {\n    const ua = window.navigator.userAgent.toLowerCase();\n    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n  }\n  if (isSafari()) {\n    const ua = String(window.navigator.userAgent);\n    if (ua.includes('Version/')) {\n      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));\n      needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n    }\n  }\n  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);\n  const isSafariBrowser = isSafari();\n  const need3dFix = isSafariBrowser || isWebView && device.ios;\n  return {\n    isSafari: needPerspectiveFix || isSafariBrowser,\n    needPerspectiveFix,\n    need3dFix,\n    isWebView\n  };\n}\nfunction getBrowser() {\n  if (!browser) {\n    browser = calcBrowser();\n  }\n  return browser;\n}\n\nfunction Resize({\n  swiper,\n  on,\n  emit\n}) {\n  const window = getWindow();\n  let observer = null;\n  let animationFrame = null;\n  const resizeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('beforeResize');\n    emit('resize');\n  };\n  const createObserver = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    observer = new ResizeObserver(entries => {\n      animationFrame = window.requestAnimationFrame(() => {\n        const {\n          width,\n          height\n        } = swiper;\n        let newWidth = width;\n        let newHeight = height;\n        entries.forEach(({\n          contentBoxSize,\n          contentRect,\n          target\n        }) => {\n          if (target && target !== swiper.el) return;\n          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n        });\n        if (newWidth !== width || newHeight !== height) {\n          resizeHandler();\n        }\n      });\n    });\n    observer.observe(swiper.el);\n  };\n  const removeObserver = () => {\n    if (animationFrame) {\n      window.cancelAnimationFrame(animationFrame);\n    }\n    if (observer && observer.unobserve && swiper.el) {\n      observer.unobserve(swiper.el);\n      observer = null;\n    }\n  };\n  const orientationChangeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('orientationchange');\n  };\n  on('init', () => {\n    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n      createObserver();\n      return;\n    }\n    window.addEventListener('resize', resizeHandler);\n    window.addEventListener('orientationchange', orientationChangeHandler);\n  });\n  on('destroy', () => {\n    removeObserver();\n    window.removeEventListener('resize', resizeHandler);\n    window.removeEventListener('orientationchange', orientationChangeHandler);\n  });\n}\n\nfunction Observer({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const observers = [];\n  const window = getWindow();\n  const attach = (target, options = {}) => {\n    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n    const observer = new ObserverFunc(mutations => {\n      // The observerUpdate event should only be triggered\n      // once despite the number of mutations.  Additional\n      // triggers are redundant and are very costly\n      if (swiper.__preventObserver__) return;\n      if (mutations.length === 1) {\n        emit('observerUpdate', mutations[0]);\n        return;\n      }\n      const observerUpdate = function observerUpdate() {\n        emit('observerUpdate', mutations[0]);\n      };\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(observerUpdate);\n      } else {\n        window.setTimeout(observerUpdate, 0);\n      }\n    });\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: swiper.isElement || (typeof options.childList === 'undefined' ? true : options).childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData\n    });\n    observers.push(observer);\n  };\n  const init = () => {\n    if (!swiper.params.observer) return;\n    if (swiper.params.observeParents) {\n      const containerParents = elementParents(swiper.hostEl);\n      for (let i = 0; i < containerParents.length; i += 1) {\n        attach(containerParents[i]);\n      }\n    }\n    // Observe container\n    attach(swiper.hostEl, {\n      childList: swiper.params.observeSlideChildren\n    });\n\n    // Observe wrapper\n    attach(swiper.wrapperEl, {\n      attributes: false\n    });\n  };\n  const destroy = () => {\n    observers.forEach(observer => {\n      observer.disconnect();\n    });\n    observers.splice(0, observers.length);\n  };\n  extendParams({\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false\n  });\n  on('init', init);\n  on('destroy', destroy);\n}\n\n/* eslint-disable no-underscore-dangle */\n\nvar eventsEmitter = {\n  on(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    events.split(' ').forEach(event => {\n      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  },\n  once(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    function onceHandler(...args) {\n      self.off(events, onceHandler);\n      if (onceHandler.__emitterProxy) {\n        delete onceHandler.__emitterProxy;\n      }\n      handler.apply(self, args);\n    }\n    onceHandler.__emitterProxy = handler;\n    return self.on(events, onceHandler, priority);\n  },\n  onAny(handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    if (self.eventsAnyListeners.indexOf(handler) < 0) {\n      self.eventsAnyListeners[method](handler);\n    }\n    return self;\n  },\n  offAny(handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsAnyListeners) return self;\n    const index = self.eventsAnyListeners.indexOf(handler);\n    if (index >= 0) {\n      self.eventsAnyListeners.splice(index, 1);\n    }\n    return self;\n  },\n  off(events, handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    events.split(' ').forEach(event => {\n      if (typeof handler === 'undefined') {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler, index) => {\n          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n            self.eventsListeners[event].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  },\n  emit(...args) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    let events;\n    let data;\n    let context;\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n      events = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    data.unshift(context);\n    const eventsArray = Array.isArray(events) ? events : events.split(' ');\n    eventsArray.forEach(event => {\n      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n        self.eventsAnyListeners.forEach(eventHandler => {\n          eventHandler.apply(context, [event, ...data]);\n        });\n      }\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach(eventHandler => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  }\n};\n\nfunction updateSize() {\n  const swiper = this;\n  let width;\n  let height;\n  const el = swiper.el;\n  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n    width = swiper.params.width;\n  } else {\n    width = el.clientWidth;\n  }\n  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n    height = swiper.params.height;\n  } else {\n    height = el.clientHeight;\n  }\n  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n    return;\n  }\n\n  // Subtract paddings\n  width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);\n  height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n  if (Number.isNaN(width)) width = 0;\n  if (Number.isNaN(height)) height = 0;\n  Object.assign(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height\n  });\n}\n\nfunction updateSlides() {\n  const swiper = this;\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);\n  }\n  const params = swiper.params;\n  const {\n    wrapperEl,\n    slidesEl,\n    rtlTranslate: rtl,\n    wrongRTL\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n  const swiperSize = swiper.size - offsetBefore - offsetAfter;\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n  } else if (typeof spaceBetween === 'string') {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n  swiper.virtualSize = -spaceBetween - offsetBefore - offsetAfter;\n\n  // reset margins\n  slides.forEach(slideEl => {\n    if (rtl) {\n      slideEl.style.marginLeft = '';\n    } else {\n      slideEl.style.marginRight = '';\n    }\n    slideEl.style.marginBottom = '';\n    slideEl.style.marginTop = '';\n  });\n\n  // reset cssMode offsets\n  if (params.centeredSlides && params.cssMode) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n  }\n\n  // set cssMode offsets\n  if (params.cssMode) {\n    setCSSProperty(wrapperEl, '--swiper-slides-offset-before', `${offsetBefore}px`);\n    setCSSProperty(wrapperEl, '--swiper-slides-offset-after', `${offsetAfter}px`);\n  }\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n  if (gridEnabled) {\n    swiper.grid.initSlides(slides);\n  } else if (swiper.grid) {\n    swiper.grid.unsetSlides();\n  }\n\n  // Calc slides\n  let slideSize;\n  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n    return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n  }).length > 0;\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    const slide = slides[i];\n    if (slide) {\n      if (gridEnabled) {\n        swiper.grid.updateSlide(i, slide, slides);\n      }\n      if (elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n    }\n\n    if (isVirtual && params.slidesPerView === 'auto') {\n      if (params.virtual.slidesPerViewAutoSlideSize) {\n        slideSize = params.virtual.slidesPerViewAutoSlideSize;\n      }\n      if (slideSize && slide) {\n        if (params.roundLengths) slideSize = Math.floor(slideSize);\n        slide.style[swiper.getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    } else if (params.slidesPerView === 'auto') {\n      if (shouldResetSlideSize) {\n        slide.style[swiper.getDirectionLabel('width')] = ``;\n      }\n      const slideStyles = getComputedStyle(slide);\n      const currentTransform = slide.style.transform;\n      const currentWebKitTransform = slide.style.webkitTransform;\n      if (currentTransform) {\n        slide.style.transform = 'none';\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = 'none';\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n      } else {\n        // eslint-disable-next-line\n        const width = getDirectionPropertyValue(slideStyles, 'width');\n        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        const boxSizing = slideStyles.getPropertyValue('box-sizing');\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const {\n            clientWidth,\n            offsetWidth\n          } = slide;\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n      if (currentTransform) {\n        slide.style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n      if (slide) {\n        slide.style[swiper.getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    }\n    if (slide) {\n      slide.swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (params.setWrapperSize) {\n    wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid);\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    // Check if snapToSlideEdge should be applied\n    const isFractionalSlidesPerView = params.slidesPerView !== 'auto' && params.slidesPerView % 1 !== 0;\n    const shouldSnapToSlideEdge = params.snapToSlideEdge && !params.loop && (params.slidesPerView === 'auto' || isFractionalSlidesPerView);\n\n    // Calculate the last allowed snap index when snapToSlideEdge is enabled\n    // This ensures minimum slides are visible at the end\n    let lastAllowedSnapIndex = snapGrid.length;\n    if (shouldSnapToSlideEdge) {\n      let minVisibleSlides;\n      if (params.slidesPerView === 'auto') {\n        // For 'auto' mode, calculate how many slides fit based on actual sizes\n        minVisibleSlides = 1;\n        let accumulatedSize = 0;\n        for (let i = slidesSizesGrid.length - 1; i >= 0; i -= 1) {\n          accumulatedSize += slidesSizesGrid[i] + (i < slidesSizesGrid.length - 1 ? spaceBetween : 0);\n          if (accumulatedSize <= swiperSize) {\n            minVisibleSlides = slidesSizesGrid.length - i;\n          } else {\n            break;\n          }\n        }\n      } else {\n        minVisibleSlides = Math.floor(params.slidesPerView);\n      }\n      lastAllowedSnapIndex = Math.max(slidesLength - minVisibleSlides, 0);\n    }\n    const newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n      if (shouldSnapToSlideEdge) {\n        // When snapToSlideEdge is enabled, only keep snaps up to lastAllowedSnapIndex\n        if (i <= lastAllowedSnapIndex) {\n          newSlidesGrid.push(slidesGridItem);\n        }\n      } else if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        // When snapToSlideEdge is disabled, keep snaps that fit within scrollable area\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      // Only add edge-aligned snap if snapToSlideEdge is not enabled\n      if (!shouldSnapToSlideEdge) {\n        snapGrid.push(swiper.virtualSize - swiperSize);\n      }\n    }\n  }\n  if (isVirtual && params.loop) {\n    const size = slidesSizesGrid[0] + spaceBetween;\n    if (params.slidesPerGroup > 1) {\n      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n      const groupSize = size * params.slidesPerGroup;\n      for (let i = 0; i < groups; i += 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n      }\n    }\n    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n      if (params.slidesPerGroup === 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n      }\n      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n      swiper.virtualSize += size;\n    }\n  }\n  if (snapGrid.length === 0) snapGrid = [0];\n  if (spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');\n    slides.filter((_, slideIndex) => {\n      if (!params.cssMode || params.loop) return true;\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n      return true;\n    }).forEach(slideEl => {\n      slideEl.style[key] = `${spaceBetween}px`;\n    });\n  }\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;\n    snapGrid = snapGrid.map(snap => {\n      if (snap <= 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    const offsetSize = (offsetBefore || 0) + (offsetAfter || 0);\n    if (allSlidesSize + offsetSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid\n  });\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n  }\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  swiper.emit('slidesUpdated');\n  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.el.classList.remove(backFaceHiddenClass);\n    }\n  }\n}\n\nfunction updateAutoHeight(speed) {\n  const swiper = this;\n  const activeSlides = [];\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  let newHeight = 0;\n  let i;\n  if (typeof speed === 'number') {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n  const getSlideByIndex = index => {\n    if (isVirtual) {\n      return swiper.slides[swiper.getSlideIndexByData(index)];\n    }\n    return swiper.slides[index];\n  };\n  // Find slides currently in view\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      (swiper.visibleSlides || []).forEach(slide => {\n        activeSlides.push(slide);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        const index = swiper.activeIndex + i;\n        if (index > swiper.slides.length && !isVirtual) break;\n        activeSlides.push(getSlideByIndex(index));\n      }\n    }\n  } else {\n    activeSlides.push(getSlideByIndex(swiper.activeIndex));\n  }\n\n  // Find new height from highest slide in view\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n\n  // Update Height\n  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n}\n\nfunction updateSlidesOffset() {\n  const swiper = this;\n  const slides = swiper.slides;\n  // eslint-disable-next-line\n  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n  }\n}\n\nconst toggleSlideClasses$1 = (slideEl, condition, className) => {\n  if (condition && !slideEl.classList.contains(className)) {\n    slideEl.classList.add(className);\n  } else if (!condition && slideEl.classList.contains(className)) {\n    slideEl.classList.remove(className);\n  }\n};\nfunction updateSlidesProgress(translate = this && this.translate || 0) {\n  const swiper = this;\n  const params = swiper.params;\n  const {\n    slides,\n    rtlTranslate: rtl,\n    snapGrid\n  } = swiper;\n  if (slides.length === 0) return;\n  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n  let offsetCenter = -translate;\n  if (rtl) offsetCenter = translate;\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n  let spaceBetween = params.spaceBetween;\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n  } else if (typeof spaceBetween === 'string') {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide = slides[i];\n    let slideOffset = slide.swiperSlideOffset;\n    if (params.cssMode && params.centeredSlides) {\n      slideOffset -= slides[0].swiperSlideOffset;\n    }\n    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n    const slideBefore = -(offsetCenter - slideOffset);\n    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];\n    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n    if (isVisible) {\n      swiper.visibleSlides.push(slide);\n      swiper.visibleSlidesIndexes.push(i);\n    }\n    toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);\n    toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);\n    slide.progress = rtl ? -slideProgress : slideProgress;\n    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n  }\n}\n\nfunction updateProgress(translate) {\n  const swiper = this;\n  if (typeof translate === 'undefined') {\n    const multiplier = swiper.rtlTranslate ? -1 : 1;\n    // eslint-disable-next-line\n    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n  }\n  const params = swiper.params;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let {\n    progress,\n    isBeginning,\n    isEnd,\n    progressLoop\n  } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / translatesDiff;\n    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n    isBeginning = isBeginningRounded || progress <= 0;\n    isEnd = isEndRounded || progress >= 1;\n    if (isBeginningRounded) progress = 0;\n    if (isEndRounded) progress = 1;\n  }\n  if (params.loop) {\n    const firstSlideIndex = swiper.getSlideIndexByData(0);\n    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n    const translateAbs = Math.abs(translate);\n    if (translateAbs >= firstSlideTranslate) {\n      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n    } else {\n      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n    }\n    if (progressLoop > 1) progressLoop -= 1;\n  }\n  Object.assign(swiper, {\n    progress,\n    progressLoop,\n    isBeginning,\n    isEnd\n  });\n  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n    swiper.emit('fromEdge');\n  }\n  swiper.emit('progress', progress);\n}\n\nconst toggleSlideClasses = (slideEl, condition, className) => {\n  if (condition && !slideEl.classList.contains(className)) {\n    slideEl.classList.add(className);\n  } else if (!condition && slideEl.classList.contains(className)) {\n    slideEl.classList.remove(className);\n  }\n};\nfunction updateSlidesClasses() {\n  const swiper = this;\n  const {\n    slides,\n    params,\n    slidesEl,\n    activeIndex\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n  const getFilteredSlide = selector => {\n    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n  };\n  let activeSlide;\n  let prevSlide;\n  let nextSlide;\n  if (isVirtual) {\n    if (params.loop) {\n      let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n    } else {\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n    }\n  } else {\n    if (gridEnabled) {\n      activeSlide = slides.find(slideEl => slideEl.column === activeIndex);\n      nextSlide = slides.find(slideEl => slideEl.column === activeIndex + 1);\n      prevSlide = slides.find(slideEl => slideEl.column === activeIndex - 1);\n    } else {\n      activeSlide = slides[activeIndex];\n    }\n  }\n  if (activeSlide) {\n    if (!gridEnabled) {\n      // Next Slide\n      nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n      if (params.loop && !nextSlide) {\n        nextSlide = slides[0];\n      }\n\n      // Prev Slide\n      prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n      if (params.loop && !prevSlide === 0) {\n        prevSlide = slides[slides.length - 1];\n      }\n    }\n  }\n  slides.forEach(slideEl => {\n    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);\n    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);\n    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);\n  });\n  swiper.emitSlidesClasses();\n}\n\nconst processLazyPreloader = (swiper, imageEl) => {\n  if (!swiper || swiper.destroyed || !swiper.params) return;\n  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  const slideEl = imageEl.closest(slideSelector());\n  if (slideEl) {\n    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n    if (!lazyEl && swiper.isElement) {\n      if (slideEl.shadowRoot) {\n        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n      } else {\n        // init later\n        requestAnimationFrame(() => {\n          if (slideEl.shadowRoot) {\n            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n            if (lazyEl && !lazyEl.lazyPreloaderManaged) lazyEl.remove();\n          }\n        });\n      }\n    }\n    // Skip removal if managed by React/Vue component\n    if (lazyEl && !lazyEl.lazyPreloaderManaged) lazyEl.remove();\n  }\n};\nconst unlazy = (swiper, index) => {\n  if (!swiper.slides[index]) return;\n  const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n  if (imageEl) imageEl.removeAttribute('loading');\n};\nconst preload = swiper => {\n  if (!swiper || swiper.destroyed || !swiper.params) return;\n  let amount = swiper.params.lazyPreloadPrevNext;\n  const len = swiper.slides.length;\n  if (!len || !amount || amount < 0) return;\n  amount = Math.min(amount, len);\n  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n  const activeIndex = swiper.activeIndex;\n  if (swiper.params.grid && swiper.params.grid.rows > 1) {\n    const activeColumn = activeIndex;\n    const preloadColumns = [activeColumn - amount];\n    preloadColumns.push(...Array.from({\n      length: amount\n    }).map((_, i) => {\n      return activeColumn + slidesPerView + i;\n    }));\n    swiper.slides.forEach((slideEl, i) => {\n      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n    });\n    return;\n  }\n  const slideIndexLastInView = activeIndex + slidesPerView - 1;\n  if (swiper.params.rewind || swiper.params.loop) {\n    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n      const realIndex = (i % len + len) % len;\n      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n    }\n  } else {\n    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n        unlazy(swiper, i);\n      }\n    }\n  }\n};\n\nfunction getActiveIndexByTranslate(swiper) {\n  const {\n    slidesGrid,\n    params\n  } = swiper;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  let activeIndex;\n  for (let i = 0; i < slidesGrid.length; i += 1) {\n    if (typeof slidesGrid[i + 1] !== 'undefined') {\n      if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n        activeIndex = i;\n      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n        activeIndex = i + 1;\n      }\n    } else if (translate >= slidesGrid[i]) {\n      activeIndex = i;\n    }\n  }\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n  }\n  return activeIndex;\n}\nfunction updateActiveIndex(newActiveIndex) {\n  const swiper = this;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    snapGrid,\n    params,\n    activeIndex: previousIndex,\n    realIndex: previousRealIndex,\n    snapIndex: previousSnapIndex\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n  const getVirtualRealIndex = aIndex => {\n    let realIndex = aIndex - swiper.virtual.slidesBefore;\n    if (realIndex < 0) {\n      realIndex = swiper.virtual.slides.length + realIndex;\n    }\n    if (realIndex >= swiper.virtual.slides.length) {\n      realIndex -= swiper.virtual.slides.length;\n    }\n    return realIndex;\n  };\n  if (typeof activeIndex === 'undefined') {\n    activeIndex = getActiveIndexByTranslate(swiper);\n  }\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex && !swiper.params.loop) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n    return;\n  }\n  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n    swiper.realIndex = getVirtualRealIndex(activeIndex);\n    return;\n  }\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n\n  // Get real index\n  let realIndex;\n  if (swiper.virtual && params.virtual.enabled) {\n    if (params.loop) {\n      realIndex = getVirtualRealIndex(activeIndex);\n    } else {\n      realIndex = activeIndex;\n    }\n  } else if (gridEnabled) {\n    const firstSlideInColumn = swiper.slides.find(slideEl => slideEl.column === activeIndex);\n    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);\n    if (Number.isNaN(activeSlideIndex)) {\n      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);\n    }\n    realIndex = Math.floor(activeSlideIndex / params.grid.rows);\n  } else if (swiper.slides[activeIndex]) {\n    const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');\n    if (slideIndex) {\n      realIndex = parseInt(slideIndex, 10);\n    } else {\n      realIndex = activeIndex;\n    }\n  } else {\n    realIndex = activeIndex;\n  }\n  Object.assign(swiper, {\n    previousSnapIndex,\n    snapIndex,\n    previousRealIndex,\n    realIndex,\n    previousIndex,\n    activeIndex\n  });\n  if (swiper.initialized) {\n    preload(swiper);\n  }\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    if (previousRealIndex !== realIndex) {\n      swiper.emit('realIndexChange');\n    }\n    swiper.emit('slideChange');\n  }\n}\n\nfunction updateClickedSlide(el, path) {\n  const swiper = this;\n  const params = swiper.params;\n  let slide = el.closest(`.${params.slideClass}, swiper-slide`);\n  if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {\n    [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {\n      if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {\n        slide = pathEl;\n      }\n    });\n  }\n  let slideFound = false;\n  let slideIndex;\n  if (slide) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) {\n        slideFound = true;\n        slideIndex = i;\n        break;\n      }\n    }\n  }\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = slideIndex;\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n}\n\nvar update = {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide\n};\n\nfunction getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {\n  const swiper = this;\n  const {\n    params,\n    rtlTranslate: rtl,\n    translate,\n    wrapperEl\n  } = swiper;\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n  if (params.cssMode) {\n    return translate;\n  }\n  let currentTranslate = getTranslate(wrapperEl, axis);\n  currentTranslate += swiper.cssOverflowAdjustment();\n  if (rtl) currentTranslate = -currentTranslate;\n  return currentTranslate || 0;\n}\n\nfunction setTranslate(translate, byController) {\n  const swiper = this;\n  const {\n    rtlTranslate: rtl,\n    params,\n    wrapperEl,\n    progress\n  } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    if (swiper.isHorizontal()) {\n      x -= swiper.cssOverflowAdjustment();\n    } else {\n      y -= swiper.cssOverflowAdjustment();\n    }\n    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n  }\n\n  // Check if we need to update progress\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n  swiper.emit('setTranslate', swiper.translate, byController);\n}\n\nfunction minTranslate() {\n  return -this.snapGrid[0];\n}\n\nfunction maxTranslate() {\n  return -this.snapGrid[this.snapGrid.length - 1];\n}\n\nfunction translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {\n  const swiper = this;\n  const {\n    params,\n    wrapperEl\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n  const minTranslate = swiper.minTranslate();\n  const maxTranslate = swiper.maxTranslate();\n  let newTranslate;\n  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;\n\n  // Update progress\n  swiper.updateProgress(newTranslate);\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: -newTranslate,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: -newTranslate,\n        behavior: 'smooth'\n      });\n    }\n    return true;\n  }\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionEnd');\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionStart');\n    }\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n          swiper.animating = false;\n          if (runCallbacks) {\n            swiper.emit('transitionEnd');\n          }\n        };\n      }\n      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n    }\n  }\n  return true;\n}\n\nvar translate = {\n  getTranslate: getSwiperTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n  translateTo\n};\n\nfunction setTransition(duration, byController) {\n  const swiper = this;\n  if (!swiper.params.cssMode) {\n    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n    swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';\n  }\n  swiper.emit('setTransition', duration, byController);\n}\n\nfunction transitionEmit({\n  swiper,\n  runCallbacks,\n  direction,\n  step\n}) {\n  const {\n    activeIndex,\n    previousIndex\n  } = swiper;\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';\n  }\n  swiper.emit(`transition${step}`);\n  if (runCallbacks && dir === 'reset') {\n    swiper.emit(`slideResetTransition${step}`);\n  } else if (runCallbacks && activeIndex !== previousIndex) {\n    swiper.emit(`slideChangeTransition${step}`);\n    if (dir === 'next') {\n      swiper.emit(`slideNextTransition${step}`);\n    } else {\n      swiper.emit(`slidePrevTransition${step}`);\n    }\n  }\n}\n\nfunction transitionStart(runCallbacks = true, direction) {\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  if (params.cssMode) return;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: 'Start'\n  });\n}\n\nfunction transitionEnd(runCallbacks = true, direction) {\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  swiper.animating = false;\n  if (params.cssMode) return;\n  swiper.setTransition(0);\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: 'End'\n  });\n}\n\nvar transition = {\n  setTransition,\n  transitionStart,\n  transitionEnd\n};\n\nfunction slideTo(index = 0, speed, runCallbacks = true, internal, initial) {\n  if (typeof index === 'string') {\n    index = parseInt(index, 10);\n  }\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled\n  } = swiper;\n  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  const translate = -snapGrid[snapIndex];\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) {\n        return false;\n      }\n    }\n  }\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  // Update progress\n  swiper.updateProgress(translate);\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';\n\n  // initial virtual\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  const isInitialVirtual = isVirtual && initial;\n  // Update Index\n  if (!isInitialVirtual && (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate)) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate : -translate;\n    if (speed === 0) {\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n        swiper._cssModeVirtualInitialSet = true;\n        requestAnimationFrame(() => {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      }\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._immediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: t,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: t,\n        behavior: 'smooth'\n      });\n    }\n    return true;\n  }\n  const browser = getBrowser();\n  const isSafari = browser.isSafari;\n  if (isVirtual && !initial && isSafari && swiper.isElement) {\n    swiper.virtual.update(false, false, slideIndex);\n  }\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n  }\n  return true;\n}\n\nfunction slideToLoop(index = 0, speed, runCallbacks = true, internal) {\n  if (typeof index === 'string') {\n    const indexAsNumber = parseInt(index, 10);\n    index = indexAsNumber;\n  }\n  const swiper = this;\n  if (swiper.destroyed) return;\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;\n  let newIndex = index;\n  if (swiper.params.loop) {\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      // eslint-disable-next-line\n      newIndex = newIndex + swiper.virtual.slidesBefore;\n    } else {\n      let targetSlideIndex;\n      if (gridEnabled) {\n        const slideIndex = newIndex * swiper.params.grid.rows;\n        targetSlideIndex = swiper.slides.find(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex).column;\n      } else {\n        targetSlideIndex = swiper.getSlideIndexByData(newIndex);\n      }\n      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;\n      const {\n        centeredSlides,\n        slidesOffsetBefore,\n        slidesOffsetAfter\n      } = swiper.params;\n      const bothDirections = centeredSlides || !!slidesOffsetBefore || !!slidesOffsetAfter;\n      let slidesPerView = swiper.params.slidesPerView;\n      if (slidesPerView === 'auto') {\n        slidesPerView = swiper.slidesPerViewDynamic();\n      } else {\n        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));\n        if (bothDirections && slidesPerView % 2 === 0) {\n          slidesPerView = slidesPerView + 1;\n        }\n      }\n      let needLoopFix = cols - targetSlideIndex < slidesPerView;\n      if (bothDirections) {\n        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);\n      }\n      if (internal && bothDirections && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {\n        needLoopFix = false;\n      }\n      if (needLoopFix) {\n        const direction = bothDirections ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';\n        swiper.loopFix({\n          direction,\n          slideTo: true,\n          activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,\n          slideRealIndex: direction === 'next' ? swiper.realIndex : undefined\n        });\n      }\n      if (gridEnabled) {\n        const slideIndex = newIndex * swiper.params.grid.rows;\n        newIndex = swiper.slides.find(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex).column;\n      } else {\n        newIndex = swiper.getSlideIndexByData(newIndex);\n      }\n    }\n  }\n  requestAnimationFrame(() => {\n    swiper.slideTo(newIndex, speed, runCallbacks, internal);\n  });\n  return swiper;\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideNext(speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const {\n    enabled,\n    params,\n    animating\n  } = swiper;\n  if (!enabled || swiper.destroyed) return swiper;\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  let perGroup = params.slidesPerGroup;\n  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n  }\n  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding) return false;\n    swiper.loopFix({\n      direction: 'next'\n    });\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {\n      requestAnimationFrame(() => {\n        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n      });\n      return true;\n    }\n  }\n  if (params.rewind && swiper.isEnd) {\n    return swiper.slideTo(0, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slidePrev(speed, runCallbacks = true, internal) {\n  const swiper = this;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    rtlTranslate,\n    enabled,\n    animating\n  } = swiper;\n  if (!enabled || swiper.destroyed) return swiper;\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding) return false;\n    swiper.loopFix({\n      direction: 'prev'\n    });\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n  function normalize(val) {\n    if (val < 0) return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate);\n  const normalizedSnapGrid = snapGrid.map(val => normalize(val));\n  const isFreeMode = params.freeMode && params.freeMode.enabled;\n  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  if (typeof prevSnap === 'undefined' && (params.cssMode || isFreeMode)) {\n    let prevSnapIndex;\n    snapGrid.forEach((snap, snapIndex) => {\n      if (normalizedTranslate >= snap) {\n        // prevSnap = snap;\n        prevSnapIndex = snapIndex;\n      }\n    });\n    if (typeof prevSnapIndex !== 'undefined') {\n      prevSnap = isFreeMode ? snapGrid[prevSnapIndex] : snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n    }\n  }\n  let prevIndex = 0;\n  if (typeof prevSnap !== 'undefined') {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n      prevIndex = Math.max(prevIndex, 0);\n    }\n  }\n  if (params.rewind && swiper.isBeginning) {\n    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {\n    requestAnimationFrame(() => {\n      swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n    });\n    return true;\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideReset(speed, runCallbacks = true, internal) {\n  const swiper = this;\n  if (swiper.destroyed) return;\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideToClosest(speed, runCallbacks = true, internal, threshold = 0.5) {\n  const swiper = this;\n  if (swiper.destroyed) return;\n  if (typeof speed === 'undefined') {\n    speed = swiper.params.speed;\n  }\n  let index = swiper.activeIndex;\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  if (translate >= swiper.snapGrid[snapIndex]) {\n    // The current translate is on or after the current snap index, so the choice\n    // is between the current index and the one after it.\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    // The current translate is before the current snap index, so the choice\n    // is between the current index and the one before it.\n    const prevSnap = swiper.snapGrid[snapIndex - 1];\n    const currentSnap = swiper.snapGrid[snapIndex];\n    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\n\nfunction slideToClickedSlide() {\n  const swiper = this;\n  if (swiper.destroyed) return;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.getSlideIndexWhenGrid(swiper.clickedIndex);\n  let realIndex;\n  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n  const isGrid = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;\n  if (params.loop) {\n    if (swiper.animating) return;\n    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n    if (params.centeredSlides) {\n      swiper.slideToLoop(realIndex);\n    } else if (slideToIndex > (isGrid ? (swiper.slides.length - slidesPerView) / 2 - (swiper.params.grid.rows - 1) : swiper.slides.length - slidesPerView)) {\n      swiper.loopFix();\n      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n      nextTick(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\n\nvar slide = {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide\n};\n\nfunction loopCreate(slideRealIndex, initial) {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n  const initSlides = () => {\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    slides.forEach((el, index) => {\n      el.setAttribute('data-swiper-slide-index', index);\n    });\n  };\n  const clearBlankSlides = () => {\n    const slides = elementChildren(slidesEl, `.${params.slideBlankClass}`);\n    slides.forEach(el => {\n      el.remove();\n    });\n    if (slides.length > 0) {\n      swiper.recalcSlides();\n      swiper.updateSlides();\n    }\n  };\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n  if (params.loopAddBlankSlides && (params.slidesPerGroup > 1 || gridEnabled)) {\n    clearBlankSlides();\n  }\n  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);\n  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;\n  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;\n  const addBlankSlides = amountOfSlides => {\n    for (let i = 0; i < amountOfSlides; i += 1) {\n      const slideEl = swiper.isElement ? createElement('swiper-slide', [params.slideBlankClass]) : createElement('div', [params.slideClass, params.slideBlankClass]);\n      swiper.slidesEl.append(slideEl);\n    }\n  };\n  if (shouldFillGroup) {\n    if (params.loopAddBlankSlides) {\n      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;\n      addBlankSlides(slidesToAdd);\n      swiper.recalcSlides();\n      swiper.updateSlides();\n    } else {\n      showWarning('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');\n    }\n    initSlides();\n  } else if (shouldFillGrid) {\n    if (params.loopAddBlankSlides) {\n      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;\n      addBlankSlides(slidesToAdd);\n      swiper.recalcSlides();\n      swiper.updateSlides();\n    } else {\n      showWarning('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');\n    }\n    initSlides();\n  } else {\n    initSlides();\n  }\n  const bothDirections = params.centeredSlides || !!params.slidesOffsetBefore || !!params.slidesOffsetAfter;\n  swiper.loopFix({\n    slideRealIndex,\n    direction: bothDirections ? undefined : 'next',\n    initial\n  });\n}\n\nfunction loopFix({\n  slideRealIndex,\n  slideTo = true,\n  direction,\n  setTranslate,\n  activeSlideIndex,\n  initial,\n  byController,\n  byMousewheel\n} = {}) {\n  const swiper = this;\n  if (!swiper.params.loop) return;\n  swiper.emit('beforeLoopFix');\n  const {\n    slides,\n    allowSlidePrev,\n    allowSlideNext,\n    slidesEl,\n    params\n  } = swiper;\n  const {\n    centeredSlides,\n    slidesOffsetBefore,\n    slidesOffsetAfter,\n    initialSlide\n  } = params;\n  const bothDirections = centeredSlides || !!slidesOffsetBefore || !!slidesOffsetAfter;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n  if (swiper.virtual && params.virtual.enabled) {\n    if (slideTo) {\n      if (!bothDirections && swiper.snapIndex === 0) {\n        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n      } else if (bothDirections && swiper.snapIndex < params.slidesPerView) {\n        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    swiper.emit('loopFix');\n    return;\n  }\n  let slidesPerView = params.slidesPerView;\n  if (slidesPerView === 'auto') {\n    slidesPerView = swiper.slidesPerViewDynamic();\n  } else {\n    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));\n    if (bothDirections && slidesPerView % 2 === 0) {\n      slidesPerView = slidesPerView + 1;\n    }\n  }\n  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;\n  let loopedSlides = bothDirections ? Math.max(slidesPerGroup, Math.ceil(slidesPerView / 2)) : slidesPerGroup;\n  if (loopedSlides % slidesPerGroup !== 0) {\n    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;\n  }\n  loopedSlides += params.loopAdditionalSlides;\n  swiper.loopedSlides = loopedSlides;\n  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;\n  if (slides.length < slidesPerView + loopedSlides || swiper.params.effect === 'cards' && slides.length < slidesPerView + loopedSlides * 2) {\n    showWarning('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');\n  } else if (gridEnabled && params.grid.fill === 'row') {\n    showWarning('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');\n  }\n  const prependSlidesIndexes = [];\n  const appendSlidesIndexes = [];\n  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;\n  const isInitialOverflow = initial && cols - initialSlide < slidesPerView && !bothDirections;\n  let activeIndex = isInitialOverflow ? initialSlide : swiper.activeIndex;\n  if (typeof activeSlideIndex === 'undefined') {\n    activeSlideIndex = swiper.getSlideIndex(slides.find(el => el.classList.contains(params.slideActiveClass)));\n  } else {\n    activeIndex = activeSlideIndex;\n  }\n  const isNext = direction === 'next' || !direction;\n  const isPrev = direction === 'prev' || !direction;\n  let slidesPrepended = 0;\n  let slidesAppended = 0;\n  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;\n  const activeColIndexWithShift = activeColIndex + (bothDirections && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);\n  // prepend last slides before start\n  if (activeColIndexWithShift < loopedSlides) {\n    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);\n    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {\n      const index = i - Math.floor(i / cols) * cols;\n      if (gridEnabled) {\n        const colIndexToPrepend = cols - index - 1;\n        for (let i = slides.length - 1; i >= 0; i -= 1) {\n          if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);\n        }\n        // slides.forEach((slide, slideIndex) => {\n        //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);\n        // });\n      } else {\n        prependSlidesIndexes.push(cols - index - 1);\n      }\n    }\n  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {\n    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);\n    if (isInitialOverflow) {\n      slidesAppended = Math.max(slidesAppended, slidesPerView - cols + initialSlide + 1);\n    }\n    for (let i = 0; i < slidesAppended; i += 1) {\n      const index = i - Math.floor(i / cols) * cols;\n      if (gridEnabled) {\n        slides.forEach((slide, slideIndex) => {\n          if (slide.column === index) appendSlidesIndexes.push(slideIndex);\n        });\n      } else {\n        appendSlidesIndexes.push(index);\n      }\n    }\n  }\n  swiper.__preventObserver__ = true;\n  requestAnimationFrame(() => {\n    swiper.__preventObserver__ = false;\n  });\n  if (swiper.params.effect === 'cards' && slides.length < slidesPerView + loopedSlides * 2) {\n    if (appendSlidesIndexes.includes(activeSlideIndex)) {\n      appendSlidesIndexes.splice(appendSlidesIndexes.indexOf(activeSlideIndex), 1);\n    }\n    if (prependSlidesIndexes.includes(activeSlideIndex)) {\n      prependSlidesIndexes.splice(prependSlidesIndexes.indexOf(activeSlideIndex), 1);\n    }\n  }\n  if (isPrev) {\n    prependSlidesIndexes.forEach(index => {\n      slides[index].swiperLoopMoveDOM = true;\n      slidesEl.prepend(slides[index]);\n      slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n  if (isNext) {\n    appendSlidesIndexes.forEach(index => {\n      slides[index].swiperLoopMoveDOM = true;\n      slidesEl.append(slides[index]);\n      slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n  swiper.recalcSlides();\n  if (params.slidesPerView === 'auto') {\n    swiper.updateSlides();\n  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {\n    swiper.slides.forEach((slide, slideIndex) => {\n      swiper.grid.updateSlide(slideIndex, slide, swiper.slides);\n    });\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (slideTo) {\n    if (prependSlidesIndexes.length > 0 && isPrev) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);\n          if (setTranslate) {\n            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n          }\n        }\n      } else {\n        if (setTranslate) {\n          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;\n          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);\n          swiper.touchEventsData.currentTranslate = swiper.translate;\n        }\n      }\n    } else if (appendSlidesIndexes.length > 0 && isNext) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n          if (setTranslate) {\n            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;\n            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;\n          }\n        }\n      } else {\n        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;\n        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);\n      }\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.controller && swiper.controller.control && !byController) {\n    const loopParams = {\n      slideRealIndex,\n      direction,\n      setTranslate,\n      activeSlideIndex,\n      byController: true\n    };\n    if (Array.isArray(swiper.controller.control)) {\n      swiper.controller.control.forEach(c => {\n        if (!c.destroyed && c.params.loop) c.loopFix({\n          ...loopParams,\n          slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false\n        });\n      });\n    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n      swiper.controller.control.loopFix({\n        ...loopParams,\n        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false\n      });\n    }\n  }\n  swiper.emit('loopFix');\n}\n\nfunction loopDestroy() {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (!params.loop || !slidesEl || swiper.virtual && swiper.params.virtual.enabled) return;\n  swiper.recalcSlides();\n  const newSlidesOrder = [];\n  swiper.slides.forEach(slideEl => {\n    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;\n    newSlidesOrder[index] = slideEl;\n  });\n  swiper.slides.forEach(slideEl => {\n    slideEl.removeAttribute('data-swiper-slide-index');\n  });\n  newSlidesOrder.forEach(slideEl => {\n    slidesEl.append(slideEl);\n  });\n  swiper.recalcSlides();\n  swiper.slideTo(swiper.realIndex, 0);\n}\n\nvar loop = {\n  loopCreate,\n  loopFix,\n  loopDestroy\n};\n\nfunction setGrabCursor(moving) {\n  const swiper = this;\n  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\n\nfunction unsetGrabCursor() {\n  const swiper = this;\n  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n    return;\n  }\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\n\nvar grabCursor = {\n  setGrabCursor,\n  unsetGrabCursor\n};\n\n// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\nfunction closestElement(selector, base = this) {\n  function __closestFrom(el) {\n    if (!el || el === getDocument() || el === getWindow()) return null;\n    if (el.assignedSlot) el = el.assignedSlot;\n    const found = el.closest(selector);\n    if (!found && !el.getRootNode) {\n      return null;\n    }\n    return found || __closestFrom(el.getRootNode().host);\n  }\n  return __closestFrom(base);\n}\nfunction preventEdgeSwipe(swiper, event, startX) {\n  const window = getWindow();\n  const {\n    params\n  } = swiper;\n  const edgeSwipeDetection = params.edgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold;\n  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n    if (edgeSwipeDetection === 'prevent') {\n      event.preventDefault();\n      return true;\n    }\n    return false;\n  }\n  return true;\n}\nfunction onTouchStart(event) {\n  const swiper = this;\n  const document = getDocument();\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  const data = swiper.touchEventsData;\n  if (e.type === 'pointerdown') {\n    if (data.pointerId !== null && data.pointerId !== e.pointerId) {\n      return;\n    }\n    data.pointerId = e.pointerId;\n  } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {\n    data.touchId = e.targetTouches[0].identifier;\n  }\n  if (e.type === 'touchstart') {\n    // don't proceed touch event\n    preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);\n    return;\n  }\n  const {\n    params,\n    touches,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && e.pointerType === 'mouse') return;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  if (!swiper.animating && params.cssMode && params.loop) {\n    swiper.loopFix();\n  }\n  let targetEl = e.target;\n  if (params.touchEventsTarget === 'wrapper') {\n    if (!elementIsChildOf(targetEl, swiper.wrapperEl)) return;\n  }\n  if ('which' in e && e.which === 3) return;\n  if ('button' in e && e.button > 0) return;\n  if (data.isTouched && data.isMoved) return;\n\n  // change target el for shadow root component\n  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n  // eslint-disable-next-line\n  const eventPath = e.composedPath ? e.composedPath() : e.path;\n  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n    targetEl = eventPath[0];\n  }\n  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n  const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n  // use closestElement for shadow root element to get the actual closest for nested shadow root element\n  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n    swiper.allowClick = true;\n    return;\n  }\n  if (params.swipeHandler) {\n    if (!targetEl.closest(params.swipeHandler)) return;\n  }\n  touches.currentX = e.pageX;\n  touches.currentY = e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n\n  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n  if (!preventEdgeSwipe(swiper, e, startX)) {\n    return;\n  }\n  Object.assign(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined\n  });\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = now();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) data.allowThresholdMove = false;\n  let preventDefault = true;\n  if (targetEl.matches(data.focusableElements)) {\n    preventDefault = false;\n    if (targetEl.nodeName === 'SELECT') {\n      data.isTouched = false;\n    }\n  }\n  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl && (e.pointerType === 'mouse' || e.pointerType !== 'mouse' && !targetEl.matches(data.focusableElements))) {\n    document.activeElement.blur();\n  }\n  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n    e.preventDefault();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n    swiper.freeMode.onTouchStart();\n  }\n  swiper.emit('touchStart', e);\n}\n\nfunction onTouchMove(event) {\n  const document = getDocument();\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (e.type === 'pointermove') {\n    if (data.touchId !== null) return; // return from pointer if we use touch\n    const id = e.pointerId;\n    if (id !== data.pointerId) return;\n  }\n  let targetTouch;\n  if (e.type === 'touchmove') {\n    targetTouch = [...e.changedTouches].find(t => t.identifier === data.touchId);\n    if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n  } else {\n    targetTouch = e;\n  }\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    return;\n  }\n  const pageX = targetTouch.pageX;\n  const pageY = targetTouch.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    if (!e.target.matches(data.focusableElements)) {\n      swiper.allowClick = false;\n    }\n    if (data.isTouched) {\n      Object.assign(touches, {\n        startX: pageX,\n        startY: pageY,\n        currentX: pageX,\n        currentY: pageY\n      });\n      data.touchStartTime = now();\n    }\n    return;\n  }\n  if (params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (rtl && (pageX > touches.startX && -swiper.translate <= swiper.maxTranslate() || pageX < touches.startX && -swiper.translate >= swiper.minTranslate())) {\n      return;\n    } else if (!rtl && (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate())) {\n      return;\n    }\n  }\n  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== e.target && e.pointerType !== 'mouse') {\n    document.activeElement.blur();\n  }\n  if (document.activeElement) {\n    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n  touches.previousX = touches.currentX;\n  touches.previousY = touches.currentY;\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n  if (typeof data.isScrolling === 'undefined') {\n    let touchAngle;\n    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if (diffX * diffX + diffY * diffY >= 25) {\n        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n  if (typeof data.startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n  if (params.oneWayMovement) {\n    diff = Math.abs(diff) * (rtl ? 1 : -1);\n    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n  }\n  touches.diff = diff;\n  diff *= params.touchRatio;\n  if (rtl) {\n    diff = -diff;\n    touchesDiff = -touchesDiff;\n  }\n  const prevTouchesDirection = swiper.touchesDirection;\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n  const isLoop = swiper.params.loop && !params.cssMode;\n  const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;\n  if (!data.isMoved) {\n    if (isLoop && allowLoopFix) {\n      swiper.loopFix({\n        direction: swiper.swipeDirection\n      });\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      const evt = new window.CustomEvent('transitionend', {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          bySwiperTouchMove: true\n        }\n      });\n      swiper.wrapperEl.dispatchEvent(evt);\n    }\n    data.allowMomentumBounce = false;\n    // Grab Cursor\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit('sliderFirstMove', e);\n  }\n  let loopFixed;\n  new Date().getTime();\n  if (params._loopSwapReset !== false && data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {\n    Object.assign(touches, {\n      startX: pageX,\n      startY: pageY,\n      currentX: pageX,\n      currentY: pageY,\n      startTranslate: data.currentTranslate\n    });\n    data.loopSwapReset = true;\n    data.startTranslate = data.currentTranslate;\n    return;\n  }\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n  data.currentTranslate = diff + data.startTranslate;\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if (diff > 0) {\n    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {\n      swiper.loopFix({\n        direction: 'prev',\n        setTranslate: true,\n        activeSlideIndex: 0\n      });\n    }\n    if (data.currentTranslate > swiper.minTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n      }\n    }\n  } else if (diff < 0) {\n    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {\n      swiper.loopFix({\n        direction: 'next',\n        setTranslate: true,\n        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n      });\n    }\n    if (data.currentTranslate < swiper.maxTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n      }\n    }\n  }\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n\n  // Directions locks\n  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n  // Threshold\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n  if (!params.followFinger || params.cssMode) return;\n\n  // Update active index in free mode\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n    swiper.freeMode.onTouchMove();\n  }\n  // Update progress\n  swiper.updateProgress(data.currentTranslate);\n  // Update translate\n  swiper.setTranslate(data.currentTranslate);\n}\n\nfunction onTouchEnd(event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  let targetTouch;\n  const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';\n  if (!isTouchEvent) {\n    if (data.touchId !== null) return; // return from pointer if we use touch\n    if (e.pointerId !== data.pointerId) return;\n    targetTouch = e;\n  } else {\n    targetTouch = [...e.changedTouches].find(t => t.identifier === data.touchId);\n    if (!targetTouch || targetTouch.identifier !== data.touchId) return;\n  }\n  if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {\n    const proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);\n    if (!proceed) {\n      return;\n    }\n  }\n  data.pointerId = null;\n  data.touchId = null;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    slidesGrid,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && e.pointerType === 'mouse') return;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  // Return Grab Cursor\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    const pathTree = e.path || e.composedPath && e.composedPath();\n    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);\n    swiper.emit('tap click', e);\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n  data.lastClickTime = now();\n  nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n  if (params.cssMode) {\n    return;\n  }\n  if (params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({\n      currentPos\n    });\n    return;\n  }\n\n  // Find current slide\n  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (swipeToLast || currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  }\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n\nfunction onResize() {\n  const swiper = this;\n  const {\n    params,\n    el\n  } = swiper;\n  if (el && el.offsetWidth === 0) return;\n\n  // Breakpoints\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n\n  // Save locks\n  const {\n    allowSlideNext,\n    allowSlidePrev,\n    snapGrid\n  } = swiper;\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n  // Disable locks on resize\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n  swiper.updateSize();\n  swiper.updateSlides();\n  swiper.updateSlidesClasses();\n  const isVirtualLoop = isVirtual && params.loop;\n  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    if (swiper.params.loop && !isVirtual) {\n      swiper.slideToLoop(swiper.realIndex, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n  }\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    clearTimeout(swiper.autoplay.resizeTimeout);\n    swiper.autoplay.resizeTimeout = setTimeout(() => {\n      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        swiper.autoplay.resume();\n      }\n    }, 500);\n  }\n  // Return locks after resize\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\n\nfunction onClick(e) {\n  const swiper = this;\n  if (!swiper.enabled) return;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\n\nfunction onScroll() {\n  const swiper = this;\n  const {\n    wrapperEl,\n    rtlTranslate,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  swiper.previousTranslate = swiper.translate;\n  if (swiper.isHorizontal()) {\n    swiper.translate = -wrapperEl.scrollLeft;\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  }\n  // eslint-disable-next-line\n  if (swiper.translate === 0) swiper.translate = 0;\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n  swiper.emit('setTranslate', swiper.translate, false);\n}\n\nfunction onLoad(e) {\n  const swiper = this;\n  processLazyPreloader(swiper, e.target);\n  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {\n    return;\n  }\n  swiper.update();\n}\n\nfunction onDocumentTouchStart() {\n  const swiper = this;\n  if (swiper.documentTouchHandlerProceeded) return;\n  swiper.documentTouchHandlerProceeded = true;\n  if (swiper.params.touchReleaseOnEdges) {\n    swiper.el.style.touchAction = 'auto';\n  }\n}\n\nconst events = (swiper, method) => {\n  const document = getDocument();\n  const {\n    params,\n    el,\n    wrapperEl,\n    device\n  } = swiper;\n  const capture = !!params.nested;\n  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n  const swiperMethod = method;\n  if (!el || typeof el === 'string') return;\n\n  // Touch Events\n  document[domMethod]('touchstart', swiper.onDocumentTouchStart, {\n    passive: false,\n    capture\n  });\n  el[domMethod]('touchstart', swiper.onTouchStart, {\n    passive: false\n  });\n  el[domMethod]('pointerdown', swiper.onTouchStart, {\n    passive: false\n  });\n  document[domMethod]('touchmove', swiper.onTouchMove, {\n    passive: false,\n    capture\n  });\n  document[domMethod]('pointermove', swiper.onTouchMove, {\n    passive: false,\n    capture\n  });\n  document[domMethod]('touchend', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointerup', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointercancel', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('touchcancel', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointerout', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointerleave', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('contextmenu', swiper.onTouchEnd, {\n    passive: true\n  });\n\n  // Prevent Links Clicks\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el[domMethod]('click', swiper.onClick, true);\n  }\n  if (params.cssMode) {\n    wrapperEl[domMethod]('scroll', swiper.onScroll);\n  }\n\n  // Resize handler\n  if (params.updateOnWindowResize) {\n    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\n  } else {\n    swiper[swiperMethod]('observerUpdate', onResize, true);\n  }\n\n  // Images loader\n  el[domMethod]('load', swiper.onLoad, {\n    capture: true\n  });\n};\nfunction attachEvents() {\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  swiper.onTouchStart = onTouchStart.bind(swiper);\n  swiper.onTouchMove = onTouchMove.bind(swiper);\n  swiper.onTouchEnd = onTouchEnd.bind(swiper);\n  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);\n  if (params.cssMode) {\n    swiper.onScroll = onScroll.bind(swiper);\n  }\n  swiper.onClick = onClick.bind(swiper);\n  swiper.onLoad = onLoad.bind(swiper);\n  events(swiper, 'on');\n}\nfunction detachEvents() {\n  const swiper = this;\n  events(swiper, 'off');\n}\nvar events$1 = {\n  attachEvents,\n  detachEvents\n};\n\nconst isGridEnabled = (swiper, params) => {\n  return swiper.grid && params.grid && params.grid.rows > 1;\n};\nfunction setBreakpoint() {\n  const swiper = this;\n  const {\n    realIndex,\n    initialized,\n    params,\n    el\n  } = swiper;\n  const breakpoints = params.breakpoints;\n  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n  const document = getDocument();\n\n  // Get breakpoint for window/container width and update parameters\n  const breakpointsBase = params.breakpointsBase === 'window' || !params.breakpointsBase ? params.breakpointsBase : 'container';\n  const breakpointContainer = ['window', 'container'].includes(params.breakpointsBase) || !params.breakpointsBase ? swiper.el : document.querySelector(params.breakpointsBase);\n  const breakpoint = swiper.getBreakpoint(breakpoints, breakpointsBase, breakpointContainer);\n  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n  const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n  const wasMultiRow = isGridEnabled(swiper, params);\n  const isMultiRow = isGridEnabled(swiper, breakpointParams);\n  const wasGrabCursor = swiper.params.grabCursor;\n  const isGrabCursor = breakpointParams.grabCursor;\n  const wasEnabled = params.enabled;\n  if (wasMultiRow && !isMultiRow) {\n    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n    swiper.emitContainerClasses();\n  } else if (!wasMultiRow && isMultiRow) {\n    el.classList.add(`${params.containerModifierClass}grid`);\n    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\n      el.classList.add(`${params.containerModifierClass}grid-column`);\n    }\n    swiper.emitContainerClasses();\n  }\n  if (wasGrabCursor && !isGrabCursor) {\n    swiper.unsetGrabCursor();\n  } else if (!wasGrabCursor && isGrabCursor) {\n    swiper.setGrabCursor();\n  }\n\n  // Toggle navigation, pagination, scrollbar\n  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {\n    if (typeof breakpointParams[prop] === 'undefined') return;\n    const wasModuleEnabled = params[prop] && params[prop].enabled;\n    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n    if (wasModuleEnabled && !isModuleEnabled) {\n      swiper[prop].disable();\n    }\n    if (!wasModuleEnabled && isModuleEnabled) {\n      swiper[prop].enable();\n    }\n  });\n  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n  const wasLoop = params.loop;\n  if (directionChanged && initialized) {\n    swiper.changeDirection();\n  }\n  extend(swiper.params, breakpointParams);\n  const isEnabled = swiper.params.enabled;\n  const hasLoop = swiper.params.loop;\n  Object.assign(swiper, {\n    allowTouchMove: swiper.params.allowTouchMove,\n    allowSlideNext: swiper.params.allowSlideNext,\n    allowSlidePrev: swiper.params.allowSlidePrev\n  });\n  if (wasEnabled && !isEnabled) {\n    swiper.disable();\n  } else if (!wasEnabled && isEnabled) {\n    swiper.enable();\n  }\n  swiper.currentBreakpoint = breakpoint;\n  swiper.emit('_beforeBreakpoint', breakpointParams);\n  if (initialized) {\n    if (needsReLoop) {\n      swiper.loopDestroy();\n      swiper.loopCreate(realIndex);\n      swiper.updateSlides();\n    } else if (!wasLoop && hasLoop) {\n      swiper.loopCreate(realIndex);\n      swiper.updateSlides();\n    } else if (wasLoop && !hasLoop) {\n      swiper.loopDestroy();\n    }\n  }\n  swiper.emit('breakpoint', breakpointParams);\n}\n\nfunction getBreakpoint(breakpoints, base = 'window', containerEl) {\n  if (!breakpoints || base === 'container' && !containerEl) return undefined;\n  let breakpoint = false;\n  const window = getWindow();\n  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n  const points = Object.keys(breakpoints).map(point => {\n    if (typeof point === 'string' && point.indexOf('@') === 0) {\n      const minRatio = parseFloat(point.substr(1));\n      const value = currentHeight * minRatio;\n      return {\n        value,\n        point\n      };\n    }\n    return {\n      value: point,\n      point\n    };\n  });\n  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const {\n      point,\n      value\n    } = points[i];\n    if (base === 'window') {\n      if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n        breakpoint = point;\n      }\n    } else if (value <= containerEl.clientWidth) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || 'max';\n}\n\nvar breakpoints = {\n  setBreakpoint,\n  getBreakpoint\n};\n\nfunction prepareClasses(entries, prefix) {\n  const resultClasses = [];\n  entries.forEach(item => {\n    if (typeof item === 'object') {\n      Object.keys(item).forEach(classNames => {\n        if (item[classNames]) {\n          resultClasses.push(prefix + classNames);\n        }\n      });\n    } else if (typeof item === 'string') {\n      resultClasses.push(prefix + item);\n    }\n  });\n  return resultClasses;\n}\nfunction addClasses() {\n  const swiper = this;\n  const {\n    classNames,\n    params,\n    rtl,\n    el,\n    device\n  } = swiper;\n  // prettier-ignore\n  const suffixes = prepareClasses(['initialized', params.direction, {\n    'free-mode': swiper.params.freeMode && params.freeMode.enabled\n  }, {\n    'autoheight': params.autoHeight\n  }, {\n    'rtl': rtl\n  }, {\n    'grid': params.grid && params.grid.rows > 1\n  }, {\n    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\n  }, {\n    'android': device.android\n  }, {\n    'ios': device.ios\n  }, {\n    'css-mode': params.cssMode\n  }, {\n    'centered': params.cssMode && params.centeredSlides\n  }, {\n    'watch-progress': params.watchSlidesProgress\n  }], params.containerModifierClass);\n  classNames.push(...suffixes);\n  el.classList.add(...classNames);\n  swiper.emitContainerClasses();\n}\n\nfunction removeClasses() {\n  const swiper = this;\n  const {\n    el,\n    classNames\n  } = swiper;\n  if (!el || typeof el === 'string') return;\n  el.classList.remove(...classNames);\n  swiper.emitContainerClasses();\n}\n\nvar classes = {\n  addClasses,\n  removeClasses\n};\n\nfunction checkOverflow() {\n  const swiper = this;\n  const {\n    isLocked: wasLocked,\n    params\n  } = swiper;\n  const {\n    slidesOffsetBefore\n  } = params;\n  if (slidesOffsetBefore) {\n    const lastSlideIndex = swiper.slides.length - 1;\n    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n    swiper.isLocked = swiper.size > lastSlideRightEdge;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n  if (params.allowSlideNext === true) {\n    swiper.allowSlideNext = !swiper.isLocked;\n  }\n  if (params.allowSlidePrev === true) {\n    swiper.allowSlidePrev = !swiper.isLocked;\n  }\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n  }\n  if (wasLocked !== swiper.isLocked) {\n    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n  }\n}\nvar checkOverflow$1 = {\n  checkOverflow\n};\n\nvar defaults = {\n  init: true,\n  direction: 'horizontal',\n  oneWayMovement: false,\n  swiperElementNodeName: 'SWIPER-CONTAINER',\n  touchEventsTarget: 'wrapper',\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  resizeObserver: true,\n  nested: false,\n  createElements: false,\n  eventsPrefix: 'swiper',\n  enabled: true,\n  focusableElements: 'input, select, option, textarea, button, video, label',\n  // Overrides\n  width: null,\n  height: null,\n  //\n  preventInteractionOnTransition: false,\n  // ssr\n  userAgent: null,\n  url: null,\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n  // Autoheight\n  autoHeight: false,\n  // Set wrapper width\n  setWrapperSize: false,\n  // Virtual Translate\n  virtualTranslate: false,\n  // Effects\n  effect: 'slide',\n  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n  // Breakpoints\n  breakpoints: undefined,\n  breakpointsBase: 'window',\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  slidesPerGroupAuto: false,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0,\n  // in px\n  slidesOffsetAfter: 0,\n  // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n  snapToSlideEdge: false,\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: true,\n  // Round length\n  roundLengths: false,\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 5,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n  // Progress\n  watchSlidesProgress: false,\n  // Cursor\n  grabCursor: false,\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n  // loop\n  loop: false,\n  loopAddBlankSlides: true,\n  loopAdditionalSlides: 0,\n  loopPreventsSliding: true,\n  // rewind\n  rewind: false,\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null,\n  // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n  noSwipingSelector: null,\n  // Passive Listeners\n  passiveListeners: true,\n  maxBackfaceHiddenSlides: 10,\n  // NS\n  containerModifierClass: 'swiper-',\n  // NEW\n  slideClass: 'swiper-slide',\n  slideBlankClass: 'swiper-slide-blank',\n  slideActiveClass: 'swiper-slide-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideFullyVisibleClass: 'swiper-slide-fully-visible',\n  slideNextClass: 'swiper-slide-next',\n  slidePrevClass: 'swiper-slide-prev',\n  wrapperClass: 'swiper-wrapper',\n  lazyPreloaderClass: 'swiper-lazy-preloader',\n  lazyPreloadPrevNext: 0,\n  // Callbacks\n  runCallbacksOnInit: true,\n  // Internals\n  _emitClasses: false\n};\n\nfunction moduleExtendParams(params, allModulesParams) {\n  return function extendParams(obj = {}) {\n    const moduleParamName = Object.keys(obj)[0];\n    const moduleParams = obj[moduleParamName];\n    if (typeof moduleParams !== 'object' || moduleParams === null) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (params[moduleParamName] === true) {\n      params[moduleParamName] = {\n        enabled: true\n      };\n    }\n    if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {\n      params[moduleParamName].auto = true;\n    }\n    if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {\n      params[moduleParamName].auto = true;\n    }\n    if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n      extend(allModulesParams, obj);\n      return;\n    }\n    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n      params[moduleParamName].enabled = true;\n    }\n    if (!params[moduleParamName]) params[moduleParamName] = {\n      enabled: false\n    };\n    extend(allModulesParams, obj);\n  };\n}\n\n/* eslint no-param-reassign: \"off\" */\nconst prototypes = {\n  eventsEmitter,\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  events: events$1,\n  breakpoints,\n  checkOverflow: checkOverflow$1,\n  classes\n};\nconst extendedDefaults = {};\nclass Swiper {\n  constructor(...args) {\n    let el;\n    let params;\n    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params) params = {};\n    params = extend({}, params);\n    if (el && !params.el) params.el = el;\n    const document = getDocument();\n    if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {\n      const swipers = [];\n      document.querySelectorAll(params.el).forEach(containerEl => {\n        const newParams = extend({}, params, {\n          el: containerEl\n        });\n        swipers.push(new Swiper(newParams));\n      });\n      // eslint-disable-next-line no-constructor-return\n      return swipers;\n    }\n\n    // Swiper Instance\n    const swiper = this;\n    swiper.__swiper__ = true;\n    swiper.support = getSupport();\n    swiper.device = getDevice({\n      userAgent: params.userAgent\n    });\n    swiper.browser = getBrowser();\n    swiper.eventsListeners = {};\n    swiper.eventsAnyListeners = [];\n    swiper.modules = [...swiper.__modules__];\n    if (params.modules && Array.isArray(params.modules)) {\n      swiper.modules.push(...params.modules);\n    }\n    const allModulesParams = {};\n    swiper.modules.forEach(mod => {\n      mod({\n        params,\n        swiper,\n        extendParams: moduleExtendParams(params, allModulesParams),\n        on: swiper.on.bind(swiper),\n        once: swiper.once.bind(swiper),\n        off: swiper.off.bind(swiper),\n        emit: swiper.emit.bind(swiper)\n      });\n    });\n\n    // Extend defaults with modules params\n    const swiperParams = extend({}, defaults, allModulesParams);\n\n    // Extend defaults with passed params\n    swiper.params = extend({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = extend({}, swiper.params);\n    swiper.passedParams = extend({}, params);\n\n    // add event listeners\n    if (swiper.params && swiper.params.on) {\n      Object.keys(swiper.params.on).forEach(eventName => {\n        swiper.on(eventName, swiper.params.on[eventName]);\n      });\n    }\n    if (swiper.params && swiper.params.onAny) {\n      swiper.onAny(swiper.params.onAny);\n    }\n\n    // Extend Swiper\n    Object.assign(swiper, {\n      enabled: swiper.params.enabled,\n      el,\n      // Classes\n      classNames: [],\n      // Slides\n      slides: [],\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n      //\n      isBeginning: true,\n      isEnd: false,\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n      cssOverflowAdjustment() {\n        // Returns 0 unless `translate` is > 2**23\n        // Should be subtracted from css values to prevent overflow\n        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n      },\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n      // Touch Events\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        focusableElements: swiper.params.focusableElements,\n        // Last click time\n        lastClickTime: 0,\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        startMoving: undefined,\n        pointerId: null,\n        touchId: null\n      },\n      // Clicks\n      allowClick: true,\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0\n      },\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0\n    });\n    swiper.emit('_swiper');\n\n    // Init\n    if (swiper.params.init) {\n      swiper.init();\n    }\n\n    // Return app instance\n    // eslint-disable-next-line no-constructor-return\n    return swiper;\n  }\n  getDirectionLabel(property) {\n    if (this.isHorizontal()) {\n      return property;\n    }\n    // prettier-ignore\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom'\n    }[property];\n  }\n  getSlideIndex(slideEl) {\n    const {\n      slidesEl,\n      params\n    } = this;\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    const firstSlideIndex = elementIndex(slides[0]);\n    return elementIndex(slideEl) - firstSlideIndex;\n  }\n  getSlideIndexByData(index) {\n    return this.getSlideIndex(this.slides.find(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index));\n  }\n  getSlideIndexWhenGrid(index) {\n    if (this.grid && this.params.grid && this.params.grid.rows > 1) {\n      if (this.params.grid.fill === 'column') {\n        index = Math.floor(index / this.params.grid.rows);\n      } else if (this.params.grid.fill === 'row') {\n        index = index % Math.ceil(this.slides.length / this.params.grid.rows);\n      }\n    }\n    return index;\n  }\n  recalcSlides() {\n    const swiper = this;\n    const {\n      slidesEl,\n      params\n    } = swiper;\n    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n  }\n  enable() {\n    const swiper = this;\n    if (swiper.enabled) return;\n    swiper.enabled = true;\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n    swiper.emit('enable');\n  }\n  disable() {\n    const swiper = this;\n    if (!swiper.enabled) return;\n    swiper.enabled = false;\n    if (swiper.params.grabCursor) {\n      swiper.unsetGrabCursor();\n    }\n    swiper.emit('disable');\n  }\n  setProgress(progress, speed) {\n    const swiper = this;\n    progress = Math.min(Math.max(progress, 0), 1);\n    const min = swiper.minTranslate();\n    const max = swiper.maxTranslate();\n    const current = (max - min) * progress + min;\n    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  emitContainerClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const cls = swiper.el.className.split(' ').filter(className => {\n      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n    });\n    swiper.emit('_containerClasses', cls.join(' '));\n  }\n  getSlideClasses(slideEl) {\n    const swiper = this;\n    if (swiper.destroyed) return '';\n    return slideEl.className.split(' ').filter(className => {\n      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n    }).join(' ');\n  }\n  emitSlidesClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const updates = [];\n    swiper.slides.forEach(slideEl => {\n      const classNames = swiper.getSlideClasses(slideEl);\n      updates.push({\n        slideEl,\n        classNames\n      });\n      swiper.emit('_slideClass', slideEl, classNames);\n    });\n    swiper.emit('_slideClasses', updates);\n  }\n  slidesPerViewDynamic(view = 'current', exact = false) {\n    const swiper = this;\n    const {\n      params,\n      slides,\n      slidesGrid,\n      slidesSizesGrid,\n      size: swiperSize,\n      activeIndex\n    } = swiper;\n    let spv = 1;\n    if (typeof params.slidesPerView === 'number') return params.slidesPerView;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += Math.ceil(slides[i].swiperSlideSize);\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n    } else {\n      // eslint-disable-next-line\n      if (view === 'current') {\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      } else {\n        // previous\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      }\n    }\n    return spv;\n  }\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed) return;\n    const {\n      snapGrid,\n      params\n    } = swiper;\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      }\n    });\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n    function setTranslate() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n      setTranslate();\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n        translated = swiper.slideTo(slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit('update');\n  }\n  changeDirection(newDirection, needUpdate = true) {\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      // eslint-disable-next-line\n      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n      return swiper;\n    }\n    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n    swiper.emitContainerClasses();\n    swiper.params.direction = newDirection;\n    swiper.slides.forEach(slideEl => {\n      if (newDirection === 'vertical') {\n        slideEl.style.width = '';\n      } else {\n        slideEl.style.height = '';\n      }\n    });\n    swiper.emit('changeDirection');\n    if (needUpdate) swiper.update();\n    return swiper;\n  }\n  changeLanguageDirection(direction) {\n    const swiper = this;\n    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;\n    swiper.rtl = direction === 'rtl';\n    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n    if (swiper.rtl) {\n      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'rtl';\n    } else {\n      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'ltr';\n    }\n    swiper.update();\n  }\n  mount(element) {\n    const swiper = this;\n    if (swiper.mounted) return true;\n\n    // Find el\n    let el = element || swiper.params.el;\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n    if (!el) {\n      return false;\n    }\n    el.swiper = swiper;\n    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {\n      swiper.isElement = true;\n    }\n    const getWrapperSelector = () => {\n      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n    };\n    const getWrapper = () => {\n      if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n        const res = el.shadowRoot.querySelector(getWrapperSelector());\n        // Children needs to return slot items\n        return res;\n      }\n      return elementChildren(el, getWrapperSelector())[0];\n    };\n    // Find Wrapper\n    let wrapperEl = getWrapper();\n    if (!wrapperEl && swiper.params.createElements) {\n      wrapperEl = createElement('div', swiper.params.wrapperClass);\n      el.append(wrapperEl);\n      elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {\n        wrapperEl.append(slideEl);\n      });\n    }\n    Object.assign(swiper, {\n      el,\n      wrapperEl,\n      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,\n      hostEl: swiper.isElement ? el.parentNode.host : el,\n      mounted: true,\n      // RTL\n      rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n      wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'\n    });\n    return true;\n  }\n  init(el) {\n    const swiper = this;\n    if (swiper.initialized) return swiper;\n    const mounted = swiper.mount(el);\n    if (mounted === false) return swiper;\n    swiper.emit('beforeInit');\n\n    // Set breakpoint\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Add Classes\n    swiper.addClasses();\n\n    // Update size\n    swiper.updateSize();\n\n    // Update slides\n    swiper.updateSlides();\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n\n    // Set Grab Cursor\n    if (swiper.params.grabCursor && swiper.enabled) {\n      swiper.setGrabCursor();\n    }\n\n    // Slide To Initial Slide\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n    }\n\n    // Create loop\n    if (swiper.params.loop) {\n      swiper.loopCreate(undefined, true);\n    }\n\n    // Attach events\n    swiper.attachEvents();\n    const lazyElements = [...swiper.el.querySelectorAll('[loading=\"lazy\"]')];\n    if (swiper.isElement) {\n      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading=\"lazy\"]'));\n    }\n    lazyElements.forEach(imageEl => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      } else {\n        imageEl.addEventListener('load', e => {\n          processLazyPreloader(swiper, e.target);\n        });\n      }\n    });\n    preload(swiper);\n\n    // Init Flag\n    swiper.initialized = true;\n    preload(swiper);\n\n    // Emit\n    swiper.emit('init');\n    swiper.emit('afterInit');\n    return swiper;\n  }\n  destroy(deleteInstance = true, cleanStyles = true) {\n    const swiper = this;\n    const {\n      params,\n      el,\n      wrapperEl,\n      slides\n    } = swiper;\n    if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n      return null;\n    }\n    swiper.emit('beforeDestroy');\n\n    // Init Flag\n    swiper.initialized = false;\n\n    // Detach events\n    swiper.detachEvents();\n\n    // Destroy loop\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    // Cleanup styles\n    if (cleanStyles) {\n      swiper.removeClasses();\n      if (el && typeof el !== 'string') {\n        el.removeAttribute('style');\n      }\n      if (wrapperEl) {\n        wrapperEl.removeAttribute('style');\n      }\n      if (slides && slides.length) {\n        slides.forEach(slideEl => {\n          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n          slideEl.removeAttribute('style');\n          slideEl.removeAttribute('data-swiper-slide-index');\n        });\n      }\n    }\n    swiper.emit('destroy');\n\n    // Detach emitter events\n    Object.keys(swiper.eventsListeners).forEach(eventName => {\n      swiper.off(eventName);\n    });\n    if (deleteInstance !== false) {\n      if (swiper.el && typeof swiper.el !== 'string') {\n        swiper.el.swiper = null;\n      }\n      deleteProps(swiper);\n    }\n    swiper.destroyed = true;\n    return null;\n  }\n  static extendDefaults(newDefaults) {\n    extend(extendedDefaults, newDefaults);\n  }\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n  static get defaults() {\n    return defaults;\n  }\n  static installModule(mod) {\n    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n    const modules = Swiper.prototype.__modules__;\n    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n      modules.push(mod);\n    }\n  }\n  static use(module) {\n    if (Array.isArray(module)) {\n      module.forEach(m => Swiper.installModule(m));\n      return Swiper;\n    }\n    Swiper.installModule(module);\n    return Swiper;\n  }\n}\nObject.keys(prototypes).forEach(prototypeGroup => {\n  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {\n    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n  });\n});\nSwiper.use([Resize, Observer]);\n\nexport { Swiper as S, defaults as d };\n","import { observeTimeline } from 'motion-dom';\nimport { scrollInfo } from './track.mjs';\nimport { getTimeline } from './utils/get-timeline.mjs';\n\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll) {\n    return onScroll.length === 2;\n}\nfunction attachToFunction(onScroll, options) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis].progress, info);\n        }, options);\n    }\n    else {\n        return observeTimeline(onScroll, getTimeline(options));\n    }\n}\n\nexport { attachToFunction };\n","import { warnOnce } from 'motion-utils';\nimport { updateScrollInfo } from './info.mjs';\nimport { resolveOffsets } from './offsets/index.mjs';\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(getComputedStyle(container).position !== \"static\", \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\");\n        }\n    }\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info);\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n\nexport { createOnScrollHandler };\n","import { g as getDocument } from '../shared/ssr-window.esm.mjs';\nimport { c as classesToSelector } from '../shared/classes-to-selector.mjs';\nimport { c as createElement, j as elementIndex, m as makeElementsArray, s as setInnerHTML } from '../shared/utils.mjs';\n\nfunction A11y({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    a11y: {\n      enabled: true,\n      notificationClass: 'swiper-notification',\n      prevSlideMessage: 'Previous slide',\n      nextSlideMessage: 'Next slide',\n      firstSlideMessage: 'This is the first slide',\n      lastSlideMessage: 'This is the last slide',\n      paginationBulletMessage: 'Go to slide {{index}}',\n      slideLabelMessage: '{{index}} / {{slidesLength}}',\n      containerMessage: null,\n      containerRoleDescriptionMessage: null,\n      containerRole: null,\n      itemRoleDescriptionMessage: null,\n      slideRole: 'group',\n      id: null,\n      scrollOnFocus: true,\n      wrapperLiveRegion: true\n    }\n  });\n  swiper.a11y = {\n    clicked: false\n  };\n  let liveRegion = null;\n  let preventFocusHandler;\n  let focusTargetSlideEl;\n  let visibilityChangedTimestamp = new Date().getTime();\n  function notify(message) {\n    const notification = liveRegion;\n    if (notification.length === 0) return;\n    setInnerHTML(notification, message);\n  }\n  function getRandomNumber(size = 16) {\n    const randomChar = () => Math.round(16 * Math.random()).toString(16);\n    return 'x'.repeat(size).replace(/x/g, randomChar);\n  }\n  function makeElFocusable(el) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('tabIndex', '0');\n    });\n  }\n  function makeElNotFocusable(el) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('tabIndex', '-1');\n    });\n  }\n  function addElRole(el, role) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('role', role);\n    });\n  }\n  function addElRoleDescription(el, description) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-roledescription', description);\n    });\n  }\n  function addElControls(el, controls) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-controls', controls);\n    });\n  }\n  function addElLabel(el, label) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-label', label);\n    });\n  }\n  function addElId(el, id) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('id', id);\n    });\n  }\n  function addElLive(el, live) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-live', live);\n    });\n  }\n  function disableEl(el) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-disabled', true);\n    });\n  }\n  function enableEl(el) {\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.setAttribute('aria-disabled', false);\n    });\n  }\n  function onEnterOrSpaceKey(e) {\n    if (e.keyCode !== 13 && e.keyCode !== 32) return;\n    const params = swiper.params.a11y;\n    const targetEl = e.target;\n    if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n      if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n    }\n    if (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {\n      const prevEls = makeElementsArray(swiper.navigation.prevEl);\n      const nextEls = makeElementsArray(swiper.navigation.nextEl);\n      if (nextEls.includes(targetEl)) {\n        if (!(swiper.isEnd && !swiper.params.loop)) {\n          swiper.slideNext();\n        }\n        if (swiper.isEnd) {\n          notify(params.lastSlideMessage);\n        } else {\n          notify(params.nextSlideMessage);\n        }\n      }\n      if (prevEls.includes(targetEl)) {\n        if (!(swiper.isBeginning && !swiper.params.loop)) {\n          swiper.slidePrev();\n        }\n        if (swiper.isBeginning) {\n          notify(params.firstSlideMessage);\n        } else {\n          notify(params.prevSlideMessage);\n        }\n      }\n    }\n    if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n      targetEl.click();\n    }\n  }\n  function updateNavigation() {\n    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n    const {\n      nextEl,\n      prevEl\n    } = swiper.navigation;\n    if (prevEl) {\n      if (swiper.isBeginning) {\n        disableEl(prevEl);\n        makeElNotFocusable(prevEl);\n      } else {\n        enableEl(prevEl);\n        makeElFocusable(prevEl);\n      }\n    }\n    if (nextEl) {\n      if (swiper.isEnd) {\n        disableEl(nextEl);\n        makeElNotFocusable(nextEl);\n      } else {\n        enableEl(nextEl);\n        makeElFocusable(nextEl);\n      }\n    }\n  }\n  function hasPagination() {\n    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n  }\n  function hasClickablePagination() {\n    return hasPagination() && swiper.params.pagination.clickable;\n  }\n  function updatePagination() {\n    const params = swiper.params.a11y;\n    if (!hasPagination()) return;\n    swiper.pagination.bullets.forEach(bulletEl => {\n      if (swiper.params.pagination.clickable) {\n        makeElFocusable(bulletEl);\n        if (!swiper.params.pagination.renderBullet) {\n          addElRole(bulletEl, 'button');\n          addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n        }\n      }\n      if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n        bulletEl.setAttribute('aria-current', 'true');\n      } else {\n        bulletEl.removeAttribute('aria-current');\n      }\n    });\n  }\n  const initNavEl = (el, wrapperId, message) => {\n    makeElFocusable(el);\n    if (el.tagName !== 'BUTTON') {\n      addElRole(el, 'button');\n      el.addEventListener('keydown', onEnterOrSpaceKey);\n    }\n    addElLabel(el, message);\n    addElControls(el, wrapperId);\n  };\n  const handlePointerDown = e => {\n    if (focusTargetSlideEl && focusTargetSlideEl !== e.target && !focusTargetSlideEl.contains(e.target)) {\n      preventFocusHandler = true;\n    }\n    swiper.a11y.clicked = true;\n  };\n  const handlePointerUp = () => {\n    preventFocusHandler = false;\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => {\n        if (!swiper.destroyed) {\n          swiper.a11y.clicked = false;\n        }\n      });\n    });\n  };\n  const onVisibilityChange = e => {\n    visibilityChangedTimestamp = new Date().getTime();\n  };\n  const handleFocus = e => {\n    if (swiper.a11y.clicked || !swiper.params.a11y.scrollOnFocus) return;\n    if (new Date().getTime() - visibilityChangedTimestamp < 100) return;\n    const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n    if (!slideEl || !swiper.slides.includes(slideEl)) return;\n    focusTargetSlideEl = slideEl;\n    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n    if (isActive || isVisible) return;\n    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n    if (swiper.isHorizontal()) {\n      swiper.el.scrollLeft = 0;\n    } else {\n      swiper.el.scrollTop = 0;\n    }\n    requestAnimationFrame(() => {\n      if (preventFocusHandler) return;\n      if (swiper.params.loop) {\n        swiper.slideToLoop(swiper.getSlideIndexWhenGrid(parseInt(slideEl.getAttribute('data-swiper-slide-index'))), 0);\n      } else {\n        swiper.slideTo(swiper.getSlideIndexWhenGrid(swiper.slides.indexOf(slideEl)), 0);\n      }\n      preventFocusHandler = false;\n    });\n  };\n  const initSlides = () => {\n    const params = swiper.params.a11y;\n    if (params.itemRoleDescriptionMessage) {\n      addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n    }\n    if (params.slideRole) {\n      addElRole(swiper.slides, params.slideRole);\n    }\n    const slidesLength = swiper.slides.length;\n    if (params.slideLabelMessage) {\n      swiper.slides.forEach((slideEl, index) => {\n        const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;\n        const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n        addElLabel(slideEl, ariaLabelMessage);\n      });\n    }\n  };\n  const init = () => {\n    const params = swiper.params.a11y;\n    swiper.el.append(liveRegion);\n\n    // Container\n    const containerEl = swiper.el;\n    if (params.containerRoleDescriptionMessage) {\n      addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n    }\n    if (params.containerMessage) {\n      addElLabel(containerEl, params.containerMessage);\n    }\n    if (params.containerRole) {\n      addElRole(containerEl, params.containerRole);\n    }\n\n    // Wrapper\n    const wrapperEl = swiper.wrapperEl;\n    const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n    addElId(wrapperEl, wrapperId);\n    if (params.wrapperLiveRegion) {\n      const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n      addElLive(wrapperEl, live);\n    }\n\n    // Slide\n    initSlides();\n\n    // Navigation\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation ? swiper.navigation : {};\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (nextEl) {\n      nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));\n    }\n    if (prevEl) {\n      prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));\n    }\n\n    // Pagination\n    if (hasClickablePagination()) {\n      const paginationEl = makeElementsArray(swiper.pagination.el);\n      paginationEl.forEach(el => {\n        el.addEventListener('keydown', onEnterOrSpaceKey);\n      });\n    }\n\n    // Tab focus\n    const document = getDocument();\n    document.addEventListener('visibilitychange', onVisibilityChange);\n    swiper.el.addEventListener('focus', handleFocus, true);\n    swiper.el.addEventListener('pointerdown', handlePointerDown, true);\n    swiper.el.addEventListener('pointerup', handlePointerUp, true);\n  };\n  function destroy() {\n    if (liveRegion) liveRegion.remove();\n    let {\n      nextEl,\n      prevEl\n    } = swiper.navigation ? swiper.navigation : {};\n    nextEl = makeElementsArray(nextEl);\n    prevEl = makeElementsArray(prevEl);\n    if (nextEl) {\n      nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n    }\n    if (prevEl) {\n      prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n    }\n\n    // Pagination\n    if (hasClickablePagination()) {\n      const paginationEl = makeElementsArray(swiper.pagination.el);\n      paginationEl.forEach(el => {\n        el.removeEventListener('keydown', onEnterOrSpaceKey);\n      });\n    }\n    const document = getDocument();\n    document.removeEventListener('visibilitychange', onVisibilityChange);\n    // Tab focus\n    if (swiper.el && typeof swiper.el !== 'string') {\n      swiper.el.removeEventListener('focus', handleFocus, true);\n      swiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n      swiper.el.removeEventListener('pointerup', handlePointerUp, true);\n    }\n  }\n  on('beforeInit', () => {\n    liveRegion = createElement('span', swiper.params.a11y.notificationClass);\n    liveRegion.setAttribute('aria-live', 'assertive');\n    liveRegion.setAttribute('aria-atomic', 'true');\n  });\n  on('afterInit', () => {\n    if (!swiper.params.a11y.enabled) return;\n    init();\n  });\n  on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n    if (!swiper.params.a11y.enabled) return;\n    initSlides();\n  });\n  on('fromEdge toEdge afterInit lock unlock', () => {\n    if (!swiper.params.a11y.enabled) return;\n    updateNavigation();\n  });\n  on('paginationUpdate', () => {\n    if (!swiper.params.a11y.enabled) return;\n    updatePagination();\n  });\n  on('destroy', () => {\n    if (!swiper.params.a11y.enabled) return;\n    destroy();\n  });\n}\n\nexport { A11y as default };\n","import { cancelFrame, frame } from 'motion-dom';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    const value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    const updateValue = () => value.set(combineValues());\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useIsomorphicLayoutEffect(() => {\n        const scheduleUpdate = () => frame.preRender(updateValue, false, true);\n        const subscriptions = values.map((v) => v.on(\"change\", scheduleUpdate));\n        return () => {\n            subscriptions.forEach((unsubscribe) => unsubscribe());\n            cancelFrame(updateValue);\n        };\n    });\n    return value;\n}\n\nexport { useCombineMotionValues };\n","import { c as classesToSelector } from '../shared/classes-to-selector.mjs';\nimport { c as createElementIfNotDefined } from '../shared/create-element-if-not-defined.mjs';\nimport { m as makeElementsArray, i as elementOuterSize, j as elementIndex, s as setInnerHTML, d as elementParents } from '../shared/utils.mjs';\n\nfunction Pagination({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const pfx = 'swiper-pagination';\n  extendParams({\n    pagination: {\n      el: null,\n      bulletElement: 'span',\n      clickable: false,\n      hideOnClick: false,\n      renderBullet: null,\n      renderProgressbar: null,\n      renderFraction: null,\n      renderCustom: null,\n      progressbarOpposite: false,\n      type: 'bullets',\n      // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n      dynamicBullets: false,\n      dynamicMainBullets: 1,\n      formatFractionCurrent: number => number,\n      formatFractionTotal: number => number,\n      bulletClass: `${pfx}-bullet`,\n      bulletActiveClass: `${pfx}-bullet-active`,\n      modifierClass: `${pfx}-`,\n      currentClass: `${pfx}-current`,\n      totalClass: `${pfx}-total`,\n      hiddenClass: `${pfx}-hidden`,\n      progressbarFillClass: `${pfx}-progressbar-fill`,\n      progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n      clickableClass: `${pfx}-clickable`,\n      lockClass: `${pfx}-lock`,\n      horizontalClass: `${pfx}-horizontal`,\n      verticalClass: `${pfx}-vertical`,\n      paginationDisabledClass: `${pfx}-disabled`\n    }\n  });\n  swiper.pagination = {\n    el: null,\n    bullets: []\n  };\n  let bulletSize;\n  let dynamicBulletIndex = 0;\n  function isPaginationDisabled() {\n    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n  }\n  function setSideBullets(bulletEl, position) {\n    const {\n      bulletActiveClass\n    } = swiper.params.pagination;\n    if (!bulletEl) return;\n    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n    if (bulletEl) {\n      bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n      if (bulletEl) {\n        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n      }\n    }\n  }\n  function getMoveDirection(prevIndex, nextIndex, length) {\n    prevIndex = prevIndex % length;\n    nextIndex = nextIndex % length;\n    if (nextIndex === prevIndex + 1) {\n      return 'next';\n    } else if (nextIndex === prevIndex - 1) {\n      return 'previous';\n    }\n    return;\n  }\n  function onBulletClick(e) {\n    const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n    if (!bulletEl) {\n      return;\n    }\n    e.preventDefault();\n    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n    if (swiper.params.loop) {\n      if (swiper.realIndex === index) return;\n      const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);\n      if (moveDirection === 'next') {\n        swiper.slideNext();\n      } else if (moveDirection === 'previous') {\n        swiper.slidePrev();\n      } else {\n        swiper.slideToLoop(index);\n      }\n    } else {\n      swiper.slideTo(index);\n    }\n  }\n  function update() {\n    // Render || Update Pagination bullets/items\n    const rtl = swiper.rtl;\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    // Current/Total\n    let current;\n    let previousIndex;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n    if (swiper.params.loop) {\n      previousIndex = swiper.previousRealIndex || 0;\n      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n    } else if (typeof swiper.snapIndex !== 'undefined') {\n      current = swiper.snapIndex;\n      previousIndex = swiper.previousSnapIndex;\n    } else {\n      previousIndex = swiper.previousIndex || 0;\n      current = swiper.activeIndex || 0;\n    }\n    // Types\n    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n      const bullets = swiper.pagination.bullets;\n      let firstIndex;\n      let lastIndex;\n      let midIndex;\n      if (params.dynamicBullets) {\n        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n        el.forEach(subEl => {\n          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n        });\n        if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n          dynamicBulletIndex += current - (previousIndex || 0);\n          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n            dynamicBulletIndex = params.dynamicMainBullets - 1;\n          } else if (dynamicBulletIndex < 0) {\n            dynamicBulletIndex = 0;\n          }\n        }\n        firstIndex = Math.max(current - dynamicBulletIndex, 0);\n        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n        midIndex = (lastIndex + firstIndex) / 2;\n      }\n      bullets.forEach(bulletEl => {\n        const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();\n        bulletEl.classList.remove(...classesToRemove);\n      });\n      if (el.length > 1) {\n        bullets.forEach(bullet => {\n          const bulletIndex = elementIndex(bullet);\n          if (bulletIndex === current) {\n            bullet.classList.add(...params.bulletActiveClass.split(' '));\n          } else if (swiper.isElement) {\n            bullet.setAttribute('part', 'bullet');\n          }\n          if (params.dynamicBullets) {\n            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n            }\n            if (bulletIndex === firstIndex) {\n              setSideBullets(bullet, 'prev');\n            }\n            if (bulletIndex === lastIndex) {\n              setSideBullets(bullet, 'next');\n            }\n          }\n        });\n      } else {\n        const bullet = bullets[current];\n        if (bullet) {\n          bullet.classList.add(...params.bulletActiveClass.split(' '));\n        }\n        if (swiper.isElement) {\n          bullets.forEach((bulletEl, bulletIndex) => {\n            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');\n          });\n        }\n        if (params.dynamicBullets) {\n          const firstDisplayedBullet = bullets[firstIndex];\n          const lastDisplayedBullet = bullets[lastIndex];\n          for (let i = firstIndex; i <= lastIndex; i += 1) {\n            if (bullets[i]) {\n              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n            }\n          }\n          setSideBullets(firstDisplayedBullet, 'prev');\n          setSideBullets(lastDisplayedBullet, 'next');\n        }\n      }\n      if (params.dynamicBullets) {\n        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n        const offsetProp = rtl ? 'right' : 'left';\n        bullets.forEach(bullet => {\n          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n        });\n      }\n    }\n    el.forEach((subEl, subElIndex) => {\n      if (params.type === 'fraction') {\n        subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {\n          fractionEl.textContent = params.formatFractionCurrent(current + 1);\n        });\n        subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {\n          totalEl.textContent = params.formatFractionTotal(total);\n        });\n      }\n      if (params.type === 'progressbar') {\n        let progressbarDirection;\n        if (params.progressbarOpposite) {\n          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n        } else {\n          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n        }\n        const scale = (current + 1) / total;\n        let scaleX = 1;\n        let scaleY = 1;\n        if (progressbarDirection === 'horizontal') {\n          scaleX = scale;\n        } else {\n          scaleY = scale;\n        }\n        subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {\n          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n        });\n      }\n      if (params.type === 'custom' && params.renderCustom) {\n        setInnerHTML(subEl, params.renderCustom(swiper, current + 1, total));\n        if (subElIndex === 0) emit('paginationRender', subEl);\n      } else {\n        if (subElIndex === 0) emit('paginationRender', subEl);\n        emit('paginationUpdate', subEl);\n      }\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n      }\n    });\n  }\n  function render() {\n    // Render Container\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;\n    let el = swiper.pagination.el;\n    el = makeElementsArray(el);\n    let paginationHTML = '';\n    if (params.type === 'bullets') {\n      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n        numberOfBullets = slidesLength;\n      }\n      for (let i = 0; i < numberOfBullets; i += 1) {\n        if (params.renderBullet) {\n          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n        } else {\n          // prettier-ignore\n          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : ''} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n        }\n      }\n    }\n    if (params.type === 'fraction') {\n      if (params.renderFraction) {\n        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n      } else {\n        paginationHTML = `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n      }\n    }\n    if (params.type === 'progressbar') {\n      if (params.renderProgressbar) {\n        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n      } else {\n        paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n      }\n    }\n    swiper.pagination.bullets = [];\n    el.forEach(subEl => {\n      if (params.type !== 'custom') {\n        setInnerHTML(subEl, paginationHTML || '');\n      }\n      if (params.type === 'bullets') {\n        swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n      }\n    });\n    if (params.type !== 'custom') {\n      emit('paginationRender', el[0]);\n    }\n  }\n  function init() {\n    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n      el: 'swiper-pagination'\n    });\n    const params = swiper.params.pagination;\n    if (!params.el) return;\n    let el;\n    if (typeof params.el === 'string' && swiper.isElement) {\n      el = swiper.el.querySelector(params.el);\n    }\n    if (!el && typeof params.el === 'string') {\n      el = [...document.querySelectorAll(params.el)];\n    }\n    if (!el) {\n      el = params.el;\n    }\n    if (!el || el.length === 0) return;\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {\n      el = [...swiper.el.querySelectorAll(params.el)];\n      // check if it belongs to another nested Swiper\n      if (el.length > 1) {\n        el = el.find(subEl => {\n          if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n          return true;\n        });\n      }\n    }\n    if (Array.isArray(el) && el.length === 1) el = el[0];\n    Object.assign(swiper.pagination, {\n      el\n    });\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      if (params.type === 'bullets' && params.clickable) {\n        subEl.classList.add(...(params.clickableClass || '').split(' '));\n      }\n      subEl.classList.add(params.modifierClass + params.type);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      if (params.type === 'bullets' && params.dynamicBullets) {\n        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n        dynamicBulletIndex = 0;\n        if (params.dynamicMainBullets < 1) {\n          params.dynamicMainBullets = 1;\n        }\n      }\n      if (params.type === 'progressbar' && params.progressbarOpposite) {\n        subEl.classList.add(params.progressbarOppositeClass);\n      }\n      if (params.clickable) {\n        subEl.addEventListener('click', onBulletClick);\n      }\n      if (!swiper.enabled) {\n        subEl.classList.add(params.lockClass);\n      }\n    });\n  }\n  function destroy() {\n    const params = swiper.params.pagination;\n    if (isPaginationDisabled()) return;\n    let el = swiper.pagination.el;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.classList.remove(params.hiddenClass);\n        subEl.classList.remove(params.modifierClass + params.type);\n        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        if (params.clickable) {\n          subEl.classList.remove(...(params.clickableClass || '').split(' '));\n          subEl.removeEventListener('click', onBulletClick);\n        }\n      });\n    }\n    if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));\n  }\n  on('changeDirection', () => {\n    if (!swiper.pagination || !swiper.pagination.el) return;\n    const params = swiper.params.pagination;\n    let {\n      el\n    } = swiper.pagination;\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.classList.remove(params.horizontalClass, params.verticalClass);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    });\n  });\n  on('init', () => {\n    if (swiper.params.pagination.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      render();\n      update();\n    }\n  });\n  on('activeIndexChange', () => {\n    if (typeof swiper.snapIndex === 'undefined') {\n      update();\n    }\n  });\n  on('snapIndexChange', () => {\n    update();\n  });\n  on('snapGridLengthChange', () => {\n    render();\n    update();\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  on('enable disable', () => {\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));\n    }\n  });\n  on('lock unlock', () => {\n    update();\n  });\n  on('click', (_s, e) => {\n    const targetEl = e.target;\n    const el = makeElementsArray(swiper.pagination.el);\n    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n      if (isHidden === true) {\n        emit('paginationShow');\n      } else {\n        emit('paginationHide');\n      }\n      el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n    }\n  });\n  const enable = () => {\n    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n    }\n    init();\n    render();\n    update();\n  };\n  const disable = () => {\n    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n    let {\n      el\n    } = swiper.pagination;\n    if (el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n    }\n    destroy();\n  };\n  Object.assign(swiper.pagination, {\n    enable,\n    disable,\n    render,\n    update,\n    init,\n    destroy\n  });\n}\n\nexport { Pagination as default };\n","import {Tag} from \"lucide-react\";\n\nimport { useState, useEffect } from \"react\";\n\nexport default function BestSellingStores() {\n    const [shops, setShops] = useState<any[]>([]);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n        fetch(\"/api/shops\")\n            .then(res => res.json())\n            .then(data => {\n                setShops(data);\n                setLoading(false);\n            });\n    }, []);\n\n    if (loading) return <div className=\"py-10 text-center\">Loading Stores...</div>;\n\n\n    return (\n        <section className=\"py-10 px-6 sm:px-10 \">\n            {/* Cashback Banner */}\n\n                <div className=\"mx-auto flex flex-col sm:flex-row items-center justify-between gap-6 mb-12\">\n                    <img src=\"/cashback.png\" alt=\"Cashback Banner\" className=\"rounded-sm\"/>\n            </div>\n\n            {/* Best Selling Stores */}\n            <span className=\"flex gap-1 items-center mb-6\">\n            <img src=\"/bar.png\" alt=\"bar\" className=\"h-7 w-10\" />\n                <p className=\"text-blue-600 font-bold text-2xl\"> Best Selling Stores </p>\n            </span>\n\n\n            <div className=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 sm:gap-8 gap-2\">\n                {shops.map((store, index) => (\n                    <a \n                        key={index} \n                        href={`/shops/${store.id}`}\n                        className=\"relative bg-gray-50 rounded-xl shadow-2xl hover:shadow-2xl hover:scale-105 transition-transform duration-300 overflow-hidden cursor-pointer no-underline block\"\n                    >\n                        {/* Cover Image */}\n                        <img\n                            src={store.cover_url || \"/covers/staples.jpg\"}\n                            alt={`${store.name} cover`}\n                            className=\"w-full h-60 object-cover rounded-xl\"\n                        />\n\n                        {/* Logo - overlapping circle */}\n                        <div className=\"absolute top-50 left-1/2 transform -translate-x-1/2\">\n                            <img\n                                src={store.logo_url}\n                                alt={`${store.name} logo`}\n                                className=\"w-20 h-20 rounded-full border-4 border-white shadow-[0_10px_10px_rgba(0,0,0,0.2)]\"\n                            />\n                        </div>\n\n                        {/* Store Info */}\n                        <div className=\"pt-12 pb-4 px-4 text-center\">\n                            <h3 className=\"text-xl font-bold text-gray-800\">{store.name}</h3>\n                            <p className=\"text-xs font-semibold text-gray-500 mt-1 line-clamp-1\">{store.description}</p>\n                            <span className=\"flex items-center justify-center mt-2 gap-1\">\n                                <Tag className=\"text-blue-500 h-4 w-4 mt-1\"/>\n                                <p className=\"text-xs font-semibold text-blue-500\">Official Store</p>\n                            </span>\n                        </div>\n                    </a>\n                ))}\n            </div>\n\n\n        </section>\n    )\n}","import { c as createShadow } from '../shared/create-shadow.mjs';\nimport { e as effectInit } from '../shared/effect-init.mjs';\nimport { e as effectTarget } from '../shared/effect-target.mjs';\nimport { g as getSlideTransformEl, a as getRotateFix } from '../shared/utils.mjs';\n\nfunction EffectCoverflow({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    coverflowEffect: {\n      rotate: 50,\n      stretch: 0,\n      depth: 100,\n      scale: 1,\n      modifier: 1,\n      slideShadows: true\n    }\n  });\n  const setTranslate = () => {\n    const {\n      width: swiperWidth,\n      height: swiperHeight,\n      slides,\n      slidesSizesGrid\n    } = swiper;\n    const params = swiper.params.coverflowEffect;\n    const isHorizontal = swiper.isHorizontal();\n    const transform = swiper.translate;\n    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n    const rotate = isHorizontal ? params.rotate : -params.rotate;\n    const translate = params.depth;\n    const r = getRotateFix(swiper);\n    // Each slide offset from center\n    for (let i = 0, length = slides.length; i < length; i += 1) {\n      const slideEl = slides[i];\n      const slideSize = slidesSizesGrid[i];\n      const slideOffset = slideEl.swiperSlideOffset;\n      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n      const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;\n      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n      // var rotateZ = 0\n      let translateZ = -translate * Math.abs(offsetMultiplier);\n      let stretch = params.stretch;\n      // Allow percentage to make a relative stretch for responsive sliders\n      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n        stretch = parseFloat(params.stretch) / 100 * slideSize;\n      }\n      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n      // Fix for ultra small values\n      if (Math.abs(translateX) < 0.001) translateX = 0;\n      if (Math.abs(translateY) < 0.001) translateY = 0;\n      if (Math.abs(translateZ) < 0.001) translateZ = 0;\n      if (Math.abs(rotateY) < 0.001) rotateY = 0;\n      if (Math.abs(rotateX) < 0.001) rotateX = 0;\n      if (Math.abs(scale) < 0.001) scale = 0;\n      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${r(rotateX)}deg) rotateY(${r(rotateY)}deg) scale(${scale})`;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = slideTransform;\n      slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n        let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n        if (!shadowBeforeEl) {\n          shadowBeforeEl = createShadow('coverflow', slideEl, isHorizontal ? 'left' : 'top');\n        }\n        if (!shadowAfterEl) {\n          shadowAfterEl = createShadow('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');\n        }\n        if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n        if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n      }\n    }\n  };\n  const setTransition = duration => {\n    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n    transformElements.forEach(el => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n  };\n  effectInit({\n    effect: 'coverflow',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => true,\n    overwriteParams: () => ({\n      watchSlidesProgress: true\n    })\n  });\n}\n\nexport { EffectCoverflow as default };\n","import { transform } from 'motion-dom';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\nimport { useComputed } from './use-computed.mjs';\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    if (typeof input === \"function\") {\n        return useComputed(input);\n    }\n    const transformer = typeof inputRangeOrTransformer === \"function\"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], ([latest]) => transformer(latest));\n}\nfunction useListTransform(values, transformer) {\n    const latest = useConstant(() => []);\n    return useCombineMotionValues(values, () => {\n        latest.length = 0;\n        const numValues = values.length;\n        for (let i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\n\nexport { useTransform };\n","import { resize, frame, cancelFrame, frameData } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { createScrollInfo } from './info.mjs';\nimport { createOnScrollHandler } from './on-scroll-handler.mjs';\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.scrollingElement ? window : element;\nfunction scrollInfo(onScroll, { container = document.scrollingElement, ...options } = {}) {\n    if (!container)\n        return noop;\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp);\n            }\n            frame.preUpdate(notifyAll);\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify();\n            }\n        };\n        const listener = () => frame.read(measureAll);\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n        listener();\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            resizeListeners.get(container)?.();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n    };\n}\n\nexport { scrollInfo };\n","import { g as getDocument } from '../shared/ssr-window.esm.mjs';\nimport { m as makeElementsArray, k as classesToTokens, c as createElement, n as nextTick, f as elementOffset } from '../shared/utils.mjs';\nimport { c as createElementIfNotDefined } from '../shared/create-element-if-not-defined.mjs';\nimport { c as classesToSelector } from '../shared/classes-to-selector.mjs';\n\nfunction Scrollbar({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const document = getDocument();\n  let isTouched = false;\n  let timeout = null;\n  let dragTimeout = null;\n  let dragStartPos;\n  let dragSize;\n  let trackSize;\n  let divider;\n  extendParams({\n    scrollbar: {\n      el: null,\n      dragSize: 'auto',\n      hide: false,\n      draggable: false,\n      snapOnRelease: true,\n      lockClass: 'swiper-scrollbar-lock',\n      dragClass: 'swiper-scrollbar-drag',\n      scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n      horizontalClass: `swiper-scrollbar-horizontal`,\n      verticalClass: `swiper-scrollbar-vertical`\n    }\n  });\n  swiper.scrollbar = {\n    el: null,\n    dragEl: null\n  };\n  function setTranslate() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    const {\n      scrollbar,\n      rtlTranslate: rtl\n    } = swiper;\n    const {\n      dragEl,\n      el\n    } = scrollbar;\n    const params = swiper.params.scrollbar;\n    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n    let newSize = dragSize;\n    let newPos = (trackSize - dragSize) * progress;\n    if (rtl) {\n      newPos = -newPos;\n      if (newPos > 0) {\n        newSize = dragSize - newPos;\n        newPos = 0;\n      } else if (-newPos + dragSize > trackSize) {\n        newSize = trackSize + newPos;\n      }\n    } else if (newPos < 0) {\n      newSize = dragSize + newPos;\n      newPos = 0;\n    } else if (newPos + dragSize > trackSize) {\n      newSize = trackSize - newPos;\n    }\n    if (swiper.isHorizontal()) {\n      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n      dragEl.style.width = `${newSize}px`;\n    } else {\n      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n      dragEl.style.height = `${newSize}px`;\n    }\n    if (params.hide) {\n      clearTimeout(timeout);\n      el.style.opacity = 1;\n      timeout = setTimeout(() => {\n        el.style.opacity = 0;\n        el.style.transitionDuration = '400ms';\n      }, 1000);\n    }\n  }\n  function setTransition(duration) {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n  }\n  function updateSize() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    const {\n      scrollbar\n    } = swiper;\n    const {\n      dragEl,\n      el\n    } = scrollbar;\n    dragEl.style.width = '';\n    dragEl.style.height = '';\n    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n    if (swiper.params.scrollbar.dragSize === 'auto') {\n      dragSize = trackSize * divider;\n    } else {\n      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n    }\n    if (swiper.isHorizontal()) {\n      dragEl.style.width = `${dragSize}px`;\n    } else {\n      dragEl.style.height = `${dragSize}px`;\n    }\n    if (divider >= 1) {\n      el.style.display = 'none';\n    } else {\n      el.style.display = '';\n    }\n    if (swiper.params.scrollbar.hide) {\n      el.style.opacity = 0;\n    }\n    if (swiper.params.watchOverflow && swiper.enabled) {\n      scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n    }\n  }\n  function getPointerPosition(e) {\n    return swiper.isHorizontal() ? e.clientX : e.clientY;\n  }\n  function setDragPosition(e) {\n    const {\n      scrollbar,\n      rtlTranslate: rtl\n    } = swiper;\n    const {\n      el\n    } = scrollbar;\n    let positionRatio;\n    positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n    positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n    if (rtl) {\n      positionRatio = 1 - positionRatio;\n    }\n    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n    swiper.updateProgress(position);\n    swiper.setTranslate(position);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  function onDragStart(e) {\n    const params = swiper.params.scrollbar;\n    const {\n      scrollbar,\n      wrapperEl\n    } = swiper;\n    const {\n      el,\n      dragEl\n    } = scrollbar;\n    isTouched = true;\n    dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\n    e.preventDefault();\n    e.stopPropagation();\n    wrapperEl.style.transitionDuration = '100ms';\n    dragEl.style.transitionDuration = '100ms';\n    setDragPosition(e);\n    clearTimeout(dragTimeout);\n    el.style.transitionDuration = '0ms';\n    if (params.hide) {\n      el.style.opacity = 1;\n    }\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style['scroll-snap-type'] = 'none';\n    }\n    emit('scrollbarDragStart', e);\n  }\n  function onDragMove(e) {\n    const {\n      scrollbar,\n      wrapperEl\n    } = swiper;\n    const {\n      el,\n      dragEl\n    } = scrollbar;\n    if (!isTouched) return;\n    if (e.preventDefault && e.cancelable) e.preventDefault();else e.returnValue = false;\n    setDragPosition(e);\n    wrapperEl.style.transitionDuration = '0ms';\n    el.style.transitionDuration = '0ms';\n    dragEl.style.transitionDuration = '0ms';\n    emit('scrollbarDragMove', e);\n  }\n  function onDragEnd(e) {\n    const params = swiper.params.scrollbar;\n    const {\n      scrollbar,\n      wrapperEl\n    } = swiper;\n    const {\n      el\n    } = scrollbar;\n    if (!isTouched) return;\n    isTouched = false;\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.style['scroll-snap-type'] = '';\n      wrapperEl.style.transitionDuration = '';\n    }\n    if (params.hide) {\n      clearTimeout(dragTimeout);\n      dragTimeout = nextTick(() => {\n        el.style.opacity = 0;\n        el.style.transitionDuration = '400ms';\n      }, 1000);\n    }\n    emit('scrollbarDragEnd', e);\n    if (params.snapOnRelease) {\n      swiper.slideToClosest();\n    }\n  }\n  function events(method) {\n    const {\n      scrollbar,\n      params\n    } = swiper;\n    const el = scrollbar.el;\n    if (!el) return;\n    const target = el;\n    const activeListener = params.passiveListeners ? {\n      passive: false,\n      capture: false\n    } : false;\n    const passiveListener = params.passiveListeners ? {\n      passive: true,\n      capture: false\n    } : false;\n    if (!target) return;\n    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n    target[eventMethod]('pointerdown', onDragStart, activeListener);\n    document[eventMethod]('pointermove', onDragMove, activeListener);\n    document[eventMethod]('pointerup', onDragEnd, passiveListener);\n  }\n  function enableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    events('on');\n  }\n  function disableDraggable() {\n    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n    events('off');\n  }\n  function init() {\n    const {\n      scrollbar,\n      el: swiperEl\n    } = swiper;\n    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n      el: 'swiper-scrollbar'\n    });\n    const params = swiper.params.scrollbar;\n    if (!params.el) return;\n    let el;\n    if (typeof params.el === 'string' && swiper.isElement) {\n      el = swiper.el.querySelector(params.el);\n    }\n    if (!el && typeof params.el === 'string') {\n      el = document.querySelectorAll(params.el);\n      if (!el.length) return;\n    } else if (!el) {\n      el = params.el;\n    }\n    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n      el = swiperEl.querySelector(params.el);\n    }\n    if (el.length > 0) el = el[0];\n    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    let dragEl;\n    if (el) {\n      dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));\n      if (!dragEl) {\n        dragEl = createElement('div', swiper.params.scrollbar.dragClass);\n        el.append(dragEl);\n      }\n    }\n    Object.assign(scrollbar, {\n      el,\n      dragEl\n    });\n    if (params.draggable) {\n      enableDraggable();\n    }\n    if (el) {\n      el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));\n    }\n  }\n  function destroy() {\n    const params = swiper.params.scrollbar;\n    const el = swiper.scrollbar.el;\n    if (el) {\n      el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));\n    }\n    disableDraggable();\n  }\n  on('changeDirection', () => {\n    if (!swiper.scrollbar || !swiper.scrollbar.el) return;\n    const params = swiper.params.scrollbar;\n    let {\n      el\n    } = swiper.scrollbar;\n    el = makeElementsArray(el);\n    el.forEach(subEl => {\n      subEl.classList.remove(params.horizontalClass, params.verticalClass);\n      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n    });\n  });\n  on('init', () => {\n    if (swiper.params.scrollbar.enabled === false) {\n      // eslint-disable-next-line\n      disable();\n    } else {\n      init();\n      updateSize();\n      setTranslate();\n    }\n  });\n  on('update resize observerUpdate lock unlock changeDirection', () => {\n    updateSize();\n  });\n  on('setTranslate', () => {\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    setTransition(duration);\n  });\n  on('enable disable', () => {\n    const {\n      el\n    } = swiper.scrollbar;\n    if (el) {\n      el.classList[swiper.enabled ? 'remove' : 'add'](...classesToTokens(swiper.params.scrollbar.lockClass));\n    }\n  });\n  on('destroy', () => {\n    destroy();\n  });\n  const enable = () => {\n    swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n    if (swiper.scrollbar.el) {\n      swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n    }\n    init();\n    updateSize();\n    setTranslate();\n  };\n  const disable = () => {\n    swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n    if (swiper.scrollbar.el) {\n      swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));\n    }\n    destroy();\n  };\n  Object.assign(swiper.scrollbar, {\n    enable,\n    disable,\n    updateSize,\n    setTranslate,\n    init,\n    destroy\n  });\n}\n\nexport { Scrollbar as default };\n","import { e as effectInit } from '../shared/effect-init.mjs';\nimport { e as effectTarget } from '../shared/effect-target.mjs';\nimport { e as effectVirtualTransitionEnd } from '../shared/effect-virtual-transition-end.mjs';\nimport { g as getSlideTransformEl } from '../shared/utils.mjs';\n\nfunction EffectFade({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    fadeEffect: {\n      crossFade: false\n    }\n  });\n  const setTranslate = () => {\n    const {\n      slides\n    } = swiper;\n    const params = swiper.params.fadeEffect;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = swiper.slides[i];\n      const offset = slideEl.swiperSlideOffset;\n      let tx = -offset;\n      if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.opacity = slideOpacity;\n      targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n    }\n  };\n  const setTransition = duration => {\n    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n    transformElements.forEach(el => {\n      el.style.transitionDuration = `${duration}ms`;\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements,\n      allSlides: true\n    });\n  };\n  effectInit({\n    effect: 'fade',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\n\nexport { EffectFade as default };\n","import { c as createShadow } from '../shared/create-shadow.mjs';\nimport { e as effectInit } from '../shared/effect-init.mjs';\nimport { e as effectTarget } from '../shared/effect-target.mjs';\nimport { e as effectVirtualTransitionEnd } from '../shared/effect-virtual-transition-end.mjs';\nimport { g as getSlideTransformEl, a as getRotateFix } from '../shared/utils.mjs';\n\nfunction EffectCreative({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    creativeEffect: {\n      limitProgress: 1,\n      shadowPerProgress: false,\n      progressMultiplier: 1,\n      perspective: true,\n      prev: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1\n      },\n      next: {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        opacity: 1,\n        scale: 1\n      }\n    }\n  });\n  const getTranslateValue = value => {\n    if (typeof value === 'string') return value;\n    return `${value}px`;\n  };\n  const setTranslate = () => {\n    const {\n      slides,\n      wrapperEl,\n      slidesSizesGrid\n    } = swiper;\n    const params = swiper.params.creativeEffect;\n    const {\n      progressMultiplier: multiplier\n    } = params;\n    const isCenteredSlides = swiper.params.centeredSlides;\n    const rotateFix = getRotateFix(swiper);\n    if (isCenteredSlides) {\n      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n      wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideProgress = slideEl.progress;\n      const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n      let originalProgress = progress;\n      if (!isCenteredSlides) {\n        originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n      }\n      const offset = slideEl.swiperSlideOffset;\n      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n      const r = [0, 0, 0];\n      let custom = false;\n      if (!swiper.isHorizontal()) {\n        t[1] = t[0];\n        t[0] = 0;\n      }\n      let data = {\n        translate: [0, 0, 0],\n        rotate: [0, 0, 0],\n        scale: 1,\n        opacity: 1\n      };\n      if (progress < 0) {\n        data = params.next;\n        custom = true;\n      } else if (progress > 0) {\n        data = params.prev;\n        custom = true;\n      }\n      // set translate\n      t.forEach((value, index) => {\n        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n      });\n      // set rotates\n      r.forEach((value, index) => {\n        let val = data.rotate[index] * Math.abs(progress * multiplier);\n        r[index] = val;\n      });\n      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n      const translateString = t.join(', ');\n      const rotateString = `rotateX(${rotateFix(r[0])}deg) rotateY(${rotateFix(r[1])}deg) rotateZ(${rotateFix(r[2])}deg)`;\n      const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n      // Set shadows\n      if (custom && data.shadow || !custom) {\n        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n        if (!shadowEl && data.shadow) {\n          shadowEl = createShadow('creative', slideEl);\n        }\n        if (shadowEl) {\n          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n          shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n        }\n      }\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n      targetEl.style.opacity = opacityString;\n      if (data.origin) {\n        targetEl.style.transformOrigin = data.origin;\n      }\n    }\n  };\n  const setTransition = duration => {\n    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n    transformElements.forEach(el => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements,\n      allSlides: true\n    });\n  };\n  effectInit({\n    effect: 'creative',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => swiper.params.creativeEffect.perspective,\n    overwriteParams: () => ({\n      watchSlidesProgress: true,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\n\nexport { EffectCreative as default };\n","import { c as createShadow } from '../shared/create-shadow.mjs';\nimport { e as effectInit } from '../shared/effect-init.mjs';\nimport { e as effectTarget } from '../shared/effect-target.mjs';\nimport { e as effectVirtualTransitionEnd } from '../shared/effect-virtual-transition-end.mjs';\nimport { g as getSlideTransformEl } from '../shared/utils.mjs';\n\nfunction EffectCards({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    cardsEffect: {\n      slideShadows: true,\n      rotate: true,\n      perSlideRotate: 2,\n      perSlideOffset: 8\n    }\n  });\n  const setTranslate = () => {\n    const {\n      slides,\n      activeIndex,\n      rtlTranslate: rtl\n    } = swiper;\n    const params = swiper.params.cardsEffect;\n    const {\n      startTranslate,\n      isTouched\n    } = swiper.touchEventsData;\n    const currentTranslate = rtl ? -swiper.translate : swiper.translate;\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      const slideProgress = slideEl.progress;\n      const progress = Math.min(Math.max(slideProgress, -4), 4);\n      let offset = slideEl.swiperSlideOffset;\n      if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n        swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n      }\n      if (swiper.params.centeredSlides && swiper.params.cssMode) {\n        offset -= slides[0].swiperSlideOffset;\n      }\n      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let tY = 0;\n      const tZ = -100 * Math.abs(progress);\n      let scale = 1;\n      let rotate = -params.perSlideRotate * progress;\n      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n      const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n      const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n      const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n      if (isSwipeToNext || isSwipeToPrev) {\n        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n        rotate += -28 * progress * subProgress;\n        scale += -0.5 * subProgress;\n        tXAdd += 96 * subProgress;\n        tY = `${(params.rotate || swiper.isHorizontal() ? -25 : 0) * subProgress * Math.abs(progress)}%`;\n      }\n      if (progress < 0) {\n        // next\n        tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;\n      } else if (progress > 0) {\n        // prev\n        tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;\n      } else {\n        tX = `${tX}px`;\n      }\n      if (!swiper.isHorizontal()) {\n        const prevY = tY;\n        tY = tX;\n        tX = prevY;\n      }\n      const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n      /* eslint-disable */\n      const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n      /* eslint-enable */\n\n      if (params.slideShadows) {\n        // Set shadows\n        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n        if (!shadowEl) {\n          shadowEl = createShadow('cards', slideEl);\n        }\n        if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n      }\n      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n    }\n  };\n  const setTransition = duration => {\n    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n    transformElements.forEach(el => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements\n    });\n  };\n  effectInit({\n    effect: 'cards',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    perspective: () => true,\n    overwriteParams: () => ({\n      _loopSwapReset: false,\n      watchSlidesProgress: true,\n      loopAdditionalSlides: swiper.params.cardsEffect.rotate ? 3 : 2,\n      centeredSlides: true,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\n\nexport { EffectCards as default };\n","import { c as createShadow } from '../shared/create-shadow.mjs';\nimport { e as effectInit } from '../shared/effect-init.mjs';\nimport { e as effectTarget } from '../shared/effect-target.mjs';\nimport { e as effectVirtualTransitionEnd } from '../shared/effect-virtual-transition-end.mjs';\nimport { g as getSlideTransformEl, a as getRotateFix } from '../shared/utils.mjs';\n\nfunction EffectFlip({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    flipEffect: {\n      slideShadows: true,\n      limitRotation: true\n    }\n  });\n  const createSlideShadows = (slideEl, progress) => {\n    let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n    let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n    if (!shadowBefore) {\n      shadowBefore = createShadow('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');\n    }\n    if (!shadowAfter) {\n      shadowAfter = createShadow('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n    }\n    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n  };\n  const recreateShadows = () => {\n    // Set shadows\n    swiper.params.flipEffect;\n    swiper.slides.forEach(slideEl => {\n      let progress = slideEl.progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      createSlideShadows(slideEl, progress);\n    });\n  };\n  const setTranslate = () => {\n    const {\n      slides,\n      rtlTranslate: rtl\n    } = swiper;\n    const params = swiper.params.flipEffect;\n    const rotateFix = getRotateFix(swiper);\n    for (let i = 0; i < slides.length; i += 1) {\n      const slideEl = slides[i];\n      let progress = slideEl.progress;\n      if (swiper.params.flipEffect.limitRotation) {\n        progress = Math.max(Math.min(slideEl.progress, 1), -1);\n      }\n      const offset = slideEl.swiperSlideOffset;\n      const rotate = -180 * progress;\n      let rotateY = rotate;\n      let rotateX = 0;\n      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n      let ty = 0;\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n        rotateX = -rotateY;\n        rotateY = 0;\n      } else if (rtl) {\n        rotateY = -rotateY;\n      }\n      slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n      if (params.slideShadows) {\n        createSlideShadows(slideEl, progress);\n      }\n      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateFix(rotateX)}deg) rotateY(${rotateFix(rotateY)}deg)`;\n      const targetEl = effectTarget(params, slideEl);\n      targetEl.style.transform = transform;\n    }\n  };\n  const setTransition = duration => {\n    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n    transformElements.forEach(el => {\n      el.style.transitionDuration = `${duration}ms`;\n      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n        shadowEl.style.transitionDuration = `${duration}ms`;\n      });\n    });\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformElements\n    });\n  };\n  effectInit({\n    effect: 'flip',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    recreateShadows,\n    getEffectParams: () => swiper.params.flipEffect,\n    perspective: () => true,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}\n\nexport { EffectFlip as default };\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,12,13,14,15,16,17,18,19,20,21,22,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68]}